<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/11/11/hello-world/"/>
    <url>/2020/11/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA插件合集</title>
    <link href="/2020/07/02/2020-07-02-IDEA%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/"/>
    <url>/2020/07/02/2020-07-02-IDEA%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h6 id="1-Key-Promoter-X：-快捷键提示"><a href="#1-Key-Promoter-X：-快捷键提示" class="headerlink" title="1. Key Promoter X： 快捷键提示"></a>1. Key Promoter X： 快捷键提示</h6><h6 id="2-Rainbow-Brackets：-彩虹括号"><a href="#2-Rainbow-Brackets：-彩虹括号" class="headerlink" title="2. Rainbow Brackets： 彩虹括号"></a>2. Rainbow Brackets： 彩虹括号</h6><h6 id="3-Codota：-代码智能提示"><a href="#3-Codota：-代码智能提示" class="headerlink" title="3. Codota： 代码智能提示"></a>3. Codota： 代码智能提示</h6><h6 id="4-Lombok：-减少冗长代码"><a href="#4-Lombok：-减少冗长代码" class="headerlink" title="4. Lombok： 减少冗长代码"></a>4. Lombok： 减少冗长代码</h6><h6 id="5-String-Manipulation：-字符串操作"><a href="#5-String-Manipulation：-字符串操作" class="headerlink" title="5. String Manipulation： 字符串操作"></a>5. String Manipulation： 字符串操作</h6><h6 id="6-Maven-Helper：-Maven冲突依赖插件"><a href="#6-Maven-Helper：-Maven冲突依赖插件" class="headerlink" title="6. Maven Helper： Maven冲突依赖插件"></a>6. Maven Helper： Maven冲突依赖插件</h6><h6 id="7-Translation：-中英文翻译工具"><a href="#7-Translation：-中英文翻译工具" class="headerlink" title="7. Translation： 中英文翻译工具"></a>7. Translation： 中英文翻译工具</h6><h6 id="8-Alibaba-Java-Coding-Guidelines：-阿里巴巴代码规约规范"><a href="#8-Alibaba-Java-Coding-Guidelines：-阿里巴巴代码规约规范" class="headerlink" title="8. Alibaba Java Coding Guidelines： 阿里巴巴代码规约规范"></a>8. Alibaba Java Coding Guidelines： 阿里巴巴代码规约规范</h6><h6 id="9-MybatisX：-Mapper-接口和-XML-文件之间跳转"><a href="#9-MybatisX：-Mapper-接口和-XML-文件之间跳转" class="headerlink" title="9. MybatisX： Mapper 接口和 XML 文件之间跳转"></a>9. MybatisX： Mapper 接口和 XML 文件之间跳转</h6><h6 id="10-CodeGlance：-右侧显示的代码地图"><a href="#10-CodeGlance：-右侧显示的代码地图" class="headerlink" title="10. CodeGlance： 右侧显示的代码地图"></a>10. CodeGlance： 右侧显示的代码地图</h6><h6 id="11-Iedis：-Redis可视化工具"><a href="#11-Iedis：-Redis可视化工具" class="headerlink" title="11. Iedis： Redis可视化工具"></a>11. Iedis： Redis可视化工具</h6><h6 id="12-mybatis-log-plugin：-控制台提取一个的输出sql语句"><a href="#12-mybatis-log-plugin：-控制台提取一个的输出sql语句" class="headerlink" title="12. mybatis-log-plugin： 控制台提取一个的输出sql语句"></a>12. mybatis-log-plugin： 控制台提取一个的输出sql语句</h6><h6 id="13-pojo-to-json：-Java-对象转换JSON-字符串"><a href="#13-pojo-to-json：-Java-对象转换JSON-字符串" class="headerlink" title="13. pojo-to-json： Java 对象转换JSON 字符串"></a>13. pojo-to-json： Java 对象转换JSON 字符串</h6><h6 id="14-JUnitGenerator：-自动生成单元测试代码"><a href="#14-JUnitGenerator：-自动生成单元测试代码" class="headerlink" title="14. JUnitGenerator： 自动生成单元测试代码"></a>14. JUnitGenerator： 自动生成单元测试代码</h6><h6 id="15-GsonFormat：-快速将JSON字符串转为类"><a href="#15-GsonFormat：-快速将JSON字符串转为类" class="headerlink" title="15. GsonFormat： 快速将JSON字符串转为类"></a>15. GsonFormat： 快速将JSON字符串转为类</h6>]]></content>
    
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="/2020/06/28/2020-06-28-MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2020/06/28/2020-06-28-MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h6 id="1-查询-SQL-尽量不要使用-select-，而是-select-具体字段"><a href="#1-查询-SQL-尽量不要使用-select-，而是-select-具体字段" class="headerlink" title="1. 查询 SQL 尽量不要使用 select *，而是 select 具体字段"></a>1. 查询 SQL 尽量不要使用 select *，而是 select 具体字段</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例子:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employee;<span class="hljs-comment">### 正例子:</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>，<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee;</code></pre><ul><li>只取需要的字段，节省资源、减少网络开销。</li><li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li></ul><h6 id="2-如果知道查询结果只有一条或者只要最大-最小一条记录，建议用-limit-1"><a href="#2-如果知道查询结果只有一条或者只要最大-最小一条记录，建议用-limit-1" class="headerlink" title="2. 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用 limit 1"></a>2. 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用 limit 1</h6><pre><code class="hljs routeros">CREATE TABLE `employee` (  `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  `name` varchar(255)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,  `age` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,  `date` datetime<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,  `sex` int(1)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,  PRIMARY KEY (`id`)) <span class="hljs-attribute">ENGINE</span>=InnoDB<span class="hljs-built_in"> DEFAULT </span><span class="hljs-attribute">CHARSET</span>=utf8mb4;</code></pre><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>，<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;jay&#x27;</span><span class="hljs-comment">### 正例:</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>，<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;jay&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;</code></pre><ul><li>加上 limit 1 后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li><li>当然，如果 name 是唯一索引的话，是不必要加上 limit 1 了，因为 limit 的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有 limit ，性能的差别并不大。</li></ul><h6 id="3-应尽量避免在-where-子句中使用-or-来连接条件"><a href="#3-应尽量避免在-where-子句中使用-or-来连接条件" class="headerlink" title="3. 应尽量避免在 where 子句中使用 or 来连接条件"></a>3. 应尽量避免在 where 子句中使用 or 来连接条件</h6><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-symbol">`userId`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_userId`</span> (<span class="hljs-symbol">`userId`</span>)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code></pre><p>假设现在需要查询 userId 为 1 或者年龄为 18 岁的用户，很容易有以下 sql</p><pre><code class="hljs crystal"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span> * from user where userid=<span class="hljs-number">1</span> or age =<span class="hljs-number">18</span><span class="hljs-comment">### 正例：</span>/<span class="hljs-regexp">/ 使用union all</span><span class="hljs-regexp">select * from user where userid=1</span><span class="hljs-regexp">union all</span><span class="hljs-regexp">select * from user where age = 18</span><span class="hljs-regexp"></span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ 或者分开两条sql写：</span><span class="hljs-regexp">select * from user where userid=1</span><span class="hljs-regexp">select * from user where age = 18</span></code></pre><ul><li>使用 or 可能会使索引失效，从而全表扫描。<br>对于 or+没有索引的 age 这种情况，假设它走了 userId 的索引，但是走到 age 查询条件时，它还得全表扫描，<br>也就是需要三步过程：全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。<br>mysql 是有优化器的，处于效率与成本考虑，遇到 or 条件，索引可能失效，看起来也合情合理。<br>建议 age 也添加索引</li></ul><h6 id="4-优化-limit-分页"><a href="#4-优化-limit-分页" class="headerlink" title="4. 优化 limit 分页"></a>4. 优化 limit 分页</h6><pre><code class="hljs clean">### 反例:select * <span class="hljs-keyword">from</span> saleshistory limit <span class="hljs-number">10000000</span>,<span class="hljs-number">10</span>### 正例:<span class="hljs-comment">//方案一 ：返回上次查询的最大记录(偏移量)</span>select * <span class="hljs-keyword">from</span> saleshistory <span class="hljs-keyword">where</span> id&gt; <span class="hljs-number">10000000</span> limit <span class="hljs-number">10</span></code></pre><h6 id="5-优化你的-like-语句"><a href="#5-优化你的-like-语句" class="headerlink" title="5. 优化你的 like 语句"></a>5. 优化你的 like 语句</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>select userId，name <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userId like <span class="hljs-string">&#x27;%123&#x27;</span><span class="hljs-comment">### 正例:</span>select userId，name <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userId like <span class="hljs-string">&#x27;123%&#x27;</span>;</code></pre><h6 id="6-使用-where-条件限定要查询的数据，避免返回多余的行"><a href="#6-使用-where-条件限定要查询的数据，避免返回多余的行" class="headerlink" title="6. 使用 where 条件限定要查询的数据，避免返回多余的行"></a>6. 使用 where 条件限定要查询的数据，避免返回多余的行</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>select userId <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">isVip</span>=1<span class="hljs-comment">### 正例:</span>select userId <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">userId</span>=<span class="hljs-string">&#x27;userId&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">isVip</span>=<span class="hljs-string">&#x27;1&#x27;</span></code></pre><h6 id="7-尽量避免在索引列上使用-mysql-的内置函数"><a href="#7-尽量避免在索引列上使用-mysql-的内置函数" class="headerlink" title="7. 尽量避免在索引列上使用 mysql 的内置函数"></a>7. 尽量避免在索引列上使用 mysql 的内置函数</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span> userId,loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span> <span class="hljs-keyword">Date_ADD</span>(loginTime,<span class="hljs-built_in">Interval</span> <span class="hljs-number">7</span> <span class="hljs-keyword">DAY</span>) &gt;=<span class="hljs-keyword">now</span>();<span class="hljs-comment">### 正例:</span><span class="hljs-keyword">select</span> userId,loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span> loginTime &gt;= <span class="hljs-keyword">Date_SUB</span>(<span class="hljs-keyword">now</span>() ,<span class="hljs-built_in">Interval</span> <span class="hljs-number">7</span> <span class="hljs-keyword">DAY</span>);</code></pre><h6 id="8-应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"><a href="#8-应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫" class="headerlink" title="8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"></a>8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age-1 =10<span class="hljs-comment">### 正例:</span>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age =11</code></pre><h6 id="9-Inner-join-、left-join、right-join，优先使用-Inner-join，如果是-left-join，左边表结果尽量小"><a href="#9-Inner-join-、left-join、right-join，优先使用-Inner-join，如果是-left-join，左边表结果尽量小" class="headerlink" title="9. Inner join 、left join、right join，优先使用 Inner join，如果是 left join，左边表结果尽量小"></a>9. Inner join 、left join、right join，优先使用 Inner join，如果是 left join，左边表结果尽量小</h6><ul><li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录</li></ul><pre><code class="hljs apache"><span class="hljs-comment">### 反例:</span><span class="hljs-attribute">select</span> * from tab<span class="hljs-number">1</span> t<span class="hljs-number">1</span> left join tab<span class="hljs-number">2</span> t<span class="hljs-number">2</span>  <span class="hljs-literal">on</span> t<span class="hljs-number">1</span>.size = t<span class="hljs-number">2</span>.size where t<span class="hljs-number">1</span>.id &gt; <span class="hljs-number">2</span><span class="hljs-comment">### 正例:</span><span class="hljs-attribute">select</span> * from (select * from tab<span class="hljs-number">1</span> where id &gt;<span class="hljs-number">2</span>) t<span class="hljs-number">1</span> left join tab<span class="hljs-number">2</span> t<span class="hljs-number">2</span> <span class="hljs-literal">on</span> t<span class="hljs-number">1</span>.size = t<span class="hljs-number">2</span>.size</code></pre><h6 id="10-应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描"><a href="#10-应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描" class="headerlink" title="10. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描"></a>10. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span> age,<span class="hljs-keyword">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &lt;&gt;<span class="hljs-number">18</span>;<span class="hljs-comment">### 正例:</span>//可以考虑分开两条sql写<span class="hljs-keyword">select</span> age,<span class="hljs-keyword">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &lt;<span class="hljs-number">18</span>;<span class="hljs-keyword">select</span> age,<span class="hljs-keyword">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt;<span class="hljs-number">18</span>;</code></pre><h6 id="11-使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则"><a href="#11-使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则" class="headerlink" title="11. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则"></a>11. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则</h6><p>表结构：（联合索引 idx_userId_age，userId 在前，age 在后）</p><pre><code class="hljs routeros">CREATE TABLE `user` (  `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  `userId` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  `age` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,  `name` varchar(255) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  PRIMARY KEY (`id`),  KEY `idx_userId_age` (`userId`,`age`) USING BTREE) <span class="hljs-attribute">ENGINE</span>=InnoDB <span class="hljs-attribute">AUTO_INCREMENT</span>=2<span class="hljs-built_in"> DEFAULT </span><span class="hljs-attribute">CHARSET</span>=utf8;</code></pre><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age = <span class="hljs-number">10</span>;<span class="hljs-comment">### 正例:</span>//符合最左匹配原则<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">10</span> <span class="hljs-keyword">and</span> age =<span class="hljs-number">10</span>；//符合最左匹配原则<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid =<span class="hljs-number">10</span>;</code></pre><h6 id="12-对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描"><a href="#12-对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描" class="headerlink" title="12. 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描"></a>12. 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where<span class="hljs-built_in"> address </span>=<span class="hljs-string">&#x27;深圳&#x27;</span> order by age<span class="hljs-comment">### 正例:</span>alter table<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">add</span> index idx_address_age (address,age)</code></pre><h6 id="13-如果插入数据过多，考虑批量插入"><a href="#13-如果插入数据过多，考虑批量插入" class="headerlink" title="13. 如果插入数据过多，考虑批量插入"></a>13. 如果插入数据过多，考虑批量插入</h6><pre><code class="hljs pgsql">### 反例:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">User</span> u :list)&#123; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>,age) <span class="hljs-keyword">values</span>(#<span class="hljs-type">name</span>#,#age#)&#125;### 正例://一次<span class="hljs-number">500</span>批量插入，分批进行<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>,age) <span class="hljs-keyword">values</span>&lt;<span class="hljs-keyword">foreach</span> collection=&quot;list&quot; item=&quot;item&quot; <span class="hljs-keyword">index</span>=&quot;index&quot; separator=&quot;,&quot;&gt;    (#&#123;item.name&#125;,#&#123;item.age&#125;)&lt;/<span class="hljs-keyword">foreach</span>&gt;</code></pre><h6 id="14-在适当的时候，使用覆盖索引"><a href="#14-在适当的时候，使用覆盖索引" class="headerlink" title="14. 在适当的时候，使用覆盖索引"></a>14. 在适当的时候，使用覆盖索引</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>// like模糊查询，不走索引了<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span><span class="hljs-comment">### 正例:</span>//<span class="hljs-keyword">id</span>为主键，那么为普通索引，即覆盖索引登场了。<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span>;</code></pre><h6 id="15-慎用-distinct-关键字"><a href="#15-慎用-distinct-关键字" class="headerlink" title="15. 慎用 distinct 关键字"></a>15. 慎用 distinct 关键字</h6><p>distinct 关键字一般用来过滤重复记录，以返回不重复的记录。<br>在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。</p><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>SELECT DISTINCT * <span class="hljs-keyword">from</span>  user;<span class="hljs-comment">### 正例:</span>select DISTINCT name <span class="hljs-keyword">from</span> user;</code></pre><h6 id="16-删除冗余和重复索引"><a href="#16-删除冗余和重复索引" class="headerlink" title="16. 删除冗余和重复索引"></a>16. 删除冗余和重复索引</h6><pre><code class="hljs autohotkey"><span class="hljs-title">### 反例:</span>  KEY `idx_userId` (`userId`)  KEY `idx_userId_age` (`userId`,`age`)<span class="hljs-title">### 正例:</span>  //删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引  KEY `idx_userId_age` (`userId`,`age`)</code></pre><h6 id="17-如果数据量较大，优化你的修改-删除语句"><a href="#17-如果数据量较大，优化你的修改-删除语句" class="headerlink" title="17. 如果数据量较大，优化你的修改/删除语句"></a>17. 如果数据量较大，优化你的修改/删除语句</h6><pre><code class="hljs clean">### 反例:<span class="hljs-comment">//一次删除10万或者100万+？</span>delete <span class="hljs-keyword">from</span> user <span class="hljs-keyword">where</span> id &lt;<span class="hljs-number">100000</span>;<span class="hljs-comment">//或者采用单一循环操作，效率低，时间漫长</span>for（User user：list）&#123;   delete <span class="hljs-keyword">from</span> user；&#125;### 正例:<span class="hljs-comment">//分批进行删除,如每次500</span>delete user <span class="hljs-keyword">where</span> id&lt;<span class="hljs-number">500</span>delete product <span class="hljs-keyword">where</span> id&gt;=<span class="hljs-number">500</span> and id&lt;<span class="hljs-number">1000</span>；</code></pre><h6 id="18-where-子句中考虑使用默认值代替-null"><a href="#18-where-子句中考虑使用默认值代替-null" class="headerlink" title="18. where 子句中考虑使用默认值代替 null"></a>18. where 子句中考虑使用默认值代替 null</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">### 正例:</span>//设置0为默认值<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt; <span class="hljs-number">0</span>;</code></pre><h6 id="19-不要有超过-5-个以上的表连接"><a href="#19-不要有超过-5-个以上的表连接" class="headerlink" title="19. 不要有超过 5 个以上的表连接"></a>19. 不要有超过 5 个以上的表连接</h6><ul><li>连表越多，编译的时间和开销也就越大。</li><li>把连接表拆开成较小的几个执行，可读性更高。</li><li>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li></ul><h6 id="20-exist-amp-in-的合理利用"><a href="#20-exist-amp-in-的合理利用" class="headerlink" title="20. exist &amp; in 的合理利用"></a>20. exist &amp; in 的合理利用</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> deptId <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> deptId <span class="hljs-keyword">from</span> B);<span class="hljs-comment">### 正例:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> A.deptId = B.deptId);</code></pre><p>因此，我们要选择最外层循环小的，也就是，如果 B 的数据量小于 A，适合使用 in，如果 B 的数据量大于 A，即适合选择 exist。</p><h6 id="21-尽量用-union-all-替换-union"><a href="#21-尽量用-union-all-替换-union" class="headerlink" title="21. 尽量用 union all 替换 union"></a>21. 尽量用 union all 替换 union</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">userid</span>=1unionselect * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age = 10<span class="hljs-comment">### 正例:</span>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">userid</span>=1union allselect * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age = 10</code></pre><ul><li>如果使用 union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。</li><li>如果已知检索结果没有重复记录，使用 union all 代替 union，这样会提高效率</li></ul><h6 id="22-索引不宜太多，一般-5-个以内"><a href="#22-索引不宜太多，一般-5-个以内" class="headerlink" title="22. 索引不宜太多，一般 5 个以内"></a>22. 索引不宜太多，一般 5 个以内</h6><ul><li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li><li>insert 或 update 时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li><li>一个表的索引数最好不要超过 5 个，若太多需要考虑一些索引是否没有存在的必要。</li></ul><h6 id="23-尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"><a href="#23-尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型" class="headerlink" title="23. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"></a>23. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>king_id` varchar（20） NOT NULL <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;守护者Id&#x27;</span><span class="hljs-comment">### 正例:</span><span class="hljs-string">`king_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;守护者Id&#x27;</span><span class="hljs-string">`</span></code></pre><ul><li>相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。</li></ul><h6 id="24-索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段"><a href="#24-索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段" class="headerlink" title="24. 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段"></a>24. 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段</h6><p>因为 SQL 优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，<br>Mysql 查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p><h6 id="25-尽量避免向客户端返回过多数据量"><a href="#25-尽量避免向客户端返回过多数据量" class="headerlink" title="25. 尽量避免向客户端返回过多数据量"></a>25. 尽量避免向客户端返回过多数据量</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>//一次性查询所有数据回来<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime &gt;= <span class="hljs-keyword">Date_sub</span>(<span class="hljs-keyword">now</span>(),<span class="hljs-built_in">Interval</span> <span class="hljs-number">1</span> Y)<span class="hljs-comment">### 正例:</span>//分页查询<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime&gt;= <span class="hljs-keyword">Date_sub</span>(<span class="hljs-keyword">now</span>(),<span class="hljs-built_in">Interval</span> <span class="hljs-number">1</span> Y) <span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span>，pageSize//如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime&gt;= <span class="hljs-keyword">Date_sub</span>(<span class="hljs-keyword">now</span>(),<span class="hljs-built_in">Interval</span> <span class="hljs-number">1</span> Y) <span class="hljs-keyword">limit</span> <span class="hljs-number">200</span> ;</code></pre><h6 id="26-当在-SQL-语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰"><a href="#26-当在-SQL-语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰" class="headerlink" title="26. 当在 SQL 语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰"></a>26. 当在 SQL 语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰</h6><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span><span class="hljs-keyword">select</span>  * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.deptId = B.deptId;<span class="hljs-comment">### 正例:</span><span class="hljs-keyword">select</span>  memeber.name,deptment.deptName <span class="hljs-keyword">from</span> A <span class="hljs-keyword">member</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B deptment <span class="hljs-keyword">on</span> member.deptId = deptment.deptId;</code></pre><h6 id="27-尽可能使用-varchar-nvarchar-代替-char-nchar"><a href="#27-尽可能使用-varchar-nvarchar-代替-char-nchar" class="headerlink" title="27. 尽可能使用 varchar/nvarchar 代替 char/nchar"></a>27. 尽可能使用 varchar/nvarchar 代替 char/nchar</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>`deptName` char(100)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;部门名称&#x27;</span><span class="hljs-comment">### 正例:</span>`deptName` varchar(100)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;部门名称&#x27;</span></code></pre><ul><li>因为首先变长字段存储空间小，可以节省存储空间。</li><li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li></ul><h6 id="28-为了提高-group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉"><a href="#28-为了提高-group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉" class="headerlink" title="28. 为了提高 group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉"></a>28. 为了提高 group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>select job，avg（salary） <span class="hljs-keyword">from</span> employee <span class="hljs-built_in"> group </span>by job having job =<span class="hljs-string">&#x27;president&#x27;</span> <span class="hljs-keyword">or</span> job = <span class="hljs-string">&#x27;managent&#x27;</span><span class="hljs-comment">### 正例:</span>select job，avg（salary） <span class="hljs-keyword">from</span> employee where job =<span class="hljs-string">&#x27;president&#x27;</span> <span class="hljs-keyword">or</span> job = <span class="hljs-string">&#x27;managent&#x27;</span><span class="hljs-built_in"> group </span>by job</code></pre><h6 id="29-如何字段类型是字符串，where-时一定用引号括起来，否则索引失效"><a href="#29-如何字段类型是字符串，where-时一定用引号括起来，否则索引失效" class="headerlink" title="29. 如何字段类型是字符串，where 时一定用引号括起来，否则索引失效"></a>29. 如何字段类型是字符串，where 时一定用引号括起来，否则索引失效</h6><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userid =123<span class="hljs-comment">### 正例:</span>select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userid =<span class="hljs-string">&#x27;123&#x27;</span></code></pre><h6 id="30-使用-explain-分析你-SQL-的计划"><a href="#30-使用-explain-分析你-SQL-的计划" class="headerlink" title="30. 使用 explain 分析你 SQL 的计划"></a>30. 使用 explain 分析你 SQL 的计划</h6><pre><code class="hljs routeros">explain select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userid =10086 <span class="hljs-keyword">or</span> age =18;<span class="hljs-comment">### 效率从高到低依次</span>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; All</code></pre><h6 id="1-巧用-CASE-WHEN-进行统计"><a href="#1-巧用-CASE-WHEN-进行统计" class="headerlink" title="1. 巧用 CASE WHEN 进行统计"></a>1. 巧用 CASE WHEN 进行统计</h6><table><thead><tr><th>city</th><th align="center">population</th></tr></thead><tbody><tr><td>长沙</td><td align="center">100</td></tr><tr><td>衡阳</td><td align="center">200</td></tr><tr><td>三亚</td><td align="center">300</td></tr><tr><td>海口</td><td align="center">300</td></tr></tbody></table><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> pref_name      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;长沙&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;湖南&#x27;</span>      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;衡阳&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;湖南&#x27;</span>      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;海口&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;海南&#x27;</span>      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;三亚&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;海南&#x27;</span>    <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;其他&#x27;</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> district,    <span class="hljs-keyword">SUM</span>(population)<span class="hljs-keyword">FROM</span> PopTbl<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> district;</code></pre><table><thead><tr><th>province</th><th align="center">人口</th></tr></thead><tbody><tr><td>湖南</td><td align="center">300</td></tr><tr><td>海南</td><td align="center">700</td></tr></tbody></table><h6 id="2-巧用-CASE-WHEN-进行更新"><a href="#2-巧用-CASE-WHEN-进行更新" class="headerlink" title="2. 巧用 CASE WHEN 进行更新"></a>2. 巧用 CASE WHEN 进行更新</h6><table><thead><tr><th>name</th><th align="center">salary</th></tr></thead><tbody><tr><td>小明</td><td align="center">10500</td></tr><tr><td>小红</td><td align="center">8000</td></tr><tr><td>小李</td><td align="center">5000</td></tr></tbody></table><ol><li>对当前工资为 1 万以上的员工，降薪 10%</li><li>对当前工资低于 1 万的员工，加薪 20%</li></ol><pre><code class="hljs sql"><span class="hljs-comment">-- 条件1</span><span class="hljs-keyword">UPDATE</span> Salaries<span class="hljs-keyword">SET</span> salary = salary * <span class="hljs-number">0.9</span> <span class="hljs-keyword">WHERE</span> salary &gt;= <span class="hljs-number">10000</span>;<span class="hljs-comment">-- 条件2</span><span class="hljs-keyword">UPDATE</span> Salaries<span class="hljs-keyword">SET</span> salary = salary * <span class="hljs-number">1.2</span><span class="hljs-keyword">WHERE</span> salary &lt; <span class="hljs-number">10000</span>;</code></pre><p>这么做其实是有问题的， 什么问题，对小明来说，他的工资是 10500，执行第一个 SQL 后，工资变为 10500 * 0.9 = 9450,<br>紧接着又执行条件 2， 工资变为了 9450 * 1.2 = 11340，反而涨薪了！</p><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> Salaries<span class="hljs-keyword">SET</span> salary = <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> salary &gt;= <span class="hljs-number">10000</span> <span class="hljs-keyword">THEN</span> salary * <span class="hljs-number">0.9</span><span class="hljs-keyword">WHEN</span> salary &lt; <span class="hljs-number">10000</span> <span class="hljs-keyword">THEN</span> salary * <span class="hljs-number">1.2</span><span class="hljs-keyword">ELSE</span> salary <span class="hljs-keyword">END</span>;</code></pre><h6 id="3-巧用-HAVING-子句"><a href="#3-巧用-HAVING-子句" class="headerlink" title="3. 巧用 HAVING 子句"></a>3. 巧用 HAVING 子句</h6><p>一般 HAVING 是与 GROUP BY 结合使用的，但其实它是可以独立使用的，<br>假设有如下表，第一列 seq 叫连续编号，但其实有些编号是缺失的，怎么知道编号是否缺失呢，</p><table><thead><tr><th>seq(连续编号)</th><th align="center">name(名字)</th></tr></thead><tbody><tr><td>1</td><td align="center">小张</td></tr><tr><td>2</td><td align="center">小丽</td></tr><tr><td>3</td><td align="center">小王</td></tr><tr><td>5</td><td align="center">小明</td></tr><tr><td>6</td><td align="center">小李</td></tr><tr><td>8</td><td align="center">老马</td></tr></tbody></table><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;存在缺失的编号&#x27;</span> <span class="hljs-keyword">AS</span> gap  <span class="hljs-keyword">FROM</span> SeqTbl<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &lt;&gt; <span class="hljs-keyword">MAX</span>(seq);</code></pre><h6 id="4-自连接"><a href="#4-自连接" class="headerlink" title="4. 自连接"></a>4. 自连接</h6><ol><li>删除重复行</li></ol><table><thead><tr><th>name(商品名称)</th><th align="center">price(价格)</th></tr></thead><tbody><tr><td>apple</td><td align="center">50</td></tr><tr><td>orange</td><td align="center">100</td></tr><tr><td>orange</td><td align="center">100</td></tr><tr><td>orange</td><td align="center">100</td></tr><tr><td>blackberry</td><td align="center">180</td></tr></tbody></table><p>表中有三个橘子，需要把这些重复的行给删掉，用如下自连接可以解决</p><pre><code class="hljs reasonml">DELETE FROM Products P1 WHERE id &lt; ( SELECT <span class="hljs-constructor">MAX(P2.<span class="hljs-params">id</span>)</span>                    FROM Products P2                   WHERE <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P1</span>.</span></span>name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P2</span>.</span></span>name                     AND <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P1</span>.</span></span>price = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P2</span>.</span></span>price );</code></pre><ol start="2"><li>排序</li></ol><table><thead><tr><th>name(商品名称)</th><th align="center">price(价格)</th></tr></thead><tbody><tr><td>apple</td><td align="center">50</td></tr><tr><td>orange</td><td align="center">100</td></tr><tr><td>watermelon</td><td align="center">100</td></tr><tr><td>berry</td><td align="center">120</td></tr><tr><td>blackberry</td><td align="center">180</td></tr></tbody></table><pre><code class="hljs pgsql"><span class="hljs-comment">-- 排序从 1 开始。如果已出现相同位次，则跳过之后的位次 </span><span class="hljs-keyword">SELECT</span> P1.name,       P1.price,       (<span class="hljs-keyword">SELECT</span> COUNT(P2.price)          <span class="hljs-keyword">FROM</span> Products P2         <span class="hljs-keyword">WHERE</span> P2.price &gt; P1.price) + <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> rank_1  <span class="hljs-keyword">FROM</span> Products P1   <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rank_1;</code></pre><h6 id="5-巧用-COALESCE-函数"><a href="#5-巧用-COALESCE-函数" class="headerlink" title="5. 巧用 COALESCE 函数"></a>5. 巧用 COALESCE 函数</h6><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     <span class="hljs-keyword">COALESCE</span>(city, <span class="hljs-string">&#x27;N/A&#x27;</span>)  <span class="hljs-keyword">FROM</span>    customers;</code></pre><table><thead><tr><th>id</th><th align="center">city</th></tr></thead><tbody><tr><td>1</td><td align="center">null</td></tr><tr><td>2</td><td align="center">上海</td></tr><tr><td>3</td><td align="center">北京</td></tr></tbody></table><h6 id="1-参数是子查询时，使用-EXISTS-代替-IN"><a href="#1-参数是子查询时，使用-EXISTS-代替-IN" class="headerlink" title="1. 参数是子查询时，使用 EXISTS 代替 IN"></a>1. 参数是子查询时，使用 EXISTS 代替 IN</h6><table><thead><tr><th>id</th><th align="center">name(名字)</th></tr></thead><tbody><tr><td>1</td><td align="center">小明</td></tr><tr><td>2</td><td align="center">晓东</td></tr><tr><td>3</td><td align="center">阿强</td></tr></tbody></table><table><thead><tr><th>id</th><th align="center">name(名字)</th></tr></thead><tbody><tr><td>1</td><td align="center">小明</td></tr><tr><td>2</td><td align="center">晓东</td></tr><tr><td>3</td><td align="center">大雄</td></tr></tbody></table><p>要查出同时存在于两个表的员工，即小明和晓东，<br>则以下用 IN 和 EXISTS 返回的结果是一样，但是用 EXISTS 的 SQL 会更快:</p><pre><code class="hljs sql"><span class="hljs-comment">-- 慢</span><span class="hljs-keyword">SELECT</span> *   <span class="hljs-keyword">FROM</span> Class_A<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>                <span class="hljs-keyword">FROM</span>  CLASS_B);<span class="hljs-comment">-- 快</span><span class="hljs-keyword">SELECT</span> *  <span class="hljs-keyword">FROM</span> Class_A A  <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> *    <span class="hljs-keyword">FROM</span> Class_B  B  <span class="hljs-keyword">WHERE</span> A.id = B.id);</code></pre><p>如果 IN 的参数是子查询时，也可以用连接来代替，如下：</p><pre><code class="hljs reasonml">-- 使用连接代替 IN SELECT <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>id, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>nameFROM Class_A A INNER JOIN Class_B B ON <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>id = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>id;</code></pre><h6 id="2-避免排序"><a href="#2-避免排序" class="headerlink" title="2. 避免排序"></a>2. 避免排序</h6><p>SQL 是声明式语言，即对用户来说，只关心它能做什么，不用关心它怎么做。<br>这样可能会产生潜在的性能问题：排序，会产生排序的代表性运算有下面这些</p><ul><li>GROUP BY 子句</li><li>ORDER BY 子句</li><li>聚合函数(SUM、COUNT、AVG、MAX、MIN)</li><li>DISTINCT</li><li>集合运算符(UNION、INTERSECT、EXCEPT)</li><li>窗口函数(RANK、ROW_NUMBER 等)</li></ul><p>如果在内存中排序还好，但如果内存不够导致需要在硬盘上排序上的话，<br>性能就会急剧下降，所以我们需要减少不必要的排序。怎样做可以减少排序呢。</p><ol><li>使用集合运算符的 ALL 可选项<br>注意：加 ALL 是优化性能非常有效的手段，不过前提是不在乎结果是否有重复数据。</li><li>使用 EXISTS 代表 DISTINCT<br>为了排除重复数据， DISTINCT 也会对结果进行排序，如果需要对两张表的连接结果进行去重，<br>可以考虑用 EXISTS 代替 DISTINCT，这样可以避免排序。</li></ol><table><thead><tr><th>item_no</th><th align="center">item</th></tr></thead><tbody><tr><td>10</td><td align="center">面包</td></tr><tr><td>20</td><td align="center">香蕉</td></tr><tr><td>30</td><td align="center">苹果</td></tr></tbody></table><table><thead><tr><th>sale_date</th><th align="center">item_no</th><th align="center">quantity</th></tr></thead><tbody><tr><td>2020-06-01 10:05:56</td><td align="center">10</td><td align="center">4</td></tr><tr><td>2020-06-01 10:05:56</td><td align="center">20</td><td align="center">10</td></tr><tr><td>2020-06-01 10:05:56</td><td align="center">30</td><td align="center">3</td></tr><tr><td>2020-06-01 10:05:56</td><td align="center">10</td><td align="center">30</td></tr></tbody></table><p>如何找出有销售记录的商品，使用如下 DISTINCT 可以:</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> I.item_no<span class="hljs-keyword">FROM</span> Items I <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SalesHistory SH<span class="hljs-keyword">ON</span> I. item_no = SH. item_no;</code></pre><p>不过更好的方式是使用 EXISTS: 既用到了索引，又避免了排序对性能的损耗。</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> item_no <span class="hljs-keyword">FROM</span> Items I<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>         (<span class="hljs-keyword">SELECT</span> *           <span class="hljs-keyword">FROM</span> SalesHistory SH          <span class="hljs-keyword">WHERE</span> I.item_no = SH.item_no);</code></pre><h6 id="2-在极值函数中使用索引（MAX-MIN）"><a href="#2-在极值函数中使用索引（MAX-MIN）" class="headerlink" title="2. 在极值函数中使用索引（MAX/MIN）"></a>2. 在极值函数中使用索引（MAX/MIN）</h6><p>使用 MAX/ MIN 都会对进行排序，如果参数字段上没加索引会导致全表扫描，<br>如果建有索引，则只需要扫描索引即可，对比如下</p><pre><code class="hljs sql"><span class="hljs-comment">-- 这样写需要扫描全表 </span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(item)  <span class="hljs-keyword">FROM</span> Items;<span class="hljs-comment">-- 这样写能用到索引 </span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(item_no)  <span class="hljs-keyword">FROM</span> Items;</code></pre><p>注意：极值函数参数推荐为索引列中并不是不需要排序，而是优化了排序前的查找速度（毕竟索引本身就是有序排列的）</p><h6 id="3-能写在-WHERE-子句里的条件不要写在-HAVING-子句里"><a href="#3-能写在-WHERE-子句里的条件不要写在-HAVING-子句里" class="headerlink" title="3. 能写在 WHERE 子句里的条件不要写在 HAVING 子句里"></a>3. 能写在 WHERE 子句里的条件不要写在 HAVING 子句里</h6><pre><code class="hljs routeros">-- 聚合后使用 HAVING 子句过滤SELECT sale_date, SUM(quantity)  <span class="hljs-keyword">FROM</span> SalesHistory<span class="hljs-built_in"> GROUP </span>BY sale_dateHAVING sale_date = <span class="hljs-string">&#x27;2007-10-01&#x27;</span>;-- 聚合前使用 WHERE 子句过滤SELECT sale_date, SUM(quantity)  <span class="hljs-keyword">FROM</span> SalesHistory WHERE sale_date = <span class="hljs-string">&#x27;2007-10-01&#x27;</span> <span class="hljs-built_in"> GROUP </span>BY sale_date;</code></pre><p>使用第二条语句效率更高，原因主要有两点: </p><ol><li>使用 GROUP BY 子句进行聚合时会进行排序，如果事先通过 WHERE 子句能筛选出一部分行，能减轻排序的负担</li><li>在 WHERE 子句中可以使用索引，而 HAVING 子句是针对聚合后生成的视频进行筛选的，但很多时候聚合后生成的视图并没有保留原表的索引结构</li></ol><h6 id="4-在-GROUP-BY-子句和-ORDER-BY-子句中使用索引"><a href="#4-在-GROUP-BY-子句和-ORDER-BY-子句中使用索引" class="headerlink" title="4. 在 GROUP BY 子句和 ORDER BY 子句中使用索引"></a>4. 在 GROUP BY 子句和 ORDER BY 子句中使用索引</h6><p>GROUP BY 子句和 ORDER BY 子句一般都会进行排序，以对行进行排列和替换，<br>不过如果指定带有索引的列作为这两者的参数列，<br>由于用到了索引，可以实现高速查询，由于索引是有序的，排序本身都会被省略掉</p><h6 id="5-使用索引时，条件表达式的左侧应该是原始字段"><a href="#5-使用索引时，条件表达式的左侧应该是原始字段" class="headerlink" title="5. 使用索引时，条件表达式的左侧应该是原始字段"></a>5. 使用索引时，条件表达式的左侧应该是原始字段</h6><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *  <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> * <span class="hljs-number">1.1</span> &gt; <span class="hljs-number">100</span>;<span class="hljs-keyword">SELECT</span> *  <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">SUBSTR</span>(<span class="hljs-keyword">col</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;a&#x27;</span>;</code></pre><p>第一个 SQL 在索引列上进行了运算, 第二个 SQL 对索引列使用了函数，均无法用到索引，正确方式是把列单独放在左侧,如下:</p><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> *  <span class="hljs-attribute">FROM</span> SomeTable <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> &gt; <span class="hljs-number">100</span> / <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;</code></pre><h6 id="6-尽量避免使用否定形式"><a href="#6-尽量避免使用否定形式" class="headerlink" title="6. 尽量避免使用否定形式"></a>6. 尽量避免使用否定形式</h6><p>如下的几种否定形式不能用到索引：</p><ul><li>&lt;&gt;</li><li>!=</li><li>NOT IN<pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *  <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 &lt;&gt; <span class="hljs-number">100</span>;</code></pre>第一条SQL 语句会导致全表扫描,可以改成以下形式: <pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> *  <span class="hljs-attribute">FROM</span> SomeTable <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> &gt; <span class="hljs-number">100</span> or col_<span class="hljs-number">1</span> &lt; <span class="hljs-number">100</span>;</code></pre></li></ul><h6 id="7-进行默认的类型转换"><a href="#7-进行默认的类型转换" class="headerlink" title="7. 进行默认的类型转换"></a>7. 进行默认的类型转换</h6><p>假设 col 是 char 类型，则推荐使用以下第二，三条 SQL 的写法，不推荐第一条 SQL 的写法</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-number">10</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-string">&#x27;10&#x27;</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-keyword">CAST</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">AS</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">2</span>));</code></pre><h6 id="8-减少中间表"><a href="#8-减少中间表" class="headerlink" title="8. 减少中间表"></a>8. 减少中间表</h6><p>在 SQL 中，子查询的结果会产生一张新表，不过如果不加限制大量使用中间表的话，会带来两个问题，<br>一是展示数据需要消耗内存资源，<br>二是原始表中的索引不容易用到，所以尽量减少中间表也可以提升性能。</p><h6 id="9-灵活使用-HAVING-子句"><a href="#9-灵活使用-HAVING-子句" class="headerlink" title="9. 灵活使用 HAVING 子句"></a>9. 灵活使用 HAVING 子句</h6><p>这一点与上面第八条相呼应，对聚合结果指定筛选条件时，使用 HAVING 是基本的原则，可能一些工程师会倾向于使用下面这样的写法</p><pre><code class="hljs routeros">SELECT *  <span class="hljs-keyword">FROM</span> (SELECT sale_date, MAX(quantity) AS max_qty          <span class="hljs-keyword">FROM</span> SalesHistory         <span class="hljs-built_in"> GROUP </span>BY sale_date) TMP         WHERE max_qty &gt;= 10;</code></pre><p>虽然上面这样的写法能达到目的，但会生成 TMP 这张临时表，HAVING 子句和聚合操作是同时执行的，<br>所以比起生成中间表后再执行 HAVING 子句，效率会更高，代码也更简洁</p><pre><code class="hljs routeros">SELECT sale_date, MAX(quantity)   <span class="hljs-keyword">FROM</span> SalesHistory<span class="hljs-built_in"> GROUP </span>BY sale_dateHAVING MAX(quantity) &gt;= 10;</code></pre><h6 id="10-需要对多个字段使用-IN-谓词时，将它们汇总到一处"><a href="#10-需要对多个字段使用-IN-谓词时，将它们汇总到一处" class="headerlink" title="10. 需要对多个字段使用 IN 谓词时，将它们汇总到一处"></a>10. 需要对多个字段使用 IN 谓词时，将它们汇总到一处</h6><p>一个表的多个字段可能都使用了 IN 谓词，如下:</p><pre><code class="hljs pf">SELECT id, <span class="hljs-keyword">state</span>, city   FROM Addresses1 A1 WHERE <span class="hljs-keyword">state</span> IN (SELECT <span class="hljs-keyword">state</span>                   FROM Addresses2 A2                  WHERE A1.id = A2.id)     AND city IN (SELECT city                   FROM Addresses2 A2                   WHERE A1.id = A2.id);</code></pre><p>这段代码用到了两个子查询，也就产生了两个中间表，可以像下面这样写,<br>查询不用考虑关联性，没有中间表产生，而且只执行一次即可。</p><pre><code class="hljs pf">SELECT *  FROM Addresses1 A1 WHERE id || <span class="hljs-keyword">state</span> || city IN (SELECT id || <span class="hljs-keyword">state</span>|| city       FROM Addresses2 A2);</code></pre><h6 id="11-使用延迟查询优化-limit-offset-rows"><a href="#11-使用延迟查询优化-limit-offset-rows" class="headerlink" title="11. 使用延迟查询优化 limit [offset], [rows]"></a>11. 使用延迟查询优化 limit [offset], [rows]</h6><pre><code class="hljs pgsql">### <span class="hljs-keyword">offset</span> 特别大<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> film <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span></code></pre><p>假设有以下 SQL,有组合索引（sex, rating）</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> &lt;cols&gt; <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">profiles</span> <span class="hljs-keyword">where</span> sex=<span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>;<span class="hljs-comment">### 则上述写法可以改成如下写法</span><span class="hljs-keyword">SELECT</span> &lt;cols&gt;   <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">profiles</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">form</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">profiles</span> <span class="hljs-keyword">where</span> x.sex=<span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>)<span class="hljs-keyword">as</span> x <span class="hljs-keyword">using</span>(<span class="hljs-keyword">id</span>);</code></pre><h6 id="12-利用-LIMIT-1-取得唯一行"><a href="#12-利用-LIMIT-1-取得唯一行" class="headerlink" title="12. 利用 LIMIT 1 取得唯一行"></a>12. 利用 LIMIT 1 取得唯一行</h6><p>数据库引擎只要发现满足条件的一行数据则立即停止扫描，这种情况适用于只需查找一条满足条件的数据的情况</p><h6 id="13-注意组合索引，要符合最左匹配原则才能生效"><a href="#13-注意组合索引，要符合最左匹配原则才能生效" class="headerlink" title="13. 注意组合索引，要符合最左匹配原则才能生效"></a>13. 注意组合索引，要符合最左匹配原则才能生效</h6><p>假设存在这样顺序的一个联合索引“col_1, col_2, col_3”。这时，指定条件的顺序就很重要</p><pre><code class="hljs n1ql">○ <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> col_2 = <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> col_3 = <span class="hljs-number">500</span>;○ <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> col_2 = <span class="hljs-number">100</span> ;× <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_2 = <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> col_3 = <span class="hljs-number">500</span> ;</code></pre><p>前面两条会命中索引，第三条由于没有先匹配 col_1，导致无法命中索引，<br>另外如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引 拆分为多个索引。</p><h6 id="14-使用-LIKE-谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）"><a href="#14-使用-LIKE-谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）" class="headerlink" title="14. 使用 LIKE 谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）"></a>14. 使用 LIKE 谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）</h6><pre><code class="hljs sql">× <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a&#x27;</span>;× <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>;○ <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;a%&#x27;</span>;</code></pre><p>上例中，只有第三条会命中索引，前面两条进行后方一致或中间一致的匹配无法命中索引</p><h6 id="15-简单字符串表达式"><a href="#15-简单字符串表达式" class="headerlink" title="15.  简单字符串表达式"></a>15.  简单字符串表达式</h6><p>模型字符串可以使用 _ 时， 尽可能避免使用 %, 假设某一列上为 char(5)</p><pre><code class="hljs sql"><span class="hljs-comment">### 不推荐</span><span class="hljs-keyword">SELECT</span>     first_name,     last_name,    homeroom_nbr  <span class="hljs-keyword">FROM</span> Students <span class="hljs-keyword">WHERE</span> homeroom_nbr <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;A-1%&#x27;</span>;<span class="hljs-comment">### 推荐</span><span class="hljs-keyword">SELECT</span> first_name, last_namehomeroom_nbr  <span class="hljs-keyword">FROM</span> Students <span class="hljs-keyword">WHERE</span> homeroom_nbr <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;A-1__&#x27;</span>; <span class="hljs-comment">--模式字符串中包含了两个下划线</span></code></pre><h6 id="16-尽量使用自增-id-作为主键"><a href="#16-尽量使用自增-id-作为主键" class="headerlink" title="16. 尽量使用自增 id 作为主键"></a>16. 尽量使用自增 id 作为主键</h6><p>比如现在有一个用户表，有人说身份证是唯一的，也可以用作主键，理论上确实可以，不过用身份证作主键的话，<br>一是占用空间相对于自增主键大了很多，<br>二是很容易引起频繁的页分裂，造成性能问题（什么是页分裂，<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247484006&idx=1&sn=3e15abeb5299a3e9b578332dd8565273&scene=21#wechat_redirect">请参考这篇文章</a>   ）<br>主键选择的几个原则：自增，尽量小，不要对主键进行修改</p><h6 id="17-在无-WHERE-条件下要计算表的行数，优先使用-count"><a href="#17-在无-WHERE-条件下要计算表的行数，优先使用-count" class="headerlink" title="17. 在无 WHERE 条件下要计算表的行数，优先使用 count(*)"></a>17. 在无 WHERE 条件下要计算表的行数，优先使用 count(*)</h6><p>优先使用以下语句来统计行数, innoDB 5.6之后已经对此语句进行了优化<br>按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(<em>)，count(</em>) 会选用性能最好的索引来进行排序</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">FROM</span> SomeTable</code></pre><h6 id="18-避免使用-SELECT-，尽量利用覆盖索引来优化性能"><a href="#18-避免使用-SELECT-，尽量利用覆盖索引来优化性能" class="headerlink" title="18. 避免使用 SELECT * ，尽量利用覆盖索引来优化性能"></a>18. 避免使用 SELECT * ，尽量利用覆盖索引来优化性能</h6><p>SELECT * 会提取出一整行的数据，如果查询条件中用的是组合索引进行查找，<br>还会导致回表（先根据组合索引找到叶子节点，再根据叶子节点上的主键回表查询一整行），降低性能，<br>而如果我们所要的数据就在组合索引里，只需读取组合索引列，<br>这样网络带宽将大大减少,假设有组合索引列 (col_1, col_2)</p><pre><code class="hljs apache"><span class="hljs-comment">### 推荐用</span><span class="hljs-attribute">SELECT</span> col_<span class="hljs-number">1</span>, col_<span class="hljs-number">2</span>   <span class="hljs-attribute">FROM</span> SomeTable  <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> = xxx AND col_<span class="hljs-number">2</span> = xxx<span class="hljs-comment">### 不推荐用</span><span class="hljs-attribute">SELECT</span> *  <span class="hljs-attribute">FROM</span> SomeTable  <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> = xxx AND  col_<span class="hljs-number">2</span> = xxx</code></pre><h6 id="19-如有必要，使用-force-index-强制走某个索引"><a href="#19-如有必要，使用-force-index-强制走某个索引" class="headerlink" title="19. 如有必要，使用 force index() 强制走某个索引"></a>19. 如有必要，使用 force index() 强制走某个索引</h6><pre><code class="hljs 1c">SELECT *  FROM  SomeTable WHERE `status` = <span class="hljs-number">0</span>   AND `gmt_create` &gt; <span class="hljs-number">1490025600</span>   AND `gmt_create` &lt; <span class="hljs-number">1490630400</span>   AND `id` &gt; <span class="hljs-number">0</span>   AND `post_id` IN (&#x27;<span class="hljs-number">6777</span>8&#x27;, &#x27;<span class="hljs-number">6781</span>1&#x27;, &#x27;<span class="hljs-number">6783</span>3&#x27;, &#x27;<span class="hljs-number">6783</span>4&#x27;, &#x27;<span class="hljs-number">6783</span>9&#x27;, &#x27;<span class="hljs-number">6785</span>2&#x27;, &#x27;<span class="hljs-number">6786</span>1&#x27;, &#x27;<span class="hljs-number">6786</span>8&#x27;, &#x27;<span class="hljs-number">6787</span>0&#x27;, &#x27;<span class="hljs-number">6787</span>8&#x27;, &#x27;<span class="hljs-number">6790</span>9&#x27;, &#x27;<span class="hljs-number">6794</span>8&#x27;, &#x27;<span class="hljs-number">6795</span>1&#x27;, &#x27;<span class="hljs-number">6796</span>3&#x27;, &#x27;<span class="hljs-number">6797</span>7&#x27;, &#x27;<span class="hljs-number">6798</span>3&#x27;, &#x27;<span class="hljs-number">6798</span>5&#x27;, &#x27;<span class="hljs-number">6799</span>1&#x27;, &#x27;<span class="hljs-number">6803</span>2&#x27;, &#x27;<span class="hljs-number">6803</span>8&#x27;/*... omitted <span class="hljs-number">480</span> items ...*/)order by id asc limit <span class="hljs-number">200</span>;</code></pre><p>post_id 也加了索引，理论上走 post_id 索引会很快查询出来，但实现了通过 EXPLAIN 发现走的却是 id 的索引（这里隐含了一个常见考点，在多个索引的情况下, MySQL 会如何选择索引），<br>而 id &gt; 0 这个查询条件没啥用，直接导致了全表扫描，<br>所以在有多个索引的情况下一定要慎用，可以使用 force index 来强制走某个索引，<br>以这个例子为例，可以强制走 post_id 索引，效果立杆见影。</p><h6 id="20-批量插入，速度更快"><a href="#20-批量插入，速度更快" class="headerlink" title="20. 批量插入，速度更快"></a>20. 批量插入，速度更快</h6><p>当需要插入数据时，批量插入比逐条插入性能更高</p><pre><code class="hljs sql"><span class="hljs-comment">### 推荐用</span><span class="hljs-comment">-- 批量插入</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> (<span class="hljs-keyword">id</span>, user_id, title) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">### 不推荐用</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> (<span class="hljs-keyword">id</span>, user_id, title) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> (<span class="hljs-keyword">id</span>, user_id, title) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;b&#x27;</span>);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署jar</title>
    <link href="/2020/06/02/2020-06-02-Docker%E9%83%A8%E7%BD%B2jar/"/>
    <url>/2020/06/02/2020-06-02-Docker%E9%83%A8%E7%BD%B2jar/</url>
    
    <content type="html"><![CDATA[<h4 id="一、-上传jar到服务器的指定目录"><a href="#一、-上传jar到服务器的指定目录" class="headerlink" title="一、 上传jar到服务器的指定目录"></a>一、 上传jar到服务器的指定目录</h4><h5 id="2-在该目录下创建Dockerfile-文件"><a href="#2-在该目录下创建Dockerfile-文件" class="headerlink" title="2. 在该目录下创建Dockerfile 文件"></a>2. 在该目录下创建Dockerfile 文件</h5><pre><code class="hljs dockerfile">vi Dockerfile<span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> bingo<span class="hljs-keyword">ADD</span><span class="bash"> demo-0.0.1-SNAPSHOT.jar demo.jar</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;demo.jar&quot;</span>]</span></code></pre><blockquote><p>from java:8              拉取一个jdk为1.8的docker image<br>maintainer               作者是bingo<br>demo-0.0.1-SNAPSHOT.jar  就是你上传的jar包，替换为jar包的名称<br>demo.jar                 是你将该jar包重新命名为什么名称，在容器中运行<br> expose                  该容器暴露的端口是多少，就是jar在容器中以多少端口运行<br>entrypoint               容器启动之后执行的命令，java -jar demo.jar  即启动jar</p></blockquote><h5 id="4-创建好Dockerfile文件之后，执行命令-构建镜像："><a href="#4-创建好Dockerfile文件之后，执行命令-构建镜像：" class="headerlink" title="4. 创建好Dockerfile文件之后，执行命令 构建镜像："></a>4. 创建好Dockerfile文件之后，执行命令 构建镜像：</h5><pre><code class="hljs erlang">docker build -t square-root  .</code></pre><p>注意最后的 .  表示 Dockerfile 文件在当前目录下<br>square-root  构建之后镜像名称</p><h5 id="5-镜像构建成功运行容器"><a href="#5-镜像构建成功运行容器" class="headerlink" title="5. 镜像构建成功运行容器"></a>5. 镜像构建成功运行容器</h5><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> -d <span class="hljs-attribute">--restart</span>=always --name square -p 18091:18091  square-root  <span class="hljs-attribute">--restart</span>=always</code></pre><p> –restart=always 这个表示docker容器在停止或服务器开机之后会自动重新启动</p><h5 id="6-查看启动日志"><a href="#6-查看启动日志" class="headerlink" title="6. 查看启动日志"></a>6. 查看启动日志</h5><pre><code class="hljs clean">### 查看启动日志docker logs --tail <span class="hljs-number">-300</span>f square</code></pre><p>如果docker run 的时候没有加 –restart=always ，然后已经运行的docker容器怎么设置自动重启？ 执行下面命令：</p><pre><code class="hljs pgsql">docker container <span class="hljs-keyword">update</span> <span class="hljs-comment">--restart=always square</span></code></pre><p>square : 你的容器名称</p><h4 id="二、-配置连接docker部署"><a href="#二、-配置连接docker部署" class="headerlink" title="二、 配置连接docker部署"></a>二、 配置连接docker部署</h4><h5 id="1-修改docker远程连接配置"><a href="#1-修改docker远程连接配置" class="headerlink" title="1.修改docker远程连接配置"></a>1.修改docker远程连接配置</h5><p>添加如下内容<br>-H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</p><pre><code class="hljs awk">$ vi  <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/docker.service [Unit]Description=Docker Application Container EngineDocumentation=https:<span class="hljs-regexp">//</span>docs.docker.comBindsTo=containerd.serviceAfter=network-online.target firewalld.service containerd.serviceWants=network-online.targetRequires=docker.socket[Service]Type=notify<span class="hljs-comment"># the default is not to use systemd for cgroups because the delegate issues still</span><span class="hljs-comment"># exists and systemd currently does not support the cgroup feature set required</span><span class="hljs-comment"># for containers run by docker</span>ExecStart=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/dockerd -H fd:/</span><span class="hljs-regexp">/ --containerd=/</span>run<span class="hljs-regexp">/containerd/</span>containerd.sock -H tcp:<span class="hljs-regexp">//</span><span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">2375</span>  -H unix:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>run/docker.sockExecReload=<span class="hljs-regexp">/bin/</span>kill -s HUP <span class="hljs-variable">$MAINPID</span>TimeoutSec=<span class="hljs-number">0</span>RestartSec=<span class="hljs-number">2</span>Restart=always<span class="hljs-comment"># Note that StartLimit* options were moved from &quot;Service&quot; to &quot;Unit&quot; in systemd 229.</span><span class="hljs-comment"># Both the old, and new location are accepted by systemd 229 and up, so using the old location</span><span class="hljs-comment"># to make them work for either version of systemd.</span>StartLimitBurst=<span class="hljs-number">3</span><span class="hljs-comment"># Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.</span><span class="hljs-comment"># Both the old, and new name are accepted by systemd 230 and up, so using the old name to make</span><span class="hljs-comment"># this option work for either version of systemd.</span>StartLimitInterval=<span class="hljs-number">60</span>s</code></pre><h5 id="2-保存配置重启Docker"><a href="#2-保存配置重启Docker" class="headerlink" title="2. 保存配置重启Docker"></a>2. 保存配置重启Docker</h5><pre><code class="hljs routeros">$ systemctl daemon-reload    $<span class="hljs-built_in"> service </span>docker restart</code></pre><h5 id="3-安装Docker插件"><a href="#3-安装Docker插件" class="headerlink" title="3. 安装Docker插件"></a>3. 安装Docker插件</h5><p>点击 File-&gt;Settings-&gt;Plugins-&gt;Browse Repositories 如下<br><img src="https://alwaysfaith.github.io/img/hash/v2-3b5d910a510a359c0a0c69cb135b4996_720w.jpg"><br>打开 File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Docker ，然后配置一下 Docker 的远程连接地址：<br><img src="https://alwaysfaith.github.io/img/hash/v2-3b5d910a510a359c0a0c69cb135b4996_720w.jpg"></p><h5 id="4-配置-Dockerfile"><a href="#4-配置-Dockerfile" class="headerlink" title="4. 配置 Dockerfile"></a>4. 配置 Dockerfile</h5><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> hub.c.<span class="hljs-number">163</span>.com/library/java:latest<span class="hljs-keyword">VOLUME</span><span class="bash"> /tmp</span><span class="hljs-keyword">ADD</span><span class="bash"> target/docker-0.0.1-SNAPSHOT.jar app.jar</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/app.jar&quot;</span>]</span></code></pre><blockquote><p>Spring Boot 项目的运行依赖 Java 环境，所以我自己的镜像基于 Java 镜像来构建。<br>考虑到 Docker 官方镜像下载较慢，我这里使用了网易提供的 Docker 镜像。<br>由于 Spring Boot 运行时需要 tmp 目录，这里数据卷配置一个 /tmp 目录出来。<br>将本地 target 目录中打包好的 .jar 文件复制一份新的 到 /app.jar。<br>最后就是配置一下启动命令，由于我打包的 jar 已经成为 app.jar 了，所以启动命令也是启动 app.jar。</p></blockquote><h5 id="5-配置-Maven-插件"><a href="#5-配置-Maven-插件" class="headerlink" title="5.配置 Maven 插件"></a>5.配置 Maven 插件</h5><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://192.168.66.131:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>javaboy/$</span><span class="hljs-template-variable">&#123;project.artifactId&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">forceTags</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">forceTags</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.basedir&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.build.directory&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.build.finalName&#125;</span><span class="xml">.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span></code></pre><blockquote><p>首先在 execution 节点中配置当执行 mvn package 的时候，顺便也执行一下 docker:build<br>然后在 configuration 中分别配置 Docker 的主机地址，镜像的名称，镜像的 tags，其中 dockerDirectory 表示指定 Dockerfile 的位置。<br>最后 resource 节点中再配置一下 jar 的位置和名称即可。</p></blockquote><h5 id="6-打包运行"><a href="#6-打包运行" class="headerlink" title="6.打包运行"></a>6.打包运行</h5>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署RocketMq</title>
    <link href="/2020/06/01/2020-06-01-Docker%E9%83%A8%E7%BD%B2RocketMq/"/>
    <url>/2020/06/01/2020-06-01-Docker%E9%83%A8%E7%BD%B2RocketMq/</url>
    
    <content type="html"><![CDATA[<h4 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h4><p>下载稳定版本compose</p><pre><code class="hljs awk">sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose</code></pre><p>添加执行权限</p><pre><code class="hljs awk">sudo chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose</code></pre><p>关联可执行文件</p><pre><code class="hljs awk">sudo ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose <span class="hljs-regexp">/usr/</span>bin/docker-compose</code></pre><p>查看版本</p><pre><code class="hljs ada">docker-compose <span class="hljs-comment">--version</span></code></pre><h4 id="基于-Docker-安装-RocketMQ"><a href="#基于-Docker-安装-RocketMQ" class="headerlink" title="基于 Docker 安装 RocketMQ"></a>基于 Docker 安装 RocketMQ</h4><p>docker-compose.yml</p><pre><code class="hljs bash">version: <span class="hljs-string">&#x27;3.5&#x27;</span>services:  rmqnamesrv:    image: foxiswho/rocketmq:server    container_name: rmqnamesrv    ports:      - 9876:9876    volumes:      - ./data/logs:/opt/logs      - ./data/store:/opt/store    networks:        rmq:          aliases:            - rmqnamesrv  rmqbroker:    image: foxiswho/rocketmq:broker    container_name: rmqbroker    ports:      - 10909:10909      - 10911:10911    volumes:      - ./data/logs:/opt/logs      - ./data/store:/opt/store      - ./data/brokerconf/broker.conf:/etc/rocketmq/broker.conf    environment:        NAMESRV_ADDR: <span class="hljs-string">&quot;rmqnamesrv:9876&quot;</span>        JAVA_OPTS: <span class="hljs-string">&quot; -Duser.home=/opt&quot;</span>        JAVA_OPT_EXT: <span class="hljs-string">&quot;-server -Xms128m -Xmx128m -Xmn128m&quot;</span>    <span class="hljs-built_in">command</span>: mqbroker -c /etc/rocketmq/broker.conf    depends_on:      - rmqnamesrv    networks:      rmq:        aliases:          - rmqbroker  rmqconsole:    image: styletang/rocketmq-console-ng    container_name: rmqconsole    ports:      - 8080:8080    environment:        JAVA_OPTS: <span class="hljs-string">&quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span>    depends_on:      - rmqnamesrv    networks:      rmq:        aliases:          - rmqconsolenetworks:  rmq:    name: rmq    driver: bridge</code></pre><p>broker.conf (1、./是当前目录 2、../是父级目录 3、/是根目录)</p><blockquote><p>RocketMQ Broker 需要一个配置文件，按照上面的 Compose 配置，我们需要在 ./data/brokerconf/ 目录下创建一个名为 broker.conf 的配置文件，内容如下：</p></blockquote><pre><code class="hljs bash"><span class="hljs-comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span><span class="hljs-comment"># contributor license agreements.  See the NOTICE file distributed with</span><span class="hljs-comment"># this work for additional information regarding copyright ownership.</span><span class="hljs-comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span><span class="hljs-comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span><span class="hljs-comment"># the License.  You may obtain a copy of the License at</span><span class="hljs-comment">#</span><span class="hljs-comment">#     http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment">#</span><span class="hljs-comment">#  Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><span class="hljs-comment">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="hljs-comment">#  See the License for the specific language governing permissions and</span><span class="hljs-comment">#  limitations under the License.</span><span class="hljs-comment"># 所属集群名字</span>brokerClusterName=DefaultCluster<span class="hljs-comment"># broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,</span><span class="hljs-comment"># 在 broker-b.properties 使用: broker-b</span>brokerName=broker-a<span class="hljs-comment"># 0 表示 Master，&gt; 0 表示 Slave</span>brokerId=0<span class="hljs-comment"># nameServer地址，分号分割</span><span class="hljs-comment"># namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><span class="hljs-comment"># 启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed</span><span class="hljs-comment"># 解决方式1 加上一句 producer.setVipChannelEnabled(false);，解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IP</span>brokerIP1=192.168.0.253<span class="hljs-comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span>defaultTopicQueueNums=4<span class="hljs-comment"># 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭 ！！！这里仔细看是 false，false，false</span>autoCreateTopicEnable=<span class="hljs-literal">true</span><span class="hljs-comment"># 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span>autoCreateSubscriptionGroup=<span class="hljs-literal">true</span><span class="hljs-comment"># Broker 对外服务的监听端口</span>listenPort=10911<span class="hljs-comment"># 删除文件时间点，默认凌晨4点</span>deleteWhen=04<span class="hljs-comment"># 文件保留时间，默认48小时</span>fileReservedTime=120<span class="hljs-comment"># commitLog 每个文件的大小默认1G</span>mapedFileSizeCommitLog=1073741824<span class="hljs-comment"># ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整</span>mapedFileSizeConsumeQueue=300000<span class="hljs-comment"># destroyMapedFileIntervalForcibly=120000</span><span class="hljs-comment"># redeleteHangedFileInterval=120000</span><span class="hljs-comment"># 检测物理文件磁盘空间</span>diskMaxUsedSpaceRatio=88<span class="hljs-comment"># 存储路径</span><span class="hljs-comment"># storePathRootDir=/home/ztztdata/rocketmq-all-4.1.0-incubating/store</span><span class="hljs-comment"># commitLog 存储路径</span><span class="hljs-comment"># storePathCommitLog=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/commitlog</span><span class="hljs-comment"># 消费队列存储</span><span class="hljs-comment"># storePathConsumeQueue=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/consumequeue</span><span class="hljs-comment"># 消息索引存储路径</span><span class="hljs-comment"># storePathIndex=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/index</span><span class="hljs-comment"># checkpoint 文件存储路径</span><span class="hljs-comment"># storeCheckpoint=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/checkpoint</span><span class="hljs-comment"># abort 文件存储路径</span><span class="hljs-comment"># abortFile=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/abort</span><span class="hljs-comment"># 限制的消息大小</span>maxMessageSize=65536<span class="hljs-comment"># flushCommitLogLeastPages=4</span><span class="hljs-comment"># flushConsumeQueueLeastPages=2</span><span class="hljs-comment"># flushCommitLogThoroughInterval=10000</span><span class="hljs-comment"># flushConsumeQueueThoroughInterval=60000</span><span class="hljs-comment"># Broker 的角色</span><span class="hljs-comment"># - ASYNC_MASTER 异步复制Master</span><span class="hljs-comment"># - SYNC_MASTER 同步双写Master</span><span class="hljs-comment"># - SLAVE</span>brokerRole=ASYNC_MASTER<span class="hljs-comment"># 刷盘方式</span><span class="hljs-comment"># - ASYNC_FLUSH 异步刷盘</span><span class="hljs-comment"># - SYNC_FLUSH 同步刷盘</span>flushDiskType=ASYNC_FLUSH<span class="hljs-comment"># 发消息线程池数量</span><span class="hljs-comment"># sendMessageThreadPoolNums=128</span><span class="hljs-comment"># 拉消息线程池数量</span><span class="hljs-comment"># pullMessageThreadPoolNums=128</span></code></pre><p>启动docker-compose</p><pre><code class="hljs bash">docker-compose up -d</code></pre><p>查看docker进程</p><pre><code class="hljs bash">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                                                NAMES9c2847e46465        styletang/rocketmq-console-ng   <span class="hljs-string">&quot;sh -c &#x27;java <span class="hljs-variable">$JAVA_O</span>…&quot;</span>   20 minutes ago      Up 20 minutes       0.0.0.0:8080-&gt;8080/tcp                               rmqconsole5a1631236667        foxiswho/rocketmq:server        <span class="hljs-string">&quot;/bin/sh -c &#x27;cd <span class="hljs-variable">$&#123;RO…&quot;   20 minutes ago      Up 20 minutes       10909/tcp, 0.0.0.0:9876-&gt;9876/tcp, 10911-10912/tcp   rmqnamesrv</span></span></code></pre><p>访问 外网ip:8080 登入控制台</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署xxl-job</title>
    <link href="/2020/05/29/2020-05-29-Docker%E9%83%A8%E7%BD%B2xxl-job/"/>
    <url>/2020/05/29/2020-05-29-Docker%E9%83%A8%E7%BD%B2xxl-job/</url>
    
    <content type="html"><![CDATA[<h5 id="拉取xxl-job-镜像"><a href="#拉取xxl-job-镜像" class="headerlink" title="拉取xxl-job 镜像"></a>拉取xxl-job 镜像</h5><p>docker pull xuxueli/xxl-job-admin:2.0.2</p><h5 id="下载application-properties"><a href="#下载application-properties" class="headerlink" title="下载application.properties"></a>下载application.properties</h5><p>修改数据库配置，以及端口号等配置</p><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/xuxueli/</span>xxl-job<span class="hljs-regexp">/2.0.2/</span>xxl-job-admin<span class="hljs-regexp">/src/m</span>ain<span class="hljs-regexp">/resources/</span>application.properties</code></pre><h5 id="启动镜像容器"><a href="#启动镜像容器" class="headerlink" title="启动镜像容器"></a>启动镜像容器</h5><pre><code class="hljs jboss-cli">docker run -d <span class="hljs-params">--name</span> xxl-job-admin -v 修改后的配置文件位置<span class="hljs-string">/application.properties</span>  <span class="hljs-params">--net</span> host -e PARAMS=&#x27;<span class="hljs-params">--spring</span>.config.location=<span class="hljs-string">/application.properties</span>&#x27; xuxueli/xxl-job-admin<span class="hljs-function">:2.0.2</span></code></pre><h5 id="也可以直接添加参数启动镜像容器"><a href="#也可以直接添加参数启动镜像容器" class="headerlink" title="也可以直接添加参数启动镜像容器"></a>也可以直接添加参数启动镜像容器</h5><p>注意一些参数如邮箱可以省略</p><pre><code class="hljs brainfuck"><span class="hljs-comment">docker</span> <span class="hljs-comment">run</span> <span class="hljs-literal">-</span><span class="hljs-comment">e</span> <span class="hljs-comment">PARAMS=&quot;</span>--<span class="hljs-comment">spring</span><span class="hljs-string">.</span><span class="hljs-comment">datasource</span><span class="hljs-string">.</span><span class="hljs-comment">url=jdbc:mysql://数据库地址:3306/xxl</span><span class="hljs-literal">-</span><span class="hljs-comment">job?Unicode=true&amp;characterEncoding=UTF</span><span class="hljs-literal">-</span><span class="hljs-comment">8</span> --<span class="hljs-comment">spring</span><span class="hljs-string">.</span><span class="hljs-comment">datasource</span><span class="hljs-string">.</span><span class="hljs-comment">password=数据库密码</span> --<span class="hljs-comment">spring</span><span class="hljs-string">.</span><span class="hljs-comment">mail</span><span class="hljs-string">.</span><span class="hljs-comment">host=smtp</span><span class="hljs-string">.</span><span class="hljs-comment">163</span><span class="hljs-string">.</span><span class="hljs-comment">com</span> --<span class="hljs-comment">spring</span><span class="hljs-string">.</span><span class="hljs-comment">mail</span><span class="hljs-string">.</span><span class="hljs-comment">username=邮箱名</span> --<span class="hljs-comment">spring</span><span class="hljs-string">.</span><span class="hljs-comment">mail</span><span class="hljs-string">.</span><span class="hljs-comment">password=邮箱密码</span> --<span class="hljs-comment">xxl</span><span class="hljs-string">.</span><span class="hljs-comment">job</span><span class="hljs-string">.</span><span class="hljs-comment">login</span><span class="hljs-string">.</span><span class="hljs-comment">password=登录密码&quot;</span> <span class="hljs-literal">-</span><span class="hljs-comment">p</span> <span class="hljs-comment">18092:8080</span> <span class="hljs-literal">-</span><span class="hljs-comment">v</span> <span class="hljs-comment">/tmp:/data/applogs</span> --<span class="hljs-comment">name</span> <span class="hljs-comment">xxl</span><span class="hljs-literal">-</span><span class="hljs-comment">job</span><span class="hljs-literal">-</span><span class="hljs-comment">admin</span> --<span class="hljs-comment">privileged=true</span> <span class="hljs-literal">-</span><span class="hljs-comment">d</span> <span class="hljs-comment">xuxueli/xxl</span><span class="hljs-literal">-</span><span class="hljs-comment">job</span><span class="hljs-literal">-</span><span class="hljs-comment">admin:2</span><span class="hljs-string">.</span><span class="hljs-comment">0</span><span class="hljs-string">.</span><span class="hljs-comment">2</span></code></pre><h5 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h5><p>文档介绍：<a href="http://www.xuxueli.com/xxl-job/#/">http://www.xuxueli.com/xxl-job/#/</a></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuxueli<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xxl-job-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h5 id="2-增加配置"><a href="#2-增加配置" class="headerlink" title="2.增加配置"></a>2.增加配置</h5><pre><code class="hljs dts"><span class="hljs-symbol">xxl:</span><span class="hljs-symbol">  job:</span><span class="hljs-symbol">    admin:</span><span class="hljs-symbol">      addresses:</span> http:<span class="hljs-comment">//10.158.1.158:19031/xxl-job-admin</span><span class="hljs-symbol">    executor:</span><span class="hljs-symbol">      appname:</span> square-executor<span class="hljs-symbol">      ip:</span><span class="hljs-symbol">      port:</span> $&#123;job-port:<span class="hljs-number">31400</span>&#125;<span class="hljs-symbol">      logpath:</span> <span class="hljs-meta-keyword">/app/</span>data<span class="hljs-meta-keyword">/logs/</span><span class="hljs-symbol">      logretentiondays:</span> <span class="hljs-number">-1</span><span class="hljs-symbol">    accessToken:</span></code></pre><h5 id="3-java配置类"><a href="#3-java配置类" class="headerlink" title="3.java配置类"></a>3.java配置类</h5><p>XxlJobConfig.java</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;xxl.job&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxlJobProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> JobAdmin admin;    <span class="hljs-keyword">private</span> String accessToken;    <span class="hljs-keyword">private</span> JobExecutor executor;    <span class="hljs-meta">@Data</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobAdmin</span> </span>&#123;        <span class="hljs-keyword">private</span> String addresses;    &#125;    <span class="hljs-meta">@Data</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobExecutor</span> </span>&#123;        <span class="hljs-keyword">private</span> String appName;        <span class="hljs-keyword">private</span> String ip;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;        <span class="hljs-keyword">private</span> String logPath;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> logRetentionDays;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * xxl-job config</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xuxueli 2017-04-28</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.square.cape.jobhandler&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxlJobConfig</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    XxlJobProperties xxlJobProperties;    <span class="hljs-meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;destroy&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> XxlJobSpringExecutor <span class="hljs-title">xxlJobExecutor</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);        XxlJobSpringExecutor xxlJobSpringExecutor = <span class="hljs-keyword">new</span> XxlJobSpringExecutor();        xxlJobSpringExecutor.setAdminAddresses(xxlJobProperties.getAdmin().getAddresses());        xxlJobSpringExecutor.setAppName(xxlJobProperties.getExecutor().getAppName());        xxlJobSpringExecutor.setIp(xxlJobProperties.getExecutor().getIp());        xxlJobSpringExecutor.setPort(xxlJobProperties.getExecutor().getPort());        xxlJobSpringExecutor.setAccessToken(xxlJobProperties.getAccessToken());        xxlJobSpringExecutor.setLogPath(xxlJobProperties.getExecutor().getLogPath());        xxlJobSpringExecutor.setLogRetentionDays(xxlJobProperties.getExecutor().getLogRetentionDays());        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;    &#125;&#125;</code></pre><h4 id="4-task示例"><a href="#4-task示例" class="headerlink" title="4.task示例"></a>4.task示例</h4><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@JobHandler(value = &quot;xxlQueryJobHandler&quot;)</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxlQueryJobHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IJobHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ReturnT&lt;String&gt; <span class="hljs-title">execute</span><span class="hljs-params">(String param)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        log.info(<span class="hljs-string">&quot;xxlQueryJobHandler start.&quot;</span>);        System.err.println(<span class="hljs-string">&quot;xxlQueryJobHandler&quot;</span> + param);        log.info(<span class="hljs-string">&quot;xxlQueryJobHandler end.&quot;</span>);        <span class="hljs-keyword">return</span> SUCCESS;    &#125;&#125;</code></pre><h5 id="5-启动项目"><a href="#5-启动项目" class="headerlink" title="5.启动项目"></a>5.启动项目</h5><p>项目启动参数添加job-port：-Djob-port=30000</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署Redis</title>
    <link href="/2020/05/28/2020-05-28-Docker%E9%83%A8%E7%BD%B2Redis/"/>
    <url>/2020/05/28/2020-05-28-Docker%E9%83%A8%E7%BD%B2Redis/</url>
    
    <content type="html"><![CDATA[<h4 id="redis容器初始化"><a href="#redis容器初始化" class="headerlink" title="redis容器初始化"></a>redis容器初始化</h4><p>容器初始化，使用docker-compose方式，先创建一个docker-compose.yml文件，内容如下:</p><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-symbol">services:</span><span class="hljs-symbol"> redis1:</span><span class="hljs-symbol">  image:</span> publicisworldwide/redis-cluster<span class="hljs-symbol">  network_mode:</span> host<span class="hljs-symbol">  restart:</span> always<span class="hljs-symbol">  volumes:</span>   - <span class="hljs-meta-keyword">/data/</span>redis/<span class="hljs-number">8001</span>/data:/data<span class="hljs-symbol">  environment:</span>   - REDIS_PORT=<span class="hljs-number">8001</span><span class="hljs-symbol"> redis2:</span><span class="hljs-symbol">  image:</span> publicisworldwide/redis-cluster<span class="hljs-symbol">  network_mode:</span> host<span class="hljs-symbol">  restart:</span> always<span class="hljs-symbol">  volumes:</span>   - <span class="hljs-meta-keyword">/data/</span>redis/<span class="hljs-number">8002</span>/data:/data<span class="hljs-symbol">  environment:</span>   - REDIS_PORT=<span class="hljs-number">8002</span><span class="hljs-symbol"> redis3:</span><span class="hljs-symbol">  image:</span> publicisworldwide/redis-cluster<span class="hljs-symbol">  network_mode:</span> host<span class="hljs-symbol">  restart:</span> always<span class="hljs-symbol">  volumes:</span>   - <span class="hljs-meta-keyword">/data/</span>redis/<span class="hljs-number">8003</span>/data:/data<span class="hljs-symbol">  environment:</span>   - REDIS_PORT=<span class="hljs-number">8003</span><span class="hljs-symbol"> redis4:</span><span class="hljs-symbol">  image:</span> publicisworldwide/redis-cluster<span class="hljs-symbol">  network_mode:</span> host<span class="hljs-symbol">  restart:</span> always<span class="hljs-symbol">  volumes:</span>   - <span class="hljs-meta-keyword">/data/</span>redis/<span class="hljs-number">8004</span>/data:/data<span class="hljs-symbol">  environment:</span>   - REDIS_PORT=<span class="hljs-number">8004</span><span class="hljs-symbol"> redis5:</span><span class="hljs-symbol">  image:</span> publicisworldwide/redis-cluster<span class="hljs-symbol">  network_mode:</span> host<span class="hljs-symbol">  restart:</span> always<span class="hljs-symbol">  volumes:</span>   - <span class="hljs-meta-keyword">/data/</span>redis/<span class="hljs-number">8005</span>/data:/data<span class="hljs-symbol">  environment:</span>   - REDIS_PORT=<span class="hljs-number">8005</span><span class="hljs-symbol"> redis6:</span><span class="hljs-symbol">  image:</span> publicisworldwide/redis-cluster<span class="hljs-symbol">  network_mode:</span> host<span class="hljs-symbol">  restart:</span> always<span class="hljs-symbol">  volumes:</span>   - <span class="hljs-meta-keyword">/data/</span>redis/<span class="hljs-number">8006</span>/data:/data<span class="hljs-symbol">  environment:</span>   - REDIS_PORT=<span class="hljs-number">8006</span></code></pre><p>这里引用了别人的一个镜像publicisworldwide/redis-cluster，方便快捷。<br>这里使用host(主机)网络模式，把redis数据挂载到本机目录/data/redis/800*下。</p><p>若不想使用host模式，也可以把network_mode去掉，但就要加ports映射。<br>redis-cluster的节点端口共分为2种，一种是节点提供服务的端口，如6379；一种是节点间通信的端口，固定格式为：10000+6379。<br>我这里使用的是下面这种方式(后面安装的时候有问题，整合springboot获取数据的时候为null，猜想需要开通18001,18002的端口，所以我就试了下第一种，不用开端口也是可以的)<br>总体来讲推荐第一种</p><pre><code class="hljs"><span class="hljs-attribute">version</span>: &#x27;3&#x27;<span class="hljs-attribute">services:</span> redis1:  image: publicisworldwide/redis-cluster  restart: always  volumes:   - /data/redis/8001/data:/data  environment:   - REDIS_PORT=8001  ports:    - &#x27;8001:8001&#x27;       #服务端口    - &#x27;18001:18001&#x27;   #集群端口 redis2:  image: publicisworldwide/redis-cluster  restart: always  volumes:   - /data/redis/8002/data:/data  environment:   - REDIS_PORT=8002  ports:    - &#x27;8002:8002&#x27;    - &#x27;18002:18002&#x27; redis3:  image: publicisworldwide/redis-cluster  restart: always  volumes:   - /data/redis/8003/data:/data  environment:   - REDIS_PORT=8003  ports:    - &#x27;8003:8003&#x27;    - &#x27;18003:18003&#x27; redis4:  image: publicisworldwide/redis-cluster  restart: always  volumes:   - /data/redis/8004/data:/data  environment:   - REDIS_PORT=8004  ports:    - &#x27;8004:8004&#x27;    - &#x27;18004:18004&#x27; redis5:  image: publicisworldwide/redis-cluster  restart: always  volumes:   - /data/redis/8005/data:/data  environment:   - REDIS_PORT=8005  ports:    - &#x27;8005:8005&#x27;    - &#x27;18005:18005&#x27; redis6:  image: publicisworldwide/redis-cluster  restart: always  volumes:   - /data/redis/8006/data:/data  environment:   - REDIS_PORT=8006  ports:    - &#x27;8006:8006&#x27;    - &#x27;18006:18006&#x27;</code></pre><h4 id="创建文件后，直接启动服务"><a href="#创建文件后，直接启动服务" class="headerlink" title="创建文件后，直接启动服务"></a>创建文件后，直接启动服务</h4><pre><code class="hljs elixir"><span class="hljs-comment"># 窗口模式</span><span class="hljs-variable">$ </span>docker-compose up<span class="hljs-comment"># 后台进程</span><span class="hljs-variable">$ </span>docker-compose up -d</code></pre><h4 id="运行docker-compose-命令报错"><a href="#运行docker-compose-命令报错" class="headerlink" title="运行docker-compose 命令报错"></a>运行docker-compose 命令报错</h4><pre><code class="hljs cmake">$ docker-compose up -d-bash: docker-compose: <span class="hljs-keyword">command</span> <span class="hljs-keyword">not</span> found$ pip -V -bash: pip: <span class="hljs-keyword">command</span> <span class="hljs-keyword">not</span> found$ yum -y <span class="hljs-keyword">install</span> epel-release$ yum -y <span class="hljs-keyword">install</span> python-pip<span class="hljs-comment"># 升级</span>$ pip <span class="hljs-keyword">install</span> --upgrade pip</code></pre><h4 id="运行pip-install-docker-compose-命令报错"><a href="#运行pip-install-docker-compose-命令报错" class="headerlink" title="运行pip install docker-compose 命令报错"></a>运行pip install docker-compose 命令报错</h4><pre><code class="hljs sql">$ pip <span class="hljs-keyword">install</span> docker-composecompilation terminated.   <span class="hljs-keyword">error</span>: command <span class="hljs-string">&#x27;gcc&#x27;</span> <span class="hljs-keyword">failed</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">exit</span> <span class="hljs-keyword">status</span> <span class="hljs-number">1</span>   <span class="hljs-comment">----------------------------------------</span><span class="hljs-keyword">ERROR</span>: Command errored <span class="hljs-keyword">out</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">exit</span> <span class="hljs-keyword">status</span> <span class="hljs-number">1</span>: /usr/<span class="hljs-keyword">bin</span>/python2 -u -c <span class="hljs-string">&#x27;import sys, setuptools, tokenize; sys.argv[0] = &#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;/tmp/pip-install-ZnU75z/subprocess32/setup.py&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;; __file__=&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;/tmp/pip-install-ZnU75z/subprocess32/setup.py&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;;f=getattr(tokenize, &#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;open&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;, open)(__file__);code=f.read().replace(&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;\r\n&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;\n&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;);f.close();exec(compile(code, __file__, &#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;exec&#x27;</span><span class="hljs-string">&quot;&#x27;&quot;</span><span class="hljs-string">&#x27;))&#x27;</span> <span class="hljs-keyword">install</span> <span class="hljs-comment">--record /tmp/pip-record-HQUs7W/install-record.txt --single-version-externally-managed --compile --install-headers /usr/include/python2.7/subprocess32 Check the logs for full command output.</span>$ sudo yum <span class="hljs-keyword">install</span> gcc libffi-devel python-devel openssl-devel -y</code></pre><h4 id="再次运行pip-install-docker-compose-命令报错"><a href="#再次运行pip-install-docker-compose-命令报错" class="headerlink" title="再次运行pip install docker-compose 命令报错"></a>再次运行pip install docker-compose 命令报错</h4><pre><code class="hljs sql">$ pip <span class="hljs-keyword">install</span> docker-compose<span class="hljs-keyword">ERROR</span>: Cannot <span class="hljs-keyword">uninstall</span> <span class="hljs-string">&#x27;requests&#x27;</span>. It <span class="hljs-keyword">is</span> a distutils installed <span class="hljs-keyword">project</span> <span class="hljs-keyword">and</span> thus we cannot accurately determine which files belong <span class="hljs-keyword">to</span> it which would <span class="hljs-keyword">lead</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">only</span> a <span class="hljs-keyword">partial</span> uninstall.$ sudo pip <span class="hljs-keyword">install</span> <span class="hljs-comment">--ignore-installed requests</span>$ pip <span class="hljs-keyword">install</span> docker-compose$ docker-compose -<span class="hljs-keyword">version</span>docker-compose <span class="hljs-keyword">version</span> <span class="hljs-number">1.25</span><span class="hljs-number">.5</span>, <span class="hljs-keyword">build</span> <span class="hljs-literal">unknown</span></code></pre><h4 id="查看启动的进程"><a href="#查看启动的进程" class="headerlink" title="查看启动的进程"></a>查看启动的进程</h4><pre><code class="hljs awk"><span class="hljs-comment"># 再次运行 docker-compose</span>[root@localhost redis-cluster]<span class="hljs-comment"># docker-compose ps</span>        Name                       Command               State   Ports----------------------------------------------------------------------rediscluster_redis1_1   <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>entrypoint. ...   Up           rediscluster_redis2_1   <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>entrypoint. ...   Up           rediscluster_redis3_1   <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>entrypoint. ...   Up           rediscluster_redis4_1   <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>entrypoint. ...   Up           rediscluster_redis5_1   <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>entrypoint. ...   Up           rediscluster_redis6_1   <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>entrypoint. ...   Up</code></pre><p>状态为Up，说明服务均已启动，镜像无问题。<br><Strong>注意：以上镜像不能设置永久密码，其实redis一般是内网访问，可以不需密码。</Strong></p><h4 id="redis容器集群配置"><a href="#redis容器集群配置" class="headerlink" title="redis容器集群配置"></a>redis容器集群配置</h4><p>上面只是启动了6个redis容器，并没有设置集群，通过下面的命令可以设置集群,注意修改ip地址</p><pre><code class="hljs angelscript">$ docker run --rm -it inem0o/redis-trib create --replicas <span class="hljs-number">1</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8001</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8002</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8003</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8004</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8005</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8006</span></code></pre><p>这里同样使用了另一个镜像inem0o/redis-trib，执行时会自动下载。<br>日志如下：</p><pre><code class="hljs angelscript"><span class="hljs-string">[root@localhost disconf]</span># docker run --rm -it inem0o/redis-trib create --replicas <span class="hljs-number">1</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8001</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8002</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8003</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8004</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8005</span> <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span>:<span class="hljs-number">8006</span>Unable to find image <span class="hljs-string">&#x27;inem0o/redis-trib:latest&#x27;</span> locallylatest: Pulling <span class="hljs-keyword">from</span> inem0o/redis-triba2b2998a36ab: Pull complete a3ed95caeb02: Pull complete <span class="hljs-number">46</span>ab6b64c08e: Pull complete <span class="hljs-number">3</span>d82c3ac2025: Pull complete Digest: sha256:<span class="hljs-number">0b89d25b387f70ef1c54605bdf061dd86e0833dbc0e2149390570b8b372278f8</span>Status: Downloaded newer image <span class="hljs-keyword">for</span> inem0o/redis-trib:latest&gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on <span class="hljs-number">6</span> nodes...Using <span class="hljs-number">3</span> masters:<span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8001</span><span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8002</span><span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8003</span>Adding replica <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8004</span> to <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8001</span>Adding replica <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8005</span> to <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8002</span>Adding replica <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8006</span> to <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8003</span>M: <span class="hljs-number">67</span>d9a6bb6875f3a0f9a53e5bb05ddeca8e656950 <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8001</span>   slots:<span class="hljs-number">0</span><span class="hljs-number">-5460</span> (<span class="hljs-number">5461</span> slots) masterM: <span class="hljs-number">206626063f</span>31dcd7e69010ce13c258e786197f1e <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8002</span>   slots:<span class="hljs-number">5461</span><span class="hljs-number">-10922</span> (<span class="hljs-number">5462</span> slots) masterM: e9924018d95772b8ff535f6bc0605a6630837069 <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8003</span>   slots:<span class="hljs-number">10923</span><span class="hljs-number">-16383</span> (<span class="hljs-number">5461</span> slots) masterS: <span class="hljs-number">548f</span>4e65fbab8dcde8aac187849d50983d68599d <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8004</span>   replicates <span class="hljs-number">67</span>d9a6bb6875f3a0f9a53e5bb05ddeca8e656950S: <span class="hljs-number">0</span>a5c799c1f8fed083c50902639fc354e4c25aa8c <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8005</span>   replicates <span class="hljs-number">206626063f</span>31dcd7e69010ce13c258e786197f1eS: <span class="hljs-number">94e2530</span>ddd05b0e9eb3e71a9616342bd6647a5e6 <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8006</span>   replicates e9924018d95772b8ff535f6bc0605a6630837069Can I <span class="hljs-keyword">set</span> the above configuration? (type <span class="hljs-string">&#x27;yes&#x27;</span> to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting <span class="hljs-keyword">for</span> the cluster to join....&gt;&gt;&gt; Performing Cluster Check (using node <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8001</span>)M: <span class="hljs-number">67</span>d9a6bb6875f3a0f9a53e5bb05ddeca8e656950 <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-number">8001</span>   slots:<span class="hljs-number">0</span><span class="hljs-number">-5460</span> (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">94e2530</span>ddd05b0e9eb3e71a9616342bd6647a5e6 <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-symbol">8006@</span><span class="hljs-number">18006</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates e9924018d95772b8ff535f6bc0605a6630837069S: <span class="hljs-number">0</span>a5c799c1f8fed083c50902639fc354e4c25aa8c <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-symbol">8005@</span><span class="hljs-number">18005</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">206626063f</span>31dcd7e69010ce13c258e786197f1eM: e9924018d95772b8ff535f6bc0605a6630837069 <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-symbol">8003@</span><span class="hljs-number">18003</span>   slots:<span class="hljs-number">10923</span><span class="hljs-number">-16383</span> (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)M: <span class="hljs-number">206626063f</span>31dcd7e69010ce13c258e786197f1e <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-symbol">8002@</span><span class="hljs-number">18002</span>   slots:<span class="hljs-number">5461</span><span class="hljs-number">-10922</span> (<span class="hljs-number">5462</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">548f</span>4e65fbab8dcde8aac187849d50983d68599d <span class="hljs-number">172.19</span><span class="hljs-number">.165</span><span class="hljs-number">.222</span>:<span class="hljs-symbol">8004@</span><span class="hljs-number">18004</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">67</span>d9a6bb6875f3a0f9a53e5bb05ddeca8e656950<span class="hljs-string">[OK]</span> All nodes agree about slots configuration.&gt;&gt;&gt; Check <span class="hljs-keyword">for</span> open slots...&gt;&gt;&gt; Check slots coverage...<span class="hljs-string">[OK]</span> All <span class="hljs-number">16384</span> slots covered.</code></pre><h4 id="若创建成功，可以使用命令登录并查看集群信息。"><a href="#若创建成功，可以使用命令登录并查看集群信息。" class="headerlink" title="若创建成功，可以使用命令登录并查看集群信息。"></a>若创建成功，可以使用命令登录并查看集群信息。</h4><pre><code class="hljs lsl">$ docker psCONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                               NAMESdf0d49474423        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">28</span> minutes ago      Up <span class="hljs-number">28</span> minutes                                           deploy_redis6_1<span class="hljs-number">800</span>da782aefa        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">28</span> minutes ago      Up <span class="hljs-number">28</span> minutes                                           deploy_redis1_1c5ac53febd7e        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">28</span> minutes ago      Up <span class="hljs-number">28</span> minutes                                           deploy_redis3_1<span class="hljs-number">5306</span>b6f054a6        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">28</span> minutes ago      Up <span class="hljs-number">28</span> minutes                                           deploy_redis5_1<span class="hljs-number">3e66</span>efae6103        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">28</span> minutes ago      Up <span class="hljs-number">28</span> minutes                                           deploy_redis4_1# 进入其中一个容器$ docker  exec -it df0d49474423  redis-cli -h <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span> -p <span class="hljs-number">8001</span></code></pre><p>与上面相同，重新执行上面的第二步，再次查看结果如下：<br>以下信息显示集群状态ok。</p><pre><code class="hljs css">127<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-pseudo">:8003</span>&gt; <span class="hljs-selector-tag">cluster</span> <span class="hljs-selector-tag">info</span><span class="hljs-selector-tag">cluster_state</span><span class="hljs-selector-pseudo">:ok</span><span class="hljs-selector-tag">cluster_slots_assigned</span><span class="hljs-selector-pseudo">:16384</span><span class="hljs-selector-tag">cluster_slots_ok</span><span class="hljs-selector-pseudo">:16384</span><span class="hljs-selector-tag">cluster_slots_pfail</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-tag">cluster_slots_fail</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-tag">cluster_known_nodes</span><span class="hljs-selector-pseudo">:6</span><span class="hljs-selector-tag">cluster_size</span><span class="hljs-selector-pseudo">:3</span><span class="hljs-selector-tag">cluster_current_epoch</span><span class="hljs-selector-pseudo">:6</span><span class="hljs-selector-tag">cluster_my_epoch</span><span class="hljs-selector-pseudo">:3</span><span class="hljs-selector-tag">cluster_stats_messages_ping_sent</span><span class="hljs-selector-pseudo">:39</span><span class="hljs-selector-tag">cluster_stats_messages_pong_sent</span><span class="hljs-selector-pseudo">:37</span><span class="hljs-selector-tag">cluster_stats_messages_meet_sent</span><span class="hljs-selector-pseudo">:4</span><span class="hljs-selector-tag">cluster_stats_messages_sent</span><span class="hljs-selector-pseudo">:80</span><span class="hljs-selector-tag">cluster_stats_messages_ping_received</span><span class="hljs-selector-pseudo">:34</span><span class="hljs-selector-tag">cluster_stats_messages_pong_received</span><span class="hljs-selector-pseudo">:43</span><span class="hljs-selector-tag">cluster_stats_messages_meet_received</span><span class="hljs-selector-pseudo">:3</span><span class="hljs-selector-tag">cluster_stats_messages_received</span><span class="hljs-selector-pseudo">:80</span></code></pre><h4 id="设置集群密码"><a href="#设置集群密码" class="headerlink" title="设置集群密码"></a>设置集群密码</h4><p>上面提供了publicisworldwide/redis-cluster的镜像不能设置永久密码，是因为它没有给redis.conf写入权限，在我们重创建的镜像里是有写入权限的，所以可以创建永久密码。<br>集群构建完毕后再通过config set + config rewrite命令逐个机器设置密码<br>在之前的镜像上设置密码会有权限问题，如下：</p><pre><code class="hljs routeros">127.0.0.1:8001&gt;<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> masterauth 12345OK127.0.0.1:8001&gt;<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> requirepass 12345OK127.0.0.1:8001&gt; auth(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;auth&#x27;</span> command127.0.0.1:8001&gt; auth 12345OK127.0.0.1:8001&gt;<span class="hljs-built_in"> config </span>rewrite(error) ERR Rewriting<span class="hljs-built_in"> config </span>file: Permission denied</code></pre><h4 id="云服务器问题"><a href="#云服务器问题" class="headerlink" title="云服务器问题"></a>云服务器问题</h4><p>这个问题看了这个<a href="https://www.jianshu.com/p/7fec6d0d0ae0">博客</a>才想到怎么解决</p><pre><code class="hljs angelscript">#以集群方式进入任意一个节点，密码为前面配置文件所配置密码$ docker  exec -it b38c1d873732  redis-cli -h <span class="hljs-number">106.55</span><span class="hljs-number">.13</span><span class="hljs-number">.2</span> -p <span class="hljs-number">8002</span> -a <span class="hljs-number">12345</span>#进入后查看Redis集群主从信息CLUSTER NODES#上面命令作者结果如下，master表示主库，slave表示从库，前面字母和数字表示节点ID，slave后面的字母和数字表示所属主库的节点ID,后面还有连接状态等<span class="hljs-number">50</span>dceba04d0fa0fd0080a5f842496db07f9366d9 公网IP:<span class="hljs-symbol">8005@</span><span class="hljs-number">18005</span> slave <span class="hljs-number">54e44f</span>550328562d3cf3984426dc9b163aa9e2b1 <span class="hljs-number">0</span> <span class="hljs-number">1581404581690</span> <span class="hljs-number">9</span> connected<span class="hljs-number">7273</span>d970b66d2dcb0257f4d7555309f5c2404a09 公网IP:<span class="hljs-symbol">8003@</span><span class="hljs-number">18003</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1581404579686</span> <span class="hljs-number">12</span> connected <span class="hljs-number">10923</span><span class="hljs-number">-16383</span>f2dbad625bd52b102a916e5ae211cdc999a1d781 公网IP:<span class="hljs-symbol">8002@</span><span class="hljs-number">18002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1581404580688</span> <span class="hljs-number">14</span> connected <span class="hljs-number">5461</span><span class="hljs-number">-10922</span><span class="hljs-number">54e44f</span>550328562d3cf3984426dc9b163aa9e2b1 内网IP:<span class="hljs-symbol">8001@</span><span class="hljs-number">18001</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1581404580000</span> <span class="hljs-number">9</span> connected <span class="hljs-number">0</span><span class="hljs-number">-5460</span><span class="hljs-number">420299</span>acf743549c19cab5ecf0b6cb9e0f482b9b 公网IP:<span class="hljs-symbol">8004@</span><span class="hljs-number">18004</span> slave <span class="hljs-number">7273</span>d970b66d2dcb0257f4d7555309f5c2404a09 <span class="hljs-number">0</span> <span class="hljs-number">1581404581000</span> <span class="hljs-number">12</span> connecteda4a884ed02f0da555020cb2e5fb5bbfbe2148a05 公网IP:<span class="hljs-symbol">8006@</span><span class="hljs-number">18006</span> slave f2dbad625bd52b102a916e5ae211cdc999a1d781 <span class="hljs-number">0</span> <span class="hljs-number">1581404579000</span> <span class="hljs-number">14</span> connected</code></pre><p>接下来是解决本章前面提出的问题。前面我们说到整合Spring Boot后，它会用任意节点通过CLUSTER SLOTS命令去获取集群中的槽点信息，<br>我们可以看到上面的结果中8001节点返回的是内网IP，其实当我们用8002节点执行CLUSTER SLOTS命令时会发现7002节点对应的IP地址变为了内网IP，<br>而其他节点包括之前的7001节点都是公网IP，也就是说用哪个节点获取集群信息则那个节点会变成内网IP，<br>这是因为每个节点的集群信息是从之前每个节点的配置文件里面的这一行cluster-config-file nodes_8001.conf指定文件里面读取的信息，<br>前面说过第一次启动后会在cd ./cluster/data/相对应节点目录下生成该文件，打开该文件会发现每个节点自己本身的IP地址均为内网IP，其他的均为公网IP，这是因为生成时自己节点的IP是通过读取网卡IP作为地址的，由于云服务器的网卡地址是内网，所以这里是内网IP。那么知道了它是怎么获取信息的那就好解决了，以修改8001节点为例，<br>整合Spring Boot报如下错误：</p><pre><code class="hljs stylus">Caused by: org<span class="hljs-selector-class">.redisson</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.RedisConnectionException</span>: Not all slots are covered! Only <span class="hljs-number">10923</span> slots are avaliableat org<span class="hljs-selector-class">.redisson</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.ClusterConnectionManager</span>.&lt;init&gt;(ClusterConnectionManager<span class="hljs-selector-class">.java</span>:<span class="hljs-number">174</span>)at org<span class="hljs-selector-class">.redisson</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.ConfigSupport</span>.createConnectionManager(ConfigSupport<span class="hljs-selector-class">.java</span>:<span class="hljs-number">200</span>)at org<span class="hljs-selector-class">.redisson</span><span class="hljs-selector-class">.Redisson</span>.&lt;init&gt;(Redisson<span class="hljs-selector-class">.java</span>:<span class="hljs-number">120</span>)at org<span class="hljs-selector-class">.redisson</span><span class="hljs-selector-class">.Redisson</span>.create(Redisson<span class="hljs-selector-class">.java</span>:<span class="hljs-number">160</span>)at com<span class="hljs-selector-class">.ms</span><span class="hljs-selector-class">.redisdemo</span><span class="hljs-selector-class">.redisson</span><span class="hljs-selector-class">.RedissonClusterUtil</span>.createClient(RedissonClusterUtil<span class="hljs-selector-class">.java</span>:<span class="hljs-number">51</span>)at com<span class="hljs-selector-class">.ms</span><span class="hljs-selector-class">.redisdemo</span><span class="hljs-selector-class">.redisson</span><span class="hljs-selector-class">.RedissonClusterUtil</span>.&lt;clinit&gt;(RedissonClusterUtil<span class="hljs-selector-class">.java</span>:<span class="hljs-number">39</span>)... <span class="hljs-number">26</span> moreCaused by: io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.ConnectTimeoutException</span>: connection timed out: <span class="hljs-number">172.16</span>.<span class="hljs-number">30.41</span>/<span class="hljs-number">172.16</span>.<span class="hljs-number">30.41</span>:<span class="hljs-number">8001</span>at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.nio</span>.AbstractNioChannel<span class="hljs-variable">$AbstractNioUnsafe</span>$<span class="hljs-number">1</span>.run(AbstractNioChannel<span class="hljs-selector-class">.java</span>:<span class="hljs-number">263</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.PromiseTask<span class="hljs-variable">$RunnableAdapter</span>.call(PromiseTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">38</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ScheduledFutureTask</span>.run(ScheduledFutureTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">127</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.AbstractEventExecutor</span>.safeExecute(AbstractEventExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">163</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.SingleThreadEventExecutor</span>.runAllTasks(SingleThreadEventExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">416</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.channel</span><span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.NioEventLoop</span>.run(NioEventLoop<span class="hljs-selector-class">.java</span>:<span class="hljs-number">515</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run(SingleThreadEventExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">918</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.internal</span>.ThreadExecutorMap$<span class="hljs-number">2</span>.run(ThreadExecutorMap<span class="hljs-selector-class">.java</span>:<span class="hljs-number">74</span>)at io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FastThreadLocalRunnable</span>.run(FastThreadLocalRunnable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">30</span>)at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span>.run(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)</code></pre><p>解决步骤如下：</p><pre><code class="hljs angelscript">#停止容器进程$ docker stop b38c1d873732#进入配置目录$ cd /data/redis/<span class="hljs-number">8001</span>/data/# 依次修改集群文件$ vim nodes.conf <span class="hljs-number">013</span>c59dceb1bf2262385106760f36b9239f7ef55 外网:<span class="hljs-symbol">8005@</span><span class="hljs-number">18005</span> slave <span class="hljs-number">31603</span>ac0097d0958970d43a01db571761b61828b <span class="hljs-number">0</span> <span class="hljs-number">1590716333000</span> <span class="hljs-number">8</span> connected<span class="hljs-number">8829</span>af563e092f9dcf36f49c015f5b22838b9f1f 内网:<span class="hljs-symbol">8001@</span><span class="hljs-number">18001</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1590716333000</span> <span class="hljs-number">11</span> connected <span class="hljs-number">0</span><span class="hljs-number">-5460</span><span class="hljs-number">31603</span>ac0097d0958970d43a01db571761b61828b 外网:<span class="hljs-symbol">8002@</span><span class="hljs-number">18002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1590716333000</span> <span class="hljs-number">8</span> connected <span class="hljs-number">5461</span><span class="hljs-number">-10922</span>a7a7e90c814d0bc70757a78f4a7421b2937fb949 外网:<span class="hljs-symbol">8006@</span><span class="hljs-number">18006</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1590716333000</span> <span class="hljs-number">9</span> connected <span class="hljs-number">10923</span><span class="hljs-number">-16383</span><span class="hljs-number">9f</span>f0099fefde6a4e60a85f7ebf4fc0cf82210ae1 外网:<span class="hljs-symbol">8004@</span><span class="hljs-number">18004</span> slave <span class="hljs-number">8829</span>af563e092f9dcf36f49c015f5b22838b9f1f <span class="hljs-number">0</span> <span class="hljs-number">1590716334708</span> <span class="hljs-number">11</span> connected<span class="hljs-number">9</span>c88658767c94dca36d7e4594fb944064cc7edf2 外网:<span class="hljs-symbol">8003@</span><span class="hljs-number">18003</span> slave a7a7e90c814d0bc70757a78f4a7421b2937fb949 <span class="hljs-number">0</span> <span class="hljs-number">1590716333909</span> <span class="hljs-number">9</span> connected# 启动容器服务$ docker start b38c1d873732</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装镜像</title>
    <link href="/2020/05/22/2020-05-22-Docker%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F/"/>
    <url>/2020/05/22/2020-05-22-Docker%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Docker安装JDK"><a href="#Docker安装JDK" class="headerlink" title="Docker安装JDK"></a>Docker安装JDK</h3><h4 id="下载Jdk文件"><a href="#下载Jdk文件" class="headerlink" title="下载Jdk文件"></a>下载Jdk文件</h4><p>在oracle下载所需要的jdk版本的.tar.gz文件<br><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">下载地址</a></p><pre><code class="hljs bash">$ wget --no-check-certificate --no-cookies --header <span class="hljs-string">&quot;Cookie: oraclelicense=accept-securebackup-cookie&quot;</span> https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz</code></pre><h4 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h4><p>下载jdk8安装包并上传至已创建的特定目录（此处使用/usr/local/docker）</p><pre><code class="hljs bash">$ mkdir -p /usr/<span class="hljs-built_in">local</span>/docker$ touch Dockerfile$ vim Dockerfile</code></pre><h4 id="Dockerfile内容"><a href="#Dockerfile内容" class="headerlink" title="Dockerfile内容"></a>Dockerfile内容</h4><pre><code class="hljs bash"><span class="hljs-comment">#1、指定基础镜像，并且必须是第一条命令</span>FROM centos:7 <span class="hljs-comment">#2、指明该镜像的作者和电子邮箱</span>MAINTAINER Caixin <span class="hljs-string">&quot;975098371@qq.com&quot;</span> <span class="hljs-comment">#3、在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录</span>WORKDIR /usr/<span class="hljs-built_in">local</span>/docker <span class="hljs-comment">#4、一个复制命令，把jdk安装文件复制到镜像中，语法 ADD SRC DEST ,ADD命令具有自动解压功能</span>ADD jdk-8u241-linux-x64.tar.gz /usr/<span class="hljs-built_in">local</span>/docker <span class="hljs-comment">#5、配置环境变量，此处目录为tar.gz包解压后的名称，需提前解压知晓：</span>ENV JAVA_HOME=/usr/<span class="hljs-built_in">local</span>/docker/jdk1.8.0_241ENV CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jarENV PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span> <span class="hljs-comment">#6、设置启动命令</span>CMD [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-version&quot;</span>]</code></pre><h4 id="Dockerfile目录构建命令"><a href="#Dockerfile目录构建命令" class="headerlink" title="Dockerfile目录构建命令"></a>Dockerfile目录构建命令</h4><pre><code class="hljs bash">$ docker build -t jdk8_image:v1.0 .</code></pre><h4 id="构建完查看镜像"><a href="#构建完查看镜像" class="headerlink" title="构建完查看镜像"></a>构建完查看镜像</h4><pre><code class="hljs bash">$ docker imagesREPOSITORY           TAG                 IMAGE ID            CREATED             SIZEjdk8_image           v1.0                f85886ec4434        13 hours ago        607MBmysql                5.7                 a4fdfd462add        21 hours ago        448MBcentos               7                   b5b4d78bc90c        2 weeks ago         203MB</code></pre><h4 id="通过镜像构建容器并后台启动，run具备create和start的功能"><a href="#通过镜像构建容器并后台启动，run具备create和start的功能" class="headerlink" title="通过镜像构建容器并后台启动，run具备create和start的功能"></a>通过镜像构建容器并后台启动，run具备create和start的功能</h4><pre><code class="hljs bash">$ docker run -itd --name jdk_container jdk8_image:v1.0 /bin/bash</code></pre><h4 id="查看已运行容器列表"><a href="#查看已运行容器列表" class="headerlink" title="查看已运行容器列表"></a>查看已运行容器列表</h4><pre><code class="hljs bash">$ docker psCONTAINER ID        IMAGE                     COMMAND                  CREATED             STATUS              PORTS                               NAMES85b62fdbd56c        mysql:5.7                 <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   10 hours ago        Up 10 hours         0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mysql5.7a126de075856        jdk8_image:v1.0           <span class="hljs-string">&quot;/bin/bash&quot;</span>              13 hours ago        Up 13 hours                                             jdk_container</code></pre><h4 id="进入容器查看jdk是否生效"><a href="#进入容器查看jdk是否生效" class="headerlink" title="进入容器查看jdk是否生效"></a>进入容器查看jdk是否生效</h4><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -it  a126de075856 /bin/bash[root@a126de075856 docker]<span class="hljs-comment"># java -version</span>java version <span class="hljs-string">&quot;1.8.0_241&quot;</span>$ <span class="hljs-built_in">exit</span></code></pre><h3 id="Docker安装Mysql"><a href="#Docker安装Mysql" class="headerlink" title="Docker安装Mysql"></a>Docker安装Mysql</h3><h4 id="查看Docker仓库中的mysql命令"><a href="#查看Docker仓库中的mysql命令" class="headerlink" title="查看Docker仓库中的mysql命令"></a>查看Docker仓库中的mysql命令</h4><pre><code class="hljs bash">$ docker search mysqlNAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDmysql                             MySQL is a widely used, open-source relation…   9525                [OK]                mariadb                           MariaDB is a community-developed fork of MyS…   3457                [OK]                mysql/mysql-server                Optimized MySQL Server Docker images. Create…   698                                     [OK]</code></pre><h4 id="pull到本地系统镜像"><a href="#pull到本地系统镜像" class="headerlink" title="pull到本地系统镜像"></a>pull到本地系统镜像</h4><pre><code class="hljs bash">$ docker pull mysql:5.7</code></pre><h4 id="docker列出已经下载的镜像并启动容器"><a href="#docker列出已经下载的镜像并启动容器" class="headerlink" title="docker列出已经下载的镜像并启动容器"></a>docker列出已经下载的镜像并启动容器</h4><pre><code class="hljs bash">$ docker images$ docker run --name mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</code></pre><p>命令说明：</p><pre><code class="hljs bash">-p 3306:3306：将容器的3306端口映射到主机的3306端口-v <span class="hljs-variable">$PWD</span>/conf:/etc/mysql/conf.d：将主机当前路径下的conf目录挂载到容器的/etc/mysql/conf.d目录-v <span class="hljs-variable">$PWD</span>/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs-v <span class="hljs-variable">$PWD</span>/data:/mysql_data：将主机当前目录下的data目录挂载到容器的/mysql_data-e MYSQL_ROOT_PASSWORD=root：初始化root用户的密码--lower_case_table_names=1 设置表名参数名等忽略大小写-v /etc/localtime:/etc/localtime:ro   设置容器的时间与宿主机同步</code></pre><h4 id="进入Mysql容器"><a href="#进入Mysql容器" class="headerlink" title="进入Mysql容器"></a>进入Mysql容器</h4><pre><code class="hljs jboss-cli">$ docker ps    列出所有在运行的容器信息df0d49474423        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   12 minutes ago      Up 12 minutes                                           <span class="hljs-keyword">deploy</span>_redis6_1800da782aefa        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   12 minutes ago      Up 12 minutes                                           <span class="hljs-keyword">deploy</span>_redis1_1$ docker exec -it df0d49474423 <span class="hljs-string">/bin/bash</span><span class="hljs-comment"># mysql -uroot -p</span>Enter password:</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7安装Docker</title>
    <link href="/2020/05/21/2020-05-21-CentOS7%E5%AE%89%E8%A3%85Docker/"/>
    <url>/2020/05/21/2020-05-21-CentOS7%E5%AE%89%E8%A3%85Docker/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Docker 使用越来越多，安装也很简单，本次记录一下基本的步骤。</p><p>Docker 目前支持 CentOS 7 及以后的版本，内核要求至少为 3.10。</p><p>Docker 官网有安装步骤，本文只是记录一下，您也可以参考 <a href="https://docs.docker.com/install/linux/docker-ce/centos/">Get Docker CE for CentOS</a></p><h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><p>CentOS 7（Minimal Install）</p><pre><code class="hljs angelscript">$ cat /etc/redhat-release CentOS Linux release <span class="hljs-number">7.6</span><span class="hljs-number">.1810</span> (Core)</code></pre><h4 id="操作系统要求"><a href="#操作系统要求" class="headerlink" title="操作系统要求"></a>操作系统要求</h4><p>CentOS 7 以后都可以安装 Docker 了，也可以确认一下。</p><pre><code class="hljs angelscript">$ uname -aLinux localhost.localdomain <span class="hljs-number">3.10</span><span class="hljs-number">.0</span><span class="hljs-number">-957.1</span><span class="hljs-number">.3</span>.el7.x86_64 #<span class="hljs-number">1</span> SMP Thu Nov <span class="hljs-number">29</span> <span class="hljs-number">14</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> UTC <span class="hljs-number">2018</span> x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>Docker 需要用到 centos-extra 这个源，如果您关闭了，需要重启启用，可以参考 <a href="https://wiki.centos.org/AdditionalResources/Repositories">Available Repositories for CentOS</a></p><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><pre><code class="hljs livescript">$ sudo yum remove docker <span class="hljs-string">\</span>                  docker-client <span class="hljs-string">\</span>                  docker-client-latest <span class="hljs-string">\</span>                  docker-common <span class="hljs-string">\</span>                  docker-latest <span class="hljs-string">\</span>                  docker-latest-logrotate <span class="hljs-string">\</span>                  docker-logrotate <span class="hljs-string">\</span>                  docker-engine</code></pre><p>旧版本的内容在 /var/lib/docker 下，目录中的镜像(images), 容器(containers), 存储卷(volumes), 和 网络配置（networks）都可以保留。</p><p>Docker CE 包，目前的包名为 docker-ce。</p><h4 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h4><p>为了方便添加软件源，支持 devicemapper 存储类型，安装如下软件包</p><pre><code class="hljs sql">$ sudo yum <span class="hljs-keyword">update</span>$ sudo yum <span class="hljs-keyword">install</span> -y yum-utils \  device-mapper-persistent-<span class="hljs-keyword">data</span> \  lvm2</code></pre><h4 id="添加-yum-软件源"><a href="#添加-yum-软件源" class="headerlink" title="添加 yum 软件源"></a>添加 yum 软件源</h4><p>添加 Docker 稳定版本的 yum 软件源</p><pre><code class="hljs awk">$ sudo yum-config-manager \    --add-repo \    https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>centos/docker-ce.repo</code></pre><h4 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h4><p>更新一下 yum 软件源的缓存，并安装 Docker。</p><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo yum update</code></pre><p>如果想安装指定版本的 Docker，可以查看一下版本并安装。</p><pre><code class="hljs angelscript">$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64  <span class="hljs-number">3</span>:<span class="hljs-number">18.09</span><span class="hljs-number">.1</span><span class="hljs-number">-3.</span>el7                     docker-ce-stabledocker-ce.x86_64  <span class="hljs-number">3</span>:<span class="hljs-number">18.09</span><span class="hljs-number">.0</span><span class="hljs-number">-3.</span>el7                     docker-ce-stabledocker-ce.x86_64  <span class="hljs-number">18.06</span><span class="hljs-number">.1</span>.ce<span class="hljs-number">-3.</span>el7                    docker-ce-stabledocker-ce.x86_64  <span class="hljs-number">18.06</span><span class="hljs-number">.0</span>.ce<span class="hljs-number">-3.</span>el7                    docker-ce-stable</code></pre><p>可以指定版本安装,版本号可以忽略 : 和 el7，如 docker-ce-18.09.1</p><pre><code class="hljs angelscript">$ sudo yum install docker-ce<span class="hljs-number">-19.03</span><span class="hljs-number">.6</span></code></pre><p>至此，指定版本的 Docker 也安装完成，同样，操作系统内 docker 服务没有启动，只创建了 docker 组，而且组里没有用户。</p><p>使用脚本自动安装</p><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：</p><pre><code class="hljs dsconfig">$ <span class="hljs-string">curl </span>-<span class="hljs-string">fsSL </span><span class="hljs-string">get.</span><span class="hljs-string">docker.</span><span class="hljs-string">com </span>-o <span class="hljs-built_in">get-docker.sh</span><span class="hljs-built_in">$</span> <span class="hljs-string">sudo </span><span class="hljs-string">sh </span><span class="hljs-built_in">get-docker.sh</span> <span class="hljs-built_in">--mirror</span> <span class="hljs-string">Aliyun</span></code></pre><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p><h4 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h4><p>如果想添加到开机启动</p><pre><code class="hljs routeros">$ sudo systemctl <span class="hljs-builtin-name">enable</span> docker</code></pre><p>启动 docker 服务</p><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo systemctl <span class="hljs-built_in">start</span> docker</code></pre><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p>验证 Docker CE 安装是否正确，可以运行 hello-world 镜像</p><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="bash"> hello-world</span></code></pre><h4 id="更新-Docker-CE"><a href="#更新-Docker-CE" class="headerlink" title="更新 Docker CE"></a>更新 Docker CE</h4><p>使用 yum 管理，更新和卸载都很方便。</p><pre><code class="hljs vim">$ sudo yum <span class="hljs-keyword">update</span> docker-<span class="hljs-keyword">ce</span></code></pre><h4 id="卸载-Docker-CE"><a href="#卸载-Docker-CE" class="headerlink" title="卸载 Docker CE"></a>卸载 Docker CE</h4><pre><code class="hljs routeros">$ sudo yum <span class="hljs-builtin-name">remove</span> docker-ce</code></pre><h4 id="删除本地文件"><a href="#删除本地文件" class="headerlink" title="删除本地文件"></a>删除本地文件</h4><p>注意，docker 的本地文件，包括镜像(images), 容器(containers), 存储卷(volumes)等，都需要手工删除。默认目录存储在 /var/lib/docker。</p><pre><code class="hljs crystal">$ sudo rm -rf /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span></span></code></pre><h4 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h4><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>docker/daemon.json&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;</span>]&#125;</code></pre><h4 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h4><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>systemctl daemon-reload<span class="hljs-variable">$ </span>systemctl restart docker.service</code></pre><h4 id="测试docker是否正常安装和运行"><a href="#测试docker是否正常安装和运行" class="headerlink" title="测试docker是否正常安装和运行"></a>测试docker是否正常安装和运行</h4><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="bash"> hello-world</span></code></pre><h4 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h4><pre><code class="hljs applescript">$ Hello <span class="hljs-keyword">from</span> Docker!This message shows <span class="hljs-keyword">that</span> your installation appears <span class="hljs-keyword">to</span> be working correctly.</code></pre><h4 id="Docker-ps-命令"><a href="#Docker-ps-命令" class="headerlink" title="Docker ps 命令"></a>Docker ps 命令</h4> <pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span>           列出所有在运行的容器信息<span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span>        显示所有的容器，包括未运行的<span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-n</span> <span class="hljs-number">5</span>      列出最近创建的<span class="hljs-number">5</span>个容器信息</code></pre><h4 id="Docker-kill-命令"><a href="#Docker-kill-命令" class="headerlink" title="Docker kill 命令"></a>Docker kill 命令</h4><pre><code class="hljs lsl">$ docker ps           列出所有在运行的容器信息<span class="hljs-number">6</span>ef9b53290fa        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">9</span> minutes ago       Up <span class="hljs-number">7</span> minutes                                            deploy_redis1_1<span class="hljs-number">4094</span>cdf6eb2f        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">9</span> minutes ago       Up <span class="hljs-number">7</span> minutes                                            deploy_redis4_1c6445bb1629f        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">9</span> minutes ago       Up <span class="hljs-number">7</span> minutes                                            deploy_redis3_1<span class="hljs-number">9e69</span>b9811ec8        publicisworldwide/redis-cluster   <span class="hljs-string">&quot;/usr/local/bin/entr…&quot;</span>   <span class="hljs-number">9</span> minutes ago       Up <span class="hljs-number">7</span> minutes                                            deploy_redis2_1$ docker rm <span class="hljs-number">6</span>ef9b53290fa        删除已经停止的容器xxx$ docker rm -f  <span class="hljs-number">6</span>ef9b53290fa    可以删除正在运行的容器xxx</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> ****** <span class="hljs-attribute">--restart</span>=always</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture</title>
    <link href="/2020/04/25/2020-04-25-CompletableFuture/"/>
    <url>/2020/04/25/2020-04-25-CompletableFuture/</url>
    
    <content type="html"><![CDATA[<h3 id="1-runAsync-和-supplyAsync方法"><a href="#1-runAsync-和-supplyAsync方法" class="headerlink" title="1. runAsync 和 supplyAsync方法"></a>1. runAsync 和 supplyAsync方法</h3><p>CompletableFuture 提供了四个静态方法来创建一个异步操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title">runAsync</span><span class="hljs-params">(Runnable runnable)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></code></pre><p>没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。<br>如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。    </p><ul><li>runAsync方法不支持返回值。</li><li>supplyAsync可以支持返回值。</li></ul><p><Strong>示例</Strong></p><pre><code class="hljs java"><span class="hljs-comment">//无返回值</span>CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        System.err.println(e.getMessage());    &#125;    System.out.println(<span class="hljs-string">&quot;run end ...&quot;</span>);&#125;);future.join();<span class="hljs-comment">//有返回值</span>CompletableFuture&lt;Long&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        System.err.println(e.getMessage());    &#125;    System.out.println(<span class="hljs-string">&quot;run end ...&quot;</span>);    <span class="hljs-keyword">return</span> System.currentTimeMillis();&#125;);<span class="hljs-keyword">long</span> time = future2.join();System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + time);</code></pre><h3 id="2-计算结果完成时的回调方法"><a href="#2-计算结果完成时的回调方法" class="headerlink" title="2. 计算结果完成时的回调方法"></a>2. 计算结果完成时的回调方法</h3><p>当CompletableFuture的计算结果完成，或者抛出异常的时候，可以执行特定的Action。主要是下面的方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title">whenComplete</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-keyword">super</span> T,? <span class="hljs-keyword">super</span> Throwable&gt; action)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title">whenCompleteAsync</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-keyword">super</span> T,? <span class="hljs-keyword">super</span> Throwable&gt; action)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title">whenCompleteAsync</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-keyword">super</span> T,? <span class="hljs-keyword">super</span> Throwable&gt; action, Executor executor)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title">exceptionally</span><span class="hljs-params">(Function&lt;Throwable,? extends T&gt; fn)</span></span></code></pre><p>可以看到Action的类型是BiConsumer&lt;? super T,? super Throwable&gt;它可以处理正常的计算结果，或者异常情况。</p><ul><li>whenComplete 和 whenCompleteAsync 的区别：</li><li>whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。</li><li>whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。</li></ul><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Long&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            System.err.println(e.getMessage());        &#125;        System.out.println(<span class="hljs-string">&quot;run end ...&quot;</span>);        <span class="hljs-keyword">return</span> System.currentTimeMillis();    &#125;).whenComplete((t, action) -&gt; System.err.println(<span class="hljs-string">&quot;执行完成\n&quot;</span> + <span class="hljs-string">&quot;t=&quot;</span> + t +<span class="hljs-string">&quot;\n&quot;</span>+ <span class="hljs-string">&quot;action=&quot;</span> + action));<span class="hljs-keyword">long</span> time = future1.join();System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + time);CompletableFuture&lt;Long&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;      <span class="hljs-keyword">try</span> &#123;          TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          System.err.println(e.getMessage());      &#125;      <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>/<span class="hljs-number">0</span>;      System.out.println(<span class="hljs-string">&quot;run end ...&quot;</span>);      <span class="hljs-keyword">return</span> System.currentTimeMillis();  &#125;).exceptionally(t -&gt; <span class="hljs-number">1L</span>);  <span class="hljs-keyword">long</span> time = future2.join();  System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + time);</code></pre><h3 id="3-thenApply-方法"><a href="#3-thenApply-方法" class="headerlink" title="3. thenApply 方法"></a>3. thenApply 方法</h3><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletableFuture&lt;U&gt; <span class="hljs-title">thenApply</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T,? extends U&gt; fn)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title">thenApplyAsync</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T,? extends U&gt; fn)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title">thenApplyAsync</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span></code></pre><ul><li>Function&lt;? super T,? extends U&gt;</li><li>T：上一个任务返回结果的类型</li><li>U：当前任务的返回值类型</li></ul><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">long</span> result = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10</span>);    System.out.println(<span class="hljs-string">&quot;result1=&quot;</span> + result);    <span class="hljs-keyword">return</span> result;&#125;).thenApply(t -&gt; &#123;    <span class="hljs-keyword">long</span> result = t * <span class="hljs-number">10</span>;    System.out.println(<span class="hljs-string">&quot;result2=&quot;</span> + result);    <span class="hljs-keyword">return</span> result;&#125;);<span class="hljs-keyword">long</span> result = future.join();System.out.println(result);</code></pre><p>第二个任务依赖第一个任务的结果。</p><h3 id="4-handle-方法"><a href="#4-handle-方法" class="headerlink" title="4. handle 方法"></a>4. handle 方法</h3><p>handle 是执行任务完成时对结果的处理。<br>handle 方法和 thenApply 方法处理方式基本一样。不同的是 handle 是在任务完成后再执行，还可以处理异常的任务。<br>thenApply 只可以执行正常的任务，任务出现异常则不执行 thenApply 方法。   </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;U&gt; <span class="hljs-title">handle</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;U&gt; <span class="hljs-title">handleAsync</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;U&gt; <span class="hljs-title">handleAsync</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-keyword">super</span> T, Throwable, ? extends U&gt; fn,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;              <span class="hljs-keyword">int</span> i= <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10</span>);          &#125;).handle((param, throwable) -&gt; &#123;              <span class="hljs-keyword">int</span> result = -<span class="hljs-number">1</span>;              <span class="hljs-keyword">if</span>(throwable==<span class="hljs-keyword">null</span>)&#123;                  result = param * <span class="hljs-number">2</span>;              &#125;<span class="hljs-keyword">else</span>&#123;                  System.out.println(throwable.getMessage());              &#125;              <span class="hljs-keyword">return</span> result;          &#125;);          System.out.println(future.join());</code></pre><p>从示例中可以看出，在 handle 中可以根据任务是否有异常来进行做相应的后续处理操作。<br>而 thenApply 方法，如果上个任务出现错误，则不会执行 thenApply 方法。</p><h3 id="5-thenAccept-消费处理结果"><a href="#5-thenAccept-消费处理结果" class="headerlink" title="5. thenAccept 消费处理结果"></a>5. thenAccept 消费处理结果</h3><p>接收任务的处理结果，并消费处理，无返回结果。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">thenAccept</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10</span>);&#125;).thenAccept(integer -&gt; &#123;    System.out.println(integer);&#125;);future.join();</code></pre><p>从示例代码中可以看出，该方法只是消费执行完成的任务，并可以根据上面的任务返回的结果进行处理。并没有后续的输错操作。</p><h3 id="6-thenRun-方法"><a href="#6-thenRun-方法" class="headerlink" title="6. thenRun 方法"></a>6. thenRun 方法</h3><p>跟 thenAccept 方法不一样的是，不关心任务的处理结果。<br>只要上面的任务执行完成，就开始执行 thenAccept 。   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">thenRun</span><span class="hljs-params">(Runnable action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">thenRunAsync</span><span class="hljs-params">(Runnable action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">thenRunAsync</span><span class="hljs-params">(Runnable action,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt;&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10</span>);&#125;).thenRun(() -&gt; &#123;    System.out.println(<span class="hljs-string">&quot;thenRun ...&quot;</span>);&#125;);future.join();</code></pre><p>该方法同 thenAccept 方法类似。不同的是上个任务处理完成后，并不会把计算的结果传给 thenRun 方法。<br>只是处理玩任务后，执行 thenAccept 的后续操作。  </p><h3 id="7-thenCombine-合并任务"><a href="#7-thenCombine-合并任务" class="headerlink" title="7. thenCombine 合并任务"></a>7. thenCombine 合并任务</h3><p>thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U,V&gt; <span class="hljs-function">CompletionStage&lt;V&gt; <span class="hljs-title">thenCombine</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="hljs-keyword">super</span> T,? <span class="hljs-keyword">super</span> U,? extends V&gt; fn)</span></span>;<span class="hljs-keyword">public</span> &lt;U,V&gt; <span class="hljs-function">CompletionStage&lt;V&gt; <span class="hljs-title">thenCombineAsync</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="hljs-keyword">super</span> T,? <span class="hljs-keyword">super</span> U,? extends V&gt; fn)</span></span>;<span class="hljs-keyword">public</span> &lt;U,V&gt; <span class="hljs-function">CompletionStage&lt;V&gt; <span class="hljs-title">thenCombineAsync</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="hljs-keyword">super</span> T,? <span class="hljs-keyword">super</span> U,? extends V&gt; fn,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;hello&quot;</span>);     CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;world&quot;</span>);     CompletableFuture&lt;String&gt; result = future1.thenCombine(future2, (t, u) -&gt; &#123;         System.err.println(<span class="hljs-string">&quot;t=&quot;</span> + t + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;u=&quot;</span> + u);         <span class="hljs-keyword">return</span> t + u;     &#125;);     System.out.println(result.join());</code></pre><h3 id="8-thenAcceptBoth"><a href="#8-thenAcceptBoth" class="headerlink" title="8. thenAcceptBoth"></a>8. thenAcceptBoth</h3><p>当两个CompletionStage都执行完成后，把结果一块交给thenAcceptBoth来进行消耗</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;Void&gt; <span class="hljs-title">thenAcceptBoth</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> U&gt; action)</span></span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;Void&gt; <span class="hljs-title">thenAcceptBothAsync</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> U&gt; action)</span></span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;Void&gt; <span class="hljs-title">thenAcceptBothAsync</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> U&gt; action,     Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;           <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);           <span class="hljs-keyword">try</span> &#123;               TimeUnit.SECONDS.sleep(t);           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();           &#125;           System.out.println(<span class="hljs-string">&quot;f1=&quot;</span> + t);           <span class="hljs-keyword">return</span> t;       &#125;);       CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;           <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);           <span class="hljs-keyword">try</span> &#123;               TimeUnit.SECONDS.sleep(t);           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();           &#125;           System.out.println(<span class="hljs-string">&quot;f2=&quot;</span> + t);           <span class="hljs-keyword">return</span> t;       &#125;);       <span class="hljs-keyword">final</span> CompletableFuture&lt;Void&gt; acceptBoth = f1.thenAcceptBoth(f2, (t, u) -&gt; &#123;           System.out.println(<span class="hljs-string">&quot;f1=&quot;</span> + t + <span class="hljs-string">&quot;;f2=&quot;</span> + u + <span class="hljs-string">&quot;;&quot;</span>);       &#125;);</code></pre><h3 id="9-applyToEither-方法"><a href="#9-applyToEither-方法" class="headerlink" title="9. applyToEither 方法"></a>9. applyToEither 方法</h3><p>两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的转化操作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;U&gt; <span class="hljs-title">applyToEither</span><span class="hljs-params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="hljs-keyword">super</span> T, U&gt; fn)</span></span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;U&gt; <span class="hljs-title">applyToEitherAsync</span><span class="hljs-params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="hljs-keyword">super</span> T, U&gt; fn)</span></span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletionStage&lt;U&gt; <span class="hljs-title">applyToEitherAsync</span><span class="hljs-params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="hljs-keyword">super</span> T, U&gt; fn,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;             <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);             <span class="hljs-keyword">try</span> &#123;                 TimeUnit.SECONDS.sleep(t);             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                 e.printStackTrace();             &#125;             System.err.println(<span class="hljs-string">&quot;f1=&quot;</span>+t);             <span class="hljs-keyword">return</span> t;         &#125;);         CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;             <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);             <span class="hljs-keyword">try</span> &#123;                 TimeUnit.SECONDS.sleep(t);             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                 e.printStackTrace();             &#125;             System.err.println(<span class="hljs-string">&quot;f2=&quot;</span>+t);             <span class="hljs-keyword">return</span> t;         &#125;);         CompletableFuture&lt;Integer&gt; result = f1.applyToEither(f2, t -&gt; &#123;             System.err.println(t);             <span class="hljs-keyword">return</span> t * <span class="hljs-number">2</span>;         &#125;);         System.err.println(result.join());</code></pre><h3 id="10-acceptEither-方法"><a href="#10-acceptEither-方法" class="headerlink" title="10. acceptEither 方法"></a>10. acceptEither 方法</h3><p>两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的消耗操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">acceptEither</span><span class="hljs-params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">acceptEitherAsync</span><span class="hljs-params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">acceptEitherAsync</span><span class="hljs-params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java"> CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(t);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(<span class="hljs-string">&quot;f1=&quot;</span>+t);    <span class="hljs-keyword">return</span> t;&#125;);CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(t);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(<span class="hljs-string">&quot;f2=&quot;</span>+t);    <span class="hljs-keyword">return</span> t;&#125;);f1.acceptEither(f2, t -&gt; &#123;    System.out.println(t);&#125;);</code></pre><h3 id="11-runAfterEither-方法"><a href="#11-runAfterEither-方法" class="headerlink" title="11. runAfterEither 方法"></a>11. runAfterEither 方法</h3><p>两个CompletionStage，任何一个完成了都会执行下一步的操作（Runnable）</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">runAfterEither</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">runAfterEitherAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">runAfterEitherAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(t);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(<span class="hljs-string">&quot;f1=&quot;</span>+t);    <span class="hljs-keyword">return</span> t;&#125;);CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);    <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(t);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(<span class="hljs-string">&quot;f2=&quot;</span>+t);    <span class="hljs-keyword">return</span> t;&#125;);f1.runAfterBoth(f2, () -&gt;&#123;    System.out.println(<span class="hljs-string">&quot;上面两个任务任意一个执行完成了。&quot;</span>);&#125;);</code></pre><h3 id="12-runAfterBoth-方法"><a href="#12-runAfterBoth-方法" class="headerlink" title="12. runAfterBoth 方法"></a>12. runAfterBoth 方法</h3><p>两个CompletionStage，都完成了计算才会执行下一步的操作（Runnable）</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">runAfterBoth</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">runAfterBothAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> CompletionStage&lt;Void&gt; <span class="hljs-title">runAfterBothAsync</span><span class="hljs-params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;                <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(t);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(<span class="hljs-string">&quot;f1=&quot;</span>+t);                <span class="hljs-keyword">return</span> t;            &#125;);            CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;                <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(t);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(<span class="hljs-string">&quot;f2=&quot;</span>+t);                <span class="hljs-keyword">return</span> t;            &#125;);            f1.runAfterBoth(f2, () -&gt;&#123;                System.out.println(<span class="hljs-string">&quot;上面两个任务都执行完成了。&quot;</span>);            &#125;);</code></pre><h3 id="13-thenCompose-方法"><a href="#13-thenCompose-方法" class="headerlink" title="13. thenCompose 方法"></a>13. thenCompose 方法</h3><p>thenCompose 方法允许你对两个 CompletionStage 进行流水线操作，第一个操作完成时，将其结果作为参数传递给第二个操作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletableFuture&lt;U&gt; <span class="hljs-title">thenCompose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletableFuture&lt;U&gt; <span class="hljs-title">thenComposeAsync</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>;<span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">CompletableFuture&lt;U&gt; <span class="hljs-title">thenComposeAsync</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span> </span>;</code></pre><p><Strong>示例</Strong></p><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; f = CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);    System.out.println(<span class="hljs-string">&quot;t1=&quot;</span>+t);    <span class="hljs-keyword">return</span> t;&#125;).thenCompose(param -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;    <span class="hljs-keyword">int</span> t = param * <span class="hljs-number">10</span>;    System.out.println(<span class="hljs-string">&quot;t2=&quot;</span>+ t);    <span class="hljs-keyword">return</span> t;&#125;));System.out.println(<span class="hljs-string">&quot;thenCompose result : &quot;</span>+f.join());</code></pre><h3 id="14-CompletableFutureUtil"><a href="#14-CompletableFutureUtil" class="headerlink" title="14. CompletableFutureUtil"></a>14. CompletableFutureUtil</h3><pre><code class="hljs java"><span class="hljs-comment">//任务1：洗水壶-&gt;烧开水</span>CompletableFuture&lt;String&gt; f1 =        CompletableFuture.supplyAsync(()-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;T1:洗水壶...&quot;</span>);            sleep(<span class="hljs-number">1</span>, TimeUnit.SECONDS);            System.out.println(<span class="hljs-string">&quot;T1:烧开水...&quot;</span>);            sleep(<span class="hljs-number">15</span>, TimeUnit.SECONDS);            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;白开水&quot;</span>;        &#125;);<span class="hljs-comment">//任务2：洗茶壶-&gt;洗茶杯-&gt;拿茶叶</span>CompletableFuture&lt;String&gt; f2 =        CompletableFuture.supplyAsync(()-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;T2:洗茶壶...&quot;</span>);            sleep(<span class="hljs-number">1</span>, TimeUnit.SECONDS);            System.out.println(<span class="hljs-string">&quot;T2:洗茶杯...&quot;</span>);            sleep(<span class="hljs-number">2</span>, TimeUnit.SECONDS);            System.out.println(<span class="hljs-string">&quot;T2:拿茶叶...&quot;</span>);            sleep(<span class="hljs-number">1</span>, TimeUnit.SECONDS);            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;龙井&quot;</span>;        &#125;);<span class="hljs-comment">//任务3：任务1和任务2完成后执行：泡茶</span>CompletableFuture&lt;String&gt; f3 =        f1.thenCombine(f2,(f11, f22)-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;T1:拿到水:&quot;</span> + f11);            System.out.println(<span class="hljs-string">&quot;T1:泡茶...&quot;</span>+f22);            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;上茶:&quot;</span> + f11;        &#125;);<span class="hljs-comment">//等待任务3执行结果</span>System.out.println(f3.join());</code></pre><pre><code class="hljs java"><span class="hljs-keyword">final</span> ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">2</span> * (Runtime.getRuntime().availableProcessors()) + <span class="hljs-number">1</span>);CompletableFuture&lt;DeliverTmGisDTO&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword">new</span> DeliverTmGisDTO(<span class="hljs-keyword">null</span>, commonGisService.gisAddrSlip(request.getSrcAddress()), <span class="hljs-keyword">null</span>))        .exceptionally(x -&gt; <span class="hljs-keyword">null</span>);CompletableFuture&lt;DeliverTmGisDTO&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword">new</span> DeliverTmGisDTO(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, commonGisService.gisAddrSlip(request.getDestAddress())))        .exceptionally(y -&gt; <span class="hljs-keyword">null</span>);CompletableFuture&lt;DeliverTmGisDTO&gt; future3 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword">new</span> DeliverTmGisDTO(commonOrgService.depthGetClientCodeAndCheckCode(orgId, <span class="hljs-number">0</span>), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>), forkJoinPool)        .exceptionally(z -&gt; <span class="hljs-keyword">null</span>);<span class="hljs-keyword">final</span> List&lt;CompletableFuture&lt;DeliverTmGisDTO&gt;&gt; futures = Arrays.asList(future1, future2, future3);List&lt;DeliverTmGisDTO&gt; deliverTmGis;<span class="hljs-keyword">try</span> &#123;    deliverTmGis = CommonCompletableFutureUtil.sequenceExceptionallyCompleteMeetFirstfFailure(futures).join();&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    log.error(<span class="hljs-string">&quot;BspOrderController.deliverTmV3 error:&#123;&#125;&quot;</span>, e.getMessage());    <span class="hljs-keyword">throw</span> e;&#125; <span class="hljs-keyword">finally</span> &#123;    log.info(<span class="hljs-string">&quot;forkJoinPool.shutdownNow success&quot;</span>);    forkJoinPool.shutdownNow();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sf.united.store.common.utils;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;<span class="hljs-comment">/**</span><span class="hljs-comment"> * created by liurenjin on 2019/2/21</span><span class="hljs-comment"> * 参考</span><span class="hljs-comment"> * https://www.cnblogs.com/dennyzhangdd/p/7010972.html</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonCompletableFutureUtil</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(CommonCompletableFutureUtil.class);    <span class="hljs-comment">/*组合多个CompletableFuture为一个CompletableFuture,所有子任务全部完成，组合后的任务才会完成。带返回值，可直接get.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; sequence(List&lt;CompletableFuture&lt;T&gt;&gt; futuresList) &#123;        log.info(<span class="hljs-string">&quot;CompletableFuture sequence start &quot;</span>);        <span class="hljs-comment">//1.构造一个空CompletableFuture，子任务数为入参任务list size</span>        <span class="hljs-comment">//2.流式（总任务完成后，每个子任务join取结果，后转换为list）</span>        <span class="hljs-keyword">return</span> CompletableFuture.allOf(futuresList.toArray(<span class="hljs-keyword">new</span> CompletableFuture&lt;?&gt;[<span class="hljs-number">0</span>]))                .thenApply(v -&gt; futuresList.stream()                        .map(CompletableFuture::join)                        .collect(toList())                );    &#125;    <span class="hljs-comment">//任何一个任务 异常</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; sequenceExceptionallyCompleteMeetFirstfFailure(List&lt;CompletableFuture&lt;T&gt;&gt; futuresList) &#123;        log.info(<span class="hljs-string">&quot;CompletableFuture sequenceExceptionallyCompleteMeetFirstfFailure start &quot;</span>);        CompletableFuture&lt;List&lt;T&gt;&gt; result = CompletableFuture.allOf(futuresList.toArray(<span class="hljs-keyword">new</span> CompletableFuture&lt;?&gt;[<span class="hljs-number">0</span>]))                .thenApply(v -&gt; futuresList.stream()                        .map(CompletableFuture::join)                        .collect(toList())                );        futuresList.forEach(f -&gt; f.whenComplete((t, ex) -&gt; &#123;            <span class="hljs-keyword">if</span> (ex != <span class="hljs-keyword">null</span>) &#123;                log.error(<span class="hljs-string">&quot;CompletableFuture  exception &quot;</span> + ex.getMessage(), ex);                result.completeExceptionally(ex);            &#125;        &#125;));        log.info(<span class="hljs-string">&quot;CompletableFuture sequenceExceptionallyCompleteMeetFirstfFailure end &quot;</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMq</title>
    <link href="/2020/04/10/2020-04-10-RocketMq/"/>
    <url>/2020/04/10/2020-04-10-RocketMq/</url>
    
    <content type="html"><![CDATA[<h2 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a>RocketMq</h2><h5 id="2-1-1-消息丢失的问题"><a href="#2-1-1-消息丢失的问题" class="headerlink" title="2.1.1 消息丢失的问题"></a>2.1.1 消息丢失的问题</h5><p>当你系统需要保证百分百消息不丢失，你可以使用生产者每发送一个消息，Broker 同步返回一个消息发送成功的反馈消息<br>即每发送一个消息，同步落盘后才返回生产者消息发送成功，这样只要生产者得到了消息发送生成的返回，事后除了硬盘损坏，都可以保证不会消息丢失<br>但是这同时引入了一个问题，同步落盘怎么才能快？</p><h5 id="2-1-2-同步落盘怎么才能快"><a href="#2-1-2-同步落盘怎么才能快" class="headerlink" title="2.1.2 同步落盘怎么才能快"></a>2.1.2 同步落盘怎么才能快</h5><p>使用 FileChannel + DirectBuffer 池，使用堆外内存，加快内存拷贝<br>使用数据和索引分离，当消息需要写入时，使用 commitlog 文件顺序写，当需要定位某个消息时，查询index 文件来定位，从而减少文件IO随机读写的性能损耗</p><h5 id="2-1-3-消息堆积的问题"><a href="#2-1-3-消息堆积的问题" class="headerlink" title="2.1.3 消息堆积的问题"></a>2.1.3 消息堆积的问题</h5><p>后台定时任务每隔72小时，删除旧的没有使用过的消息信息<br>根据不同的业务实现不同的丢弃任务，具体参考线程池的 AbortPolicy，例如FIFO/LRU等（RocketMQ没有此策略）<br>消息定时转移，或者对某些重要的 TAG 型（支付型）消息真正落库</p><h5 id="2-1-4-定时消息的实现"><a href="#2-1-4-定时消息的实现" class="headerlink" title="2.1.4 定时消息的实现"></a>2.1.4 定时消息的实现</h5><p>实际 RocketMQ 没有实现任意精度的定时消息，它只支持某些特定的时间精度的定时消息<br>实现定时消息的原理是：创建特定时间精度的 MessageQueue，例如生产者需要定时1s之后被消费者消费，你只需要将此消息发送到特定的 Topic，例如：MessageQueue-1 表示这个 MessageQueue 里面的消息都会延迟一秒被消费，然后 Broker 会在 1s 后发送到消费者消费此消息，使用 newSingleThreadScheduledExecutor 实现</p><h5 id="2-1-5-顺序消息的实现"><a href="#2-1-5-顺序消息的实现" class="headerlink" title="2.1.5 顺序消息的实现"></a>2.1.5 顺序消息的实现</h5><p>与定时消息同原理，生产者生产消息时指定特定的 MessageQueue ，消费者消费消息时，消费特定的 MessageQueue，其实单机版的消息中心在一个 MessageQueue 就天然支持了顺序消息<br>注意：同一个 MessageQueue 保证里面的消息是顺序消费的前提是：消费者是串行的消费该 MessageQueue，因为就算 MessageQueue 是顺序的，但是当并行消费时，还是会有顺序问题，但是串行消费也同时引入了两个问题：<br>引入锁来实现串行<br>前一个消费阻塞时后面都会被阻塞</p><h5 id="2-1-6-分布式消息的实现"><a href="#2-1-6-分布式消息的实现" class="headerlink" title="2.1.6 分布式消息的实现"></a>2.1.6 分布式消息的实现</h5><p>需要前置知识：2PC<br>RocketMQ4.3 起支持，原理为2PC，即两阶段提交，prepared-&gt;commit/rollback<br>生产者发送事务消息，假设该事务消息 Topic 为 Topic1-Trans，Broker 得到后首先更改该消息的 Topic 为 Topic1-Prepared，该 Topic1-Prepared 对消费者不可见。然后定时回调生产者的本地事务A执行状态，根据本地事务A执行状态，来是否将该消息修改为 Topic1-Commit 或 Topic1-Rollback，消费者就可以正常找到该事务消息或者不执行等<br>注意，就算是事务消息最后回滚了也不会物理删除，只会逻辑删除该消息</p><h5 id="2-1-7-消息的-push-实现"><a href="#2-1-7-消息的-push-实现" class="headerlink" title="2.1.7 消息的 push 实现"></a>2.1.7 消息的 push 实现</h5><p>注意，RocketMQ 已经说了自己会有低延迟问题，其中就包括这个消息的 push 延迟问题<br>因为这并不是真正的将消息主动的推送到消费者，而是 Broker 定时任务每5s将消息推送到消费者</p><h5 id="2-1-8-消息重复发送的避免"><a href="#2-1-8-消息重复发送的避免" class="headerlink" title="2.1.8 消息重复发送的避免"></a>2.1.8 消息重复发送的避免</h5><p>RocketMQ 会出现消息重复发送的问题，因为在网络延迟的情况下，这种问题不可避免的发生，如果非要实现消息不可重复发送，那基本太难，因为网络环境无法预知，还会使程序复杂度加大，因此默认允许消息重复发送<br>RocketMQ 让使用者在消费者端去解决该问题，即需要消费者端在消费消息时支持幂等性的去消费消息<br>最简单的解决方案是每条消费记录有个消费状态字段，根据这个消费状态字段来是否消费或者使用一个集中式的表，来存储所有消息的消费状态，从而避免重复消费<br>具体实现可以查询关于消息幂等消费的解决方案</p><h5 id="2-1-9-广播消费与集群消费"><a href="#2-1-9-广播消费与集群消费" class="headerlink" title="2.1.9 广播消费与集群消费"></a>2.1.9 广播消费与集群消费</h5><p>消息消费区别：广播消费，订阅该 Topic 的消息者们都会消费每个消息。集群消费，订阅该 Topic 的消息者们只会有一个去消费某个消息<br>消息落盘区别：具体表现在消息消费进度的保存上。广播消费，由于每个消费者都独立的去消费每个消息，因此每个消费者各自保存自己的消息消费进度。而集群消费下，订阅了某个 Topic，而旗下又有多个 MessageQueue，每个消费者都可能会去消费不同的 MessageQueue，因此总体的消费进度保存在 Broker 上集中的管理</p><h5 id="2-1-10-RocketMQ-不使用-ZooKeeper-作为注册中心的原因，以及自制的-NameServer-优缺点？"><a href="#2-1-10-RocketMQ-不使用-ZooKeeper-作为注册中心的原因，以及自制的-NameServer-优缺点？" class="headerlink" title="2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？"></a>2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？</h5><p>ZooKeeper 作为支持顺序一致性的中间件，在某些情况下，它为了满足一致性，会丢失一定时间内的可用性，RocketMQ 需要注册中心只是为了发现组件地址，在某些情况下，RocketMQ 的注册中心可以出现数据不一致性，这同时也是 NameServer 的缺点，因为 NameServer 集群间互不通信，它们之间的注册信息可能会不一致<br>另外，当有新的服务器加入时，NameServer 并不会立马通知到 Producer，而是由 Producer 定时去请求 NameServer 获取最新的 Broker/Consumer 信息（这种情况是通过 Producer 发送消息时，负载均衡解决）    </p><h5 id="分布式事务解决方案知道哪些，说一下区别以及原理？"><a href="#分布式事务解决方案知道哪些，说一下区别以及原理？" class="headerlink" title="分布式事务解决方案知道哪些，说一下区别以及原理？"></a>分布式事务解决方案知道哪些，说一下区别以及原理？</h5><p>发送方向 MQ 服务端发送消息。<br>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。<br>发送方开始执行本地事务逻辑。<br>发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。<br>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后 MQ Server 将对该消息发起消息回查。<br>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。<br>发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2020/04/09/2020-04-09-Mybatis/"/>
    <url>/2020/04/09/2020-04-09-Mybatis/</url>
    
    <content type="html"><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h5 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、#{}和${}的区别是什么？"></a>1、#{}和${}的区别是什么？</h5><p>1.${}是 变量占位符，属于字符串替换<br>2.#{}是 sql 的参数占位符, Mybatis 会将 sql 中的#{}替换为?号  </p><h5 id="2、Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#2、Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="2、Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>2、Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h5><p>Mapper接口，接口的全限名，就是映射文件中的 namespace 的值，<br>接口的方法名，就是映射文件中MappedStatement的 id 值，<br>接口方法内的参数，就是传递给 sql 的参数。<br>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement<br>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。<br>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，<br>代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。  </p><h5 id="3-Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#3-Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="3. Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>3. Mybatis 是如何进行分页的？分页插件的原理是什么？</h5><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，<br>PageHelper 插件的拦截方法内拦截待执行的 sql，然后重写 sql，添加对应的物理分页语句和物理分页参数</p><h5 id="4-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#4-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="4. 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>4. 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h5><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。<br>Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2020/04/08/2020-04-08-Redis/"/>
    <url>/2020/04/08/2020-04-08-Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h5 id="1、为什么要用-redis-为什么要用缓存"><a href="#1、为什么要用-redis-为什么要用缓存" class="headerlink" title="1、为什么要用 redis/为什么要用缓存"></a>1、为什么要用 redis/为什么要用缓存</h5><p>高性能：操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！<br>高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去。  </p><h5 id="2、为什么要用-redis-而不用-map-guava-做缓存"><a href="#2、为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="2、为什么要用 redis 而不用 map/guava 做缓存?"></a>2、为什么要用 redis 而不用 map/guava 做缓存?</h5><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。<br>缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。  </p><h5 id="3、redis-的线程模型"><a href="#3、redis-的线程模型" class="headerlink" title="3、redis 的线程模型"></a>3、redis 的线程模型</h5><p>redis叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket<br>文件事件处理器的结构包含 4 个部分： </p><ul><li>多个 socket  </li><li>IO 多路复用程序  </li><li>文件事件分派器  </li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）     </li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，<br>会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。      </p><h5 id="4、redis-和-memcached-的区别"><a href="#4、redis-和-memcached-的区别" class="headerlink" title="4、redis 和 memcached 的区别"></a>4、redis 和 memcached 的区别</h5><ol><li>redis支持更丰富的数据类型：Redis支持String,List,Set,Hash,ZSet(Sorted Set)等数据结构的存储。memcache支持String(二进制类型新增)数据类型，。     </li><li>Redis支持数据的持久化(RDB+AOF)，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。     </li><li>集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.     </li><li>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。         </li></ol><h5 id="5、redis-设置过期时间"><a href="#5、redis-设置过期时间" class="headerlink" title="5、redis 设置过期时间"></a>5、redis 设置过期时间</h5><p>定期删除+惰性删除。     </p><ul><li>定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。     </li><li>惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。<br>假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。        </li></ul><h5 id="6、什么是缓存雪崩？"><a href="#6、什么是缓存雪崩？" class="headerlink" title="6、什么是缓存雪崩？"></a>6、什么是缓存雪崩？</h5><p>雪崩就是在大量redis突然失效的时候，请求在缓存无法获取进而去访问数据库，数据库压力过大导致服务器宕机的行为<br>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。     </p><ul><li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。     </li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉     </li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存     </li><li>设置不同的过期时间，防止同一时间内大量的key失效。</li></ul><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，<br>持续的大并发就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。<br>缓存击穿这里强调的是并发，造成缓存击穿的原因有以下两个：<br>该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）<br>添加到了缓存，redis有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）<br>对于缓存击穿的解决方案就是加锁</p><h5 id="7、缓存穿透"><a href="#7、缓存穿透" class="headerlink" title="7、缓存穿透"></a>7、缓存穿透</h5><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。<br>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。这时的用户很可能是攻击者，攻击会导致数据库压力过大<br>1）缓存无效 key : 如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间<br>2）布隆过滤器     代码维护复杂，效果很好<br>布隆过滤器是一种基于概率的数据结构，主要用来判断某个元素是否在集合内，它具有运行速度快（时间效率），占用内存小的优点（空间效率），<br>但是有一定的误识别率和删除困难的问题。它只能告诉你某个元素一定不在集合内或可能在集合内。<br>在布隆过滤器中引用了一个误判率的概念，即它可能会把不属于这个集合的元素认为可能属于这个集合，<br>但是不会把属于这个集合的认为不属于这个集合，布隆过滤器的特点如下：<br>一个非常大的二进制位数组 （数组里只有0和1）<br>若干个哈希函数<br>空间效率和查询效率高<br>不存在漏报（False Negative）：某个元素在某个集合中，肯定能报出来。<br>可能存在误报（False Positive）：某个元素不在某个集合中，可能也被爆出来。<br>不提供删除方法，代码维护困难。<br>位数组初始化都为0，它不存元素的具体值，当元素经过哈希函数哈希后的值（也就是数组下标）对应的数组位置值改为1。</p><h5 id="8、Redis原理"><a href="#8、Redis原理" class="headerlink" title="8、Redis原理"></a>8、Redis原理</h5><p>Redis是基于内存操作数据，key-value数据结构，worker Thread(工作线程)是单线程，Redis 6.x版本 I/O threads<br>IO多路复用器select/poll/ePoll监听客户端是否有消息到达,通知redis实例去读取操作消息<br>I/O能不能读取:多路复用器<br>I/O:程序自己得去读取</p><h5 id="9、Redis多路复用器ePoll解决了什么问题"><a href="#9、Redis多路复用器ePoll解决了什么问题" class="headerlink" title="9、Redis多路复用器ePoll解决了什么问题"></a>9、Redis多路复用器ePoll解决了什么问题</h5><p>1、IO多路复用器更有效率地获知哪些IO信息可以进行读写,不用进行全量的遍历<br>2、Redis单线程worker自己同步读取<br>3、Redis读取完进行计算<br>Redis单线程worker串行化处理，原子性，快</p><p>Redis 6.x版本 I/O threads,计算交给worker线程，读取和写出交给I/O threads线程操作<br><img src="https://alwaysfaith.github.io/img/redis/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200508143507.jpg"></p><h5 id="10、Redis五大Value类型使用场景"><a href="#10、Redis五大Value类型使用场景" class="headerlink" title="10、Redis五大Value类型使用场景"></a>10、Redis五大Value类型使用场景</h5><ul><li>String  字符串            append追加</li><li>String  数值增减          decr/incr加减   点赞、统计、限流</li><li>String  bitmap二进制位除   二进制     统计:任意用户,任意时间窗口内,登录天数  <pre><code>                               2E用戶,礼品？活跃用户？任意时间窗口，反复计算                               （数据分析 常驻内存 bitmap 临时导入redis 统计 报表）</code></pre></li><li>List 有序、存入顺序                              </li><li>List 同向：栈                                   </li><li>List 异向：队列                                    </li><li>List 数组</li><li>List ltrim 评论列表 缓冲数据 数据迁出，redis无状态</li><li>Hash  HashMap 场景: 详情页–聚合数据  统计值:粉丝、点赞…</li><li>Set  集合、去重、无序  多实例akf拆分 底层数据结构hashtable</li><li>ZSet  场景: 分页、排行榜  如何实现排序的？ 底层数据结构:zipList,元素个数超过128或value字节超过64切换成skipList(跳表:空间效率和红黑树儿二叉树,属于空间换时间)<br><img src="https://alwaysfaith.github.io/img/redis/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200509170015.jpg"></li></ul><p>二进制安全:客户端将数据变成字节(byte[])数组交予redis(redis/hbase/kafka )存储,不管客户端的数据类型</p><h5 id="11、如何实现redis高可用的"><a href="#11、如何实现redis高可用的" class="headerlink" title="11、如何实现redis高可用的"></a>11、如何实现redis高可用的</h5><p>可以使用哨兵模式和Cluster集群来实现高可用,中小型使用哨兵，大型用集群模式<br>redis的哨兵模式: 当我们的主机master宕机之后，我们的slave会等待我们的master上线，再次期间不会进行任何操作，<br>这个时候我们可以手动的进行主机切换，将我们其中的一台从机slaver装换成我们的主机master，当原来的master恢复重新上线的时候，会自动沦为从机slave<br>可是我们无法知道redis什么时候宕机，所以我们需要他们自动的监控和进行主从切换，而哨兵提供了这些功能，监控，通知和自动的故障转移，最常见的哨兵模型就是一主二从三哨兵</p><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，<br>以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</p><p>Redis-Cluster集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现：<br>一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个。<br>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p><ul><li>节点 A 负责处理 0 号至 5500 号哈希槽。</li><li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li><li>节点 C 负责处理 11001 号至 16384 号哈希槽。</li></ul><p>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。<br>增加一个D节点的结果可能如下：</p><ul><li>节点A覆盖1365-5460</li><li>节点B覆盖6827-10922</li><li>节点C覆盖12288-16383</li><li>节点D覆盖0-1364,5461-6826,10923-1228</li></ul><p>主从复制模型<br>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能：<br>集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。<br>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000号的哈希槽。<br>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点，<br>并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。<br>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p><p>Redis一致性保证<br>Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：<br>第一个原因是因为集群是用了异步复制. 写操作过程:</p><p>客户端向主节点B写入一条命令.<br>主节点B向客户端回复命令状态.<br>主节点将写操作复制给他得从节点 B1, B2 和 B3<br>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低<br>我们必须在性能和一致性之间做出权衡。<br>注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。<br>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点，<br>其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点，<br>还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .<br>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.<br>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout），<br>是 Redis 集群的一个重要的配置选项</p><h5 id="12、redis的持久化"><a href="#12、redis的持久化" class="headerlink" title="12、redis的持久化"></a>12、redis的持久化</h5><p>rdb(Redis DataBase)是redis默认的持久化方式，在指定的时间间隔内将内存中的数据集快照（Snapshot）写入磁盘的二进制文件，所产生的也就是dump.rdb文件，<br>它恢复时是将快照文件直接读到内存里。基于时间窗口，全量数据，加载快，rdb文件，丢失一大部分数据,开机恢复数据快,写入持久化文件快<br>RDB持久化的时候会单独fork一个与当前进程一摸一样的子进程来进行持久化<br>在RDB机制中触发内存中的数据进行持久化</p><ol><li>save命令 (save命令不会fork子进程，通过阻塞当前Redis服务器，直到RDB完成为止，所以该命令在生产中一般不会使用)</li><li>bgsave命令 (bgsave命令会在后台fork一个与Redis主线程一模一样的子线程，由子线程负责内存中的数据持久化。)</li><li>自动化 (save 300 10则表示300秒内如果至少有10个key值发生变化，则进行持久化，save 60 10000以此类推)</li></ol><p>通过以上的分析可以得出以下save和bgsave的对比区别:</p><ol><li>save是同步持久化数据，而bgsave是异步持久化数据。</li><li>save不会fork子进程，通过主进程持久化数据，会阻塞处理客户端的请求，而bdsave会fork子进程持久化数据，同时还可以处理客户端请求，高效。</li><li>save不会消耗内存，而bgsave会消耗内存。<br>RDB的优缺点:<br>缺点： RDB持久化后的文件是紧凑的二进制文件，适合于备份、全量复制、大规模数据恢复的场景，对数据完整性和一致性要求不高，RDB会丢失最后一次快照的数据。<br>优点： 开机的恢复数据快，写入持久化文件快</li></ol><p>aof(Append Only File)是以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，<br>redis启动之初会读取该文件重新构建数据基于实时完整的每一个操作，追加到日志文件 缺点:1.加载慢 2.有冗余<br>AOF持久化机制是以日志的形式记录Redis中的每一次的增删改操作，不会记录查询操作，以文本的形式记录，打开记录的日志文件就可以查看操作记录。<br>AOF是默认不开启的，若是想开启AOF，只需要把appendonly no修改为appendonly yes即可开启<br>AOF触发机制:</p><ol><li>no：表示等操作系统等数据缓存同步到磁盘中（快、持久化没保证）。</li><li>always：同步持久化，每次发生数据变更时，就会立即记录到磁盘中（慢，安全）。</li><li>everysec：表示每秒同步一次（默认值，很快，但是会丢失一秒内的数据）。<br>AOF中每秒同步也是异步完成的，效率是非常高的，由于该机制对日志文件的写入操作是采用append的形式。</li></ol><p>所谓的无效的的操作，举个例子，比如某一时刻对一个k++，然后后面的某一时刻k–，这样k的值是保持不变的，那么这两次的操作就是无效的。<br>如果像这样的无效操作很多，记录的文件臃肿，就浪费了资源空间，所以在Redis中出现了rewrite机制。<br>redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。<br>重写操作也会fork一个子进程来处理重写操作，重写以内存中的数据作为重写的源，避免了操作的冗余性，保证了数据的最新。</p><p>AOF的优缺点<br>优点： AOF更好保证数据不会被丢失，最多只丢失一秒内的数据，通过fork一个子进程处理持久化操作，保证了主进程不会进程io操作，能高效的处理客户端的请求。<br>另外重写操作保证了数据的有效性，即使日志文件过大也会进行重写。<br>AOF的日志文件的记录可读性非常的高，即使某一时刻有人执行flushall清空了所有数据，只需要拿到aof的日志文件，然后把最后一条的flushall给删除掉，就可以恢复数据。<br>缺点：  对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。AOF在运行效率上往往会慢于RDB。</p><p>混合持久化:<br>混合持久化也是通过bgrewriteaof来完成的，不同的是当开启混合持久化时，fork出的子进程先将共享内存的数据以RDB方式写入aof文件中，<br>然后再将重写缓冲区的增量命令以AOF方式写入文件中。<br>写入完成后通知主进程统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。<br>简单的说：新的AOF文件前半段是以RDB格式的全量数据后半段是AOF格式的增量数据。<br>优点： 混合持久化结合RDB持久化和AOF持久化的优点，由于绝大部分的格式是RDB格式，加载速度快，增量数据以AOF方式保存，数据更少的丢失。</p><h5 id="13、如何实现分布式锁"><a href="#13、如何实现分布式锁" class="headerlink" title="13、如何实现分布式锁"></a>13、如何实现分布式锁</h5><p>单机模式下可以使用set nx px去设置锁<br>保证锁的原子性和失效时间 在集群模式下使用Redlock去实现分布式锁，redisson对Redlock算法进行了封装<br>基于zookeeper实现分布式锁</p><h5 id="14、redis单线程的还怎么快"><a href="#14、redis单线程的还怎么快" class="headerlink" title="14、redis单线程的还怎么快"></a>14、redis单线程的还怎么快</h5><p>采用了多路IO复用，多路指的是多个连接，复用是使用同一个线程 基于内存，而内存的读写速度非常快 单线程减少了上下文切换线程的时间</p><h5 id="15、redis-的String的容量是多大"><a href="#15、redis-的String的容量是多大" class="headerlink" title="15、redis 的String的容量是多大"></a>15、redis 的String的容量是多大</h5><p>512M</p><h5 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h5><p>Redis是使用定期删除+惰性删除两者配合的过期策略<br>定期删除: 定期删除指的是Redis默认每隔100ms就随机抽取一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉<br>惰性删除:惰性删除不再是Redis去主动删除，而是在客户端要获取某个key的时候，Redis会先去检测一下这个key是否已经过期，如果没有过期则返回给客户端，<br>如果已经过期了，那么Redis会删除这个key，不会返回给客户端。</p><h5 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h5><p>Redis在使用内存达到某个阈值（通过maxmemory配置)的时候，就会触发内存淘汰机制，选取一些key来删除。内存淘汰有许多策略<br>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。默认策略<br>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key<br>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key<br>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key<br>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key<br>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<br>比较推荐的是两种lru策略。根据自己的业务需求。如果你使用Redis只是作为缓存，不作为DB持久化，那推荐选择allkeys-lru<br>如果你使用Redis同时用于缓存和数据持久化，那推荐选择volatile-lru</p><h5 id="redis为什么使用单线程？"><a href="#redis为什么使用单线程？" class="headerlink" title="redis为什么使用单线程？"></a>redis为什么使用单线程？</h5><p>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。<br>（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql</title>
    <link href="/2020/04/07/2020-04-07-Mysql/"/>
    <url>/2020/04/07/2020-04-07-Mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h5 id="1、MyISAM和InnoDB区别"><a href="#1、MyISAM和InnoDB区别" class="headerlink" title="1、MyISAM和InnoDB区别"></a>1、MyISAM和InnoDB区别</h5><ul><li>是否支持行级锁:MyISAM只有表级锁，InnoDB 支持行级锁和表级锁,默认为行级锁。  </li><li>是否支持事务和崩溃后的安全恢复:MyISAM强调的是性能，不提供事务支持。InnoDB提供事务支持事务，外部键等高级数据库功能。   </li></ul><p>具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。  </p><ul><li>是否支持外键： MyISAM不支持，而InnoDB支持。  </li><li>是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;</li></ul><p>MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;</p><h5 id="2、索引的数据结构"><a href="#2、索引的数据结构" class="headerlink" title="2、索引的数据结构"></a>2、索引的数据结构</h5><p>主流B+Tree、Hash结构以及BitMap等，其中mysql数据库不支持BitMap索引,<br>同时基于InnoDB以及MyISAM引擎的mysql不显示支持Hash<br>Hash索引的缺点:仅仅能满足”=”和”in”,不能使用范围查询<br>无法用来数据的排序操作<br>遇到Hash冲突的时候效率不高   </p><h5 id="3、什么是事务"><a href="#3、什么是事务" class="headerlink" title="3、什么是事务?"></a>3、什么是事务?</h5><ol><li>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</li></ol><h5 id="4、事务隔离级别有哪些-MySQL的默认隔离级别是"><a href="#4、事务隔离级别有哪些-MySQL的默认隔离级别是" class="headerlink" title="4、事务隔离级别有哪些?MySQL的默认隔离级别是?"></a>4、事务隔离级别有哪些?MySQL的默认隔离级别是?</h5><ul><li>READ-UNCOMMITTED(读未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。  </li><li>READ-COMMITTED(读已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生   。</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。   </li><li>SERIALIZABLE(串行化)： 最高的隔离级别，完全服从ACID的隔离级别。</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）  </p><h5 id="5、-为什么要使用索引？"><a href="#5、-为什么要使用索引？" class="headerlink" title="5、 为什么要使用索引？"></a>5、 为什么要使用索引？</h5><ol><li>创建唯一性索引，可以保证数据库表中每一行数据的唯一性。   </li><li>加快数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。    </li><li>帮助服务器避免排序和临时表。   </li><li>将随机IO变为顺序IO   </li><li>可以加速表和表之间的连接。     </li></ol><h5 id="6、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#6、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="6、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>6、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h5><ol><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护。  </li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。   </li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。    </li></ol><h5 id="7、-transactional注解在什么情况下会失效，为什么？"><a href="#7、-transactional注解在什么情况下会失效，为什么？" class="headerlink" title="7、@transactional注解在什么情况下会失效，为什么？"></a>7、@transactional注解在什么情况下会失效，为什么？</h5><p>检查方法是不是public<br>异常类型是不是unchecked异常<br>数据库引擎是否支持事务<br>Spring是否扫描到你事务的这个包的注解了<br>是不是同一个类中调用的方法<br>异常是不是被catch住了      </p><h5 id="8、简单说一说drop、delete与truncate的区别"><a href="#8、简单说一说drop、delete与truncate的区别" class="headerlink" title="8、简单说一说drop、delete与truncate的区别"></a>8、简单说一说drop、delete与truncate的区别</h5><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别<br>1、delete和truncate只删除表的数据不删除表的结构<br>2、速度,一般来说: drop&gt; truncate &gt;delete<br>3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p><h5 id="9、你所用过的DDL语句"><a href="#9、你所用过的DDL语句" class="headerlink" title="9、你所用过的DDL语句"></a>9、你所用过的DDL语句</h5><p>alter table <code>us_zara_origin_detail</code> add index index_order_id ( <code>order_id</code> );<br>alter table <code>us_receive_address</code> add column org_number_path varchar(512) null comment ‘组织路径编号’;<br>alter table <code>us_zara_origin_detail</code> drop index index_order_id;</p><h5 id="10-什么情况下索引失效"><a href="#10-什么情况下索引失效" class="headerlink" title="10. 什么情况下索引失效"></a>10. 什么情况下索引失效</h5><p>1.查询条件包含or（当or左右查询字段只有一个是索引，该索引失效。只有当or左右查询字段均为索引时，才会生效；）<br>2.组合索引，不是使用第一列索引，索引失效。最佳左前缀法则（带头索引不能死，中间索引不能断）<br>如果select * from key1=1 and key2= 2;建立组合索引（key1，key2）;<br>select * from key1 = 1;组合索引有效；<br>select * from key1 = 1 and key2= 2;组合索引有效；<br>select * from key2 = 2;组合索引失效；不符合最左前缀原则<br>3.索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描<br>4.索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描<br>5.当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效<br>6、索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描<br>7、不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描<br>8、mysql存储引擎不能继续使用索引中范围条件（between、&lt;、&gt;、in等）右边的列<br>9、索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描<br>10、索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描<br>11、查询的数量是大表的大部分，应该是30％以上<br>12、between and 时间查询跨度大导致索引失效</p><h5 id="11-mysql的union和unionall区别"><a href="#11-mysql的union和unionall区别" class="headerlink" title="11. mysql的union和unionall区别"></a>11. mysql的union和unionall区别</h5><p>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；<br>Union All：对两个结果集进行并集操作，包括重复行，不进行排序</p><h4 id="原子性是基于日志的Redo-Undo机制，你能说一说Redo-Undo机制吗？"><a href="#原子性是基于日志的Redo-Undo机制，你能说一说Redo-Undo机制吗？" class="headerlink" title="原子性是基于日志的Redo/Undo机制，你能说一说Redo/Undo机制吗？"></a>原子性是基于日志的Redo/Undo机制，你能说一说Redo/Undo机制吗？</h4><p>Redo/Undo机制比较简单，它们将所有对数据的更新操作都写到日志中<br>Redo log用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据；Undo log是用来记录数据更新前的值，保证数据更新失败能够回滚。<br>假如某个时刻数据库崩溃，在崩溃之前有事务A和事务B在执行，事务A已经提交，而事务B还未提交。<br>当数据库重启进行crash-recovery时，就会通过Redo log将已经提交事务的更改写到数据文件，而还没有提交的就通过Undo log进行roll back</p><p>设置隔离级别的语句中set global transaction isolation level read uncommitted，<br>这里的global也可以换成session，global表示全局的，而session表示当前会话，也就是当前窗口有效。</p><p>Mysq的锁说起，在Mysql中的锁可以分为分享锁/读锁（Shared Locks）、排他锁/写锁（Exclusive Locks） 、间隙锁、行锁（Record Locks）、表锁<br>在四个隔离级别中加锁肯定是要消耗性能的，而读未提交是没有加任何锁的，所以对于它来说也就是没有隔离的效果，所以它的性能也是最好的<br>对于串行化加的是一把大锁，读的时候加共享锁，不能写，写的时候，加的是排它锁，阻塞其它事务的写入和读取，<br>若是其它的事务长时间不能写入就会直接报超时，所以它的性能也是最差的，对于它来就没有什么并发性可言<br> 对于读提交和可重复读，他们俩的实现是兼顾解决数据问题，然后又要有一定的并发行，所以在实现上锁机制会比串行化优化很多，提高并发性，所以性能也会比较好</p><p>数据库的增删改操作默认都会加排他锁，而查询不会加任何锁。</p><p>共享锁：对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后。语法为：<br>select * from table lock in share mode</p><p>排他锁：对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。语法为：<br>select * from table for update</p><p>行锁和表锁，是从锁的粒度上进行划分的，行锁锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，<br>行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务<br>表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低</p><p>间隙锁则分为两种：Gap Locks和Next-Key Locks。Gap Locks会锁住两个索引之间的区间，<br>比如select * from User where id&gt;3 and id&lt;5 for update，就会在区间（3，5）之间加上Gap Locks<br>Next-Key Locks是Gap Locks+Record Locks形成闭区间锁select * from User where id&gt;=3 and id=&lt;5 for update，就会在区间[3,5]之间加上Next-Key Locks。</p><p>假如事务1和事务2都要执行update操作，<br>事务1先update数据行的时候，先回获取行锁，锁定数据，<br>当事务2要进行update操作的时候，也会取获取该数据行的行锁，<br>但是已经被事务1占有，事务2只能wait<br>若是事务1长时间没有释放锁，事务2就会出现超时异常<br>这个是在update的where后的条件是在有索引的情况下</p><h4 id="Mysql中什么时候会加锁呢"><a href="#Mysql中什么时候会加锁呢" class="headerlink" title="Mysql中什么时候会加锁呢"></a>Mysql中什么时候会加锁呢</h4><p>在数据库的增、删、改、查中，只有增、删、改才会加上排它锁，而只是查询并不会加锁，<br>只能通过在select语句后显式加lock in share mode或者for update来加共享锁或者排它锁。</p><h4 id="那没有索引的条件下呢？没办法快速定位到数据行呢？"><a href="#那没有索引的条件下呢？没办法快速定位到数据行呢？" class="headerlink" title="那没有索引的条件下呢？没办法快速定位到数据行呢？"></a>那没有索引的条件下呢？没办法快速定位到数据行呢？</h4><p>若是没有索引的条件下，就获取所有行，都加上行锁，然后Mysql会再次过滤符合条件的的行并释放锁，只有符合条件的行才会继续持有锁。</p><h4 id="datetime和-timestamp"><a href="#datetime和-timestamp" class="headerlink" title="datetime和 timestamp"></a>datetime和 timestamp</h4><p>datetime：保存格式为YYYYMMDDHHMMSS（年月日时分秒）的整数，它与时区无关，存入的是什么值就是什么值，不会根据当前时区进行转换。<br>存储范围: 1000-01-01 00:00:00 到’9999-12-31 23:59:59’ 长度，8个字节<br>timestamp：长度，4个字节<br>存储范围：’1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07 会随时区改变</p><h4 id="Mysql-in和exists"><a href="#Mysql-in和exists" class="headerlink" title="Mysql in和exists"></a>Mysql in和exists</h4><p>IN 使用于大表驱动小表,exists适用于小表驱动大表的情况</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2020/04/06/2020-04-06-Spring/"/>
    <url>/2020/04/06/2020-04-06-Spring/</url>
    
    <content type="html"><![CDATA[<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><h5 id="1-什么是-Spring-框架"><a href="#1-什么是-Spring-框架" class="headerlink" title="1. 什么是 Spring 框架?"></a>1. 什么是 Spring 框架?</h5><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。   </p><ul><li>核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。   </li><li>测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。   </li><li>数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。   </li><li>Web支持 : Spring MVC和Spring WebFlux Web框架。   </li><li>集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。   </li><li>语言 ：Kotlin，Groovy，动态语言。         </li></ul><h5 id="2-列举一些重要的Spring模块？"><a href="#2-列举一些重要的Spring模块？" class="headerlink" title="2. 列举一些重要的Spring模块？"></a>2. 列举一些重要的Spring模块？</h5><ul><li>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li><li>Spring Aspects ： 该模块为与AspectJ的集成提供支持。</li><li>Spring AOP ：提供了面向切面的编程实现。</li><li>Spring JDBC : Java数据库连接。</li><li>Spring JMS ：Java消息服务。</li><li>Spring ORM : 用于支持Hibernate等ORM工具。</li><li>Spring Web : 为创建Web应用程序提供支持。</li><li>Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。      </li></ul><h5 id="3-谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#3-谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="3.谈谈自己对于 Spring IoC 和 AOP 的理解"></a>3.谈谈自己对于 Spring IoC 和 AOP 的理解</h5><p>IoC（控制反转）是一种设计思想，将程序中手动创建对象的控制权，交由Spring框架来管理。<br>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。<br>AOP(面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，<br>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。<br>Spring AOP就是基于动态代理的      </p><h5 id="5-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#5-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="5. Spring AOP 和 AspectJ AOP 有什么区别？"></a>5. Spring AOP 和 AspectJ AOP 有什么区别？</h5><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。<br>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作。<br>AspectJ 相比于 Spring AOP 功能更加强大。      </p><h5 id="6-Spring-中的-bean-的作用域有哪些"><a href="#6-Spring-中的-bean-的作用域有哪些" class="headerlink" title="6. Spring 中的 bean 的作用域有哪些?"></a>6. Spring 中的 bean 的作用域有哪些?</h5><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session: 全局session作用域,在基于portlet的web应用中才有意义,Spring5已经没有了。      </li></ul><h5 id="7-Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#7-Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="7. Spring 中的单例 bean 的线程安全问题了解吗？"></a>7. Spring 中的单例 bean 的线程安全问题了解吗？</h5><p>不，Spring框架中的单例bean不是线程安全的。<br>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。<br>常见的有两种解决办法：<br>在Bean对象中尽量避免定义可变的成员变量（不太现实）。<br>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal    </p><h5 id="8-将一个类声明为Spring的-bean-的注解有哪些"><a href="#8-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="8. 将一个类声明为Spring的 bean 的注解有哪些?"></a>8. 将一个类声明为Spring的 bean 的注解有哪些?</h5><ul><li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。</li><li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。     </li></ul><h5 id="9-Spring-中的-bean-生命周期"><a href="#9-Spring-中的-bean-生命周期" class="headerlink" title="9. Spring 中的 bean 生命周期?"></a>9. Spring 中的 bean 生命周期?</h5><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用 set()方法设置一些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</li><li>与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法</li><li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。    </li></ul><h5 id="10-SpringMVC-工作原理了解吗"><a href="#10-SpringMVC-工作原理了解吗" class="headerlink" title="10. SpringMVC 工作原理了解吗?"></a>10. SpringMVC 工作原理了解吗?</h5><ol><li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet。</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。</li><li>解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。</li><li>HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。</li><li>ViewResolver 会根据逻辑 View 查找实际的 View。</li><li>DispatcherServlet 把返回的 Model 传给 View（视图渲染）。</li><li>把 View 返回给请求者（浏览器）    </li></ol><h5 id="11-Spring-框架中用到了哪些设计模式？"><a href="#11-Spring-框架中用到了哪些设计模式？" class="headerlink" title="11. Spring 框架中用到了哪些设计模式？"></a>11. Spring 框架中用到了哪些设计模式？</h5><p>创建型模式，是对对象创建过程的各种问题和解决方案的总结，<br>包括各种工厂模式（Factory、 Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。<br>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。<br>结构型模式包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、<br>代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。<br>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。<br>行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、<br>观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。  </p><ul><li>工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。  </li><li>代理设计模式 : Spring AOP 功能的实现。</li><li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li><li>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li>适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。     </li></ul><h5 id="12-Spring-事务中的隔离级别有哪几种"><a href="#12-Spring-事务中的隔离级别有哪几种" class="headerlink" title="12. Spring 事务中的隔离级别有哪几种?"></a>12. Spring 事务中的隔离级别有哪几种?</h5><p>DEFAULT: 默认数据库隔离级别<br>READ_UNCOMMITTED: 读未提交<br>READ_COMMITTED: 读已提交<br>REPEATABLE_READ: 可重复读<br>SERIALIZABLE: 串行化         </p><h5 id="13-Spring-事务中哪几种事务传播行为"><a href="#13-Spring-事务中哪几种事务传播行为" class="headerlink" title="13. Spring 事务中哪几种事务传播行为?"></a>13. Spring 事务中哪几种事务传播行为?</h5><ol><li>PROPAGATION_REQUIRED<br> 若当前存在事务，则加入该事务，若不存在事务，则新建一个事务。  </li><li>PAOPAGATION_REQUIRE_NEW<br> 若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。  </li><li>PROPAGATION_NESTED<br> 如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务，则新建一个事务，类似于REQUIRE_NEW。  </li><li>PROPAGATION_SUPPORTS<br> 支持当前事务，若当前不存在事务，以非事务的方式执行。  </li><li>PROPAGATION_NOT_SUPPORTED<br> 以非事务的方式执行，若当前存在事务，则把当前事务挂起。  </li><li>PROPAGATION_MANDATORY<br> 强制事务执行，若当前不存在事务，则抛出异常  </li><li>PROPAGATION_NEVER<br> 以非事务的方式执行，如果当前存在事务，则抛出异常。            </li></ol><h5 id="14-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#14-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="14. @Transactional(rollbackFor = Exception.class)注解了解吗？"></a>14. @Transactional(rollbackFor = Exception.class)注解了解吗？</h5><p>Exception分为运行时异常RuntimeException和非运行时异常<br>@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,<br>加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚   </p><h5 id="15-说出使用Spring-Boot的主要优点"><a href="#15-说出使用Spring-Boot的主要优点" class="headerlink" title="15. 说出使用Spring Boot的主要优点"></a>15. 说出使用Spring Boot的主要优点</h5><ol><li>开发基于 Spring 的应用程序很容易。</li><li>Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。</li><li>Spring Boot不需要编写大量样板代码、XML配置和注释。</li><li>Spring引导应用程序可以很容易地与Spring生态系统集成，如Spring JDBC、Spring ORM、Spring Data等。</li><li>Spring Boot遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。</li><li>Spring Boot 应用程序提供嵌入式HTTP服务器，如Tomcat和Jetty，可以轻松地开发和测试web应用程序。</li><li>Spring Boot提供命令行接口(CLI)工具，用于开发和测试Spring Boot应用程序，如Java或Groovy。</li><li>Spring Boot提供了多种插件，可以使用内置工具(如Maven和Gradle)开发和测试Spring Boot应用程序           </li></ol><h5 id="16-介绍一下-SpringBootApplication注解"><a href="#16-介绍一下-SpringBootApplication注解" class="headerlink" title="16. 介绍一下@SpringBootApplication注解"></a>16. 介绍一下@SpringBootApplication注解</h5><p>@SpringBootApplication 看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。<br>根据 SpringBoot官网，这三个注解的作用分别是：</p><ul><li>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制 </li><li>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的bean，注解默认会扫描该类所在的包下所有的类。  </li><li>@Configuration：允许在上下文中注册额外的bean或导入其他配置类       </li></ul><h5 id="17-Bean工厂和-Application-contexts有什么区别？"><a href="#17-Bean工厂和-Application-contexts有什么区别？" class="headerlink" title="17. Bean工厂和 Application contexts有什么区别？"></a>17. Bean工厂和 Application contexts有什么区别？</h5><p>BeanFactory它的核心概念就是bean工厂，用作于bean生命周期的管理<br>Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。<br>另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。<br>Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。            </p><h5 id="18-PostConstruct和-PreDestroy-是两个作用于-Servlet-生命周期的注解，相信从-Servlet-开始学-Java-后台开发的同学对他应该不陌生。"><a href="#18-PostConstruct和-PreDestroy-是两个作用于-Servlet-生命周期的注解，相信从-Servlet-开始学-Java-后台开发的同学对他应该不陌生。" class="headerlink" title="18. @PostConstruct和@PreDestroy 是两个作用于 Servlet 生命周期的注解，相信从 Servlet 开始学 Java 后台开发的同学对他应该不陌生。"></a>18. @PostConstruct和@PreDestroy 是两个作用于 Servlet 生命周期的注解，相信从 Servlet 开始学 Java 后台开发的同学对他应该不陌生。</h5><p>被这两个注解修饰的方法可以保证在整个 Servlet 生命周期只被执行一次，即使 Web 容器在其内部中多次实例化该方法所在的 bean。<br>这两个注解分别有什么作用呢？<br>@PostConstruct : 用来修饰方法，标记在项目启动的时候执行这个方法,一般用来执行某些初始化操作比如全局配置。<br>PostConstruct 注解的方法会在构造函数之后执行,Servlet 的init()方法之前执行。<br>@PreDestroy : 当 bean 被 Web 容器的时候被调用，一般用来释放 bean 所持有的资源。<br>@PreDestroy 注解的方法会在Servlet 的destroy()方法之前执行。                     </p><h5 id="19-说一下你boot都用过什么注解吧"><a href="#19-说一下你boot都用过什么注解吧" class="headerlink" title="19. 说一下你boot都用过什么注解吧"></a>19. 说一下你boot都用过什么注解吧</h5><p>首先是启动类 @SpringBootApplication 配置文件注解@Configuration 包扫描注解@ComponentScan<br>自动注入@AutoWired @RestController，@RequestMapping，@Service，@Bean，@Value</p><h5 id="20-你知道bean都是怎么注入的吗？"><a href="#20-你知道bean都是怎么注入的吗？" class="headerlink" title="20. 你知道bean都是怎么注入的吗？"></a>20. 你知道bean都是怎么注入的吗？</h5><p>关于ioc的注入，基于xml bean的配置和@controller等注解，包扫描进行ioc注入 bean之间的依赖注入可以通过setter，构造器，工厂模式进行注入<br>手动进行依赖装配过多会导致不易管理，所以我们可以使用注解的方式进行自动装配进行注入，比如@Autowire 和@Resource</p><h5 id="21-说一下-Autowired和-Resource的区别"><a href="#21-说一下-Autowired和-Resource的区别" class="headerlink" title="21.说一下@Autowired和@Resource的区别"></a>21.说一下@Autowired和@Resource的区别</h5><p>@Autowired是spring的 @resource是jdk的 @Autowired默认按照类型装配，默认情况下它要求依赖对象必须存在如果允许为null，<br>可以设置 required属性为false，如果我们想使用按照名称装配，可 以结合@Qualifier注解一起使用;<br>@Resource默认按照名称装配，当找不到与名称匹配的bean才会按照类型装配，可以通过name属性指定，<br>如果没有指定name属 性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找 依赖对象.</p><h5 id="22-Spring底层用了那些设计模式"><a href="#22-Spring底层用了那些设计模式" class="headerlink" title="22. Spring底层用了那些设计模式"></a>22. Spring底层用了那些设计模式</h5><p>工厂模式：创建bean的时候使用的BeanFactory 或 ApplicationContext ，在问下这两个的区别是什么？<br>单例模式：bean 默认都是单例的，再问下为什么是单例的，是线程安全的吗，如何线程安全，bean除了单例还有其他那些作用域？<br>代理模式：aop就是动态代理，在问下你动态代理和静态代理的区别，jdk代理和CGlib的区别，jdk代理的核心是什么，aop和AspectJ的区别是什么？</p><h5 id="23-Spring的加载机制"><a href="#23-Spring的加载机制" class="headerlink" title="23. Spring的加载机制"></a>23. Spring的加载机制</h5><p><a href="https://zhuanlan.zhihu.com/p/62979297">见博客</a>   </p><h5 id="24-Transactional注解哪些场景下会失效"><a href="#24-Transactional注解哪些场景下会失效" class="headerlink" title="24. @Transactional注解哪些场景下会失效"></a>24. @Transactional注解哪些场景下会失效</h5><p>编程式事务：是指在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强</p><pre><code class="hljs haxe"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//TODO something</span>     transactionManager.commit(status);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    transactionManager.rollback(status);    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">InvoiceApplyException</span>(<span class="hljs-string">&quot;异常失败&quot;</span>);&#125;</code></pre><p>声明式事务：基于AOP面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低</p><pre><code class="hljs typescript"><span class="hljs-meta">@Transactional</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/test&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;    int insert = cityInfoDictMapper.insert(cityInfoDict);&#125;</code></pre><p>@Transactional 可以作用在接口、类、类方法。</p><ul><li>作用于类：当把@Transactional 注解放在类上时，表示所有该类的public方法都配置相同的事务属性信息。</li><li>作用于方法：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</li><li>作用于接口：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li></ul><p>@Transactional失效场景</p><ol><li><p>@Transactional 应用在非 public 修饰的方法上</p></li><li><p>@Transactional 注解属性 propagation 设置错误</p><blockquote><p>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p></blockquote></li><li><p>@Transactional 注解属性 rollbackFor 设置错误</p></li><li><p>同一个类中方法调用，导致@Transactional失效</p></li><li><p>异常被你的 catch“吃了”导致@Transactional失效</p></li><li><p>数据库引擎不支持事务</p></li><li><p>在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启(相当于4)</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestService</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    TestMapper testMapper;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertTestInnerInvoke</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//正常public修饰符的事务方法</span>        <span class="hljs-keyword">int</span> re = testMapper.insert(<span class="hljs-keyword">new</span> Test(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));        <span class="hljs-keyword">if</span> (re &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NeedToInterceptException(<span class="hljs-string">&quot;need intercept&quot;</span>);        &#125;        testMapper.insert(<span class="hljs-keyword">new</span> Test(<span class="hljs-number">210</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInnerInvoke</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//类内部调用@Transactional标注的方法。</span>        insertTestInnerInvoke();    &#125;&#125;</code></pre><pre><code class="hljs less"><span class="hljs-variable">@RunWith</span>(SpringRunner.class)<span class="hljs-variable">@SpringBootTest</span>public class DemoApplicationTests &#123;   <span class="hljs-variable">@Resource</span>   TestServiceImpl testService;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 测试内部调用@Transactional标注方法</span><span class="hljs-comment">    */</span>   <span class="hljs-variable">@Test</span>   public void  testInnerInvoke()&#123;       <span class="hljs-comment">//测试外部调用事务方法是否正常</span>      <span class="hljs-comment">//testService.insertTestInnerInvoke();</span>       <span class="hljs-comment">//测试内部调用事务方法是否正常</span>      <span class="hljs-selector-tag">testService</span><span class="hljs-selector-class">.testInnerInvoke</span>();   &#125;&#125;</code></pre><h5 id="Transactional-事务注解原理"><a href="#Transactional-事务注解原理" class="headerlink" title="@Transactional 事务注解原理"></a>@Transactional 事务注解原理</h5><p>@Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。<br>如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。<br>createAopProxy() 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultAopProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AopProxyFactory</span>, <span class="hljs-title">Serializable</span> </span>&#123; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;  <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;   Class&lt;?&gt; targetClass = config.getTargetClass();   <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +      <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);   &#125;   <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);  &#125;  <span class="hljs-keyword">else</span> &#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);  &#125; &#125;&#125;</code></pre><p>如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，<br>在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。<br>这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p></li></ol><p>Spring AOP 自调用问题<br>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有@Transactional 注解的方法的事务会失效。<br>这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p><p>MyService 类中的method1()调用method2()就会导致method2()的事务失效。</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;     method2();     <span class="hljs-comment">//......</span>&#125;<span class="hljs-meta">@Transactional</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-comment">//......</span>  &#125;&#125;</code></pre><h5 id="spring-cloud项目中用到了哪些主要的组件"><a href="#spring-cloud项目中用到了哪些主要的组件" class="headerlink" title="spring cloud项目中用到了哪些主要的组件"></a>spring cloud项目中用到了哪些主要的组件</h5><p>Ribbon: 服务消费者调用服务生产者提供的数据是通过Spring Cloud Ribbon来实现的,Ribbon客户端负载均衡器由此而来<br>Feign: 服务与服务之间的调用<br>Hystrix的含义是：断路器,服务降级<br>Zuul: 服务网关是微服务架构中一个不可或缺的部分</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA网络</title>
    <link href="/2020/04/05/2020-04-05-JAVA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/04/05/2020-04-05-JAVA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><h5 id="1、OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#1、OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="1、OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>1、OSI与TCP/IP各层的结构与功能,都有哪些协议?</h5><p>计算机网络体系结构：<br>OSI的体系结构:<br>1.物理层 -&gt; 2.数据链路层 -&gt; 3.网络层-&gt; 4.运输层 -&gt; 5.会话层 -&gt; 6.表示层 -&gt; 7.应用层<br>TCP/IP的体系结构:<br>网络接口层 -&gt; 网络层IP -&gt; 运输层(TCP或UDP) -&gt; 应用层（各种应用层协议如TELNET,FTP,SMTP等）<br>五层协议的体系结构:<br>1.物理层 -&gt; 2.数据链路层 -&gt; 3.网络层 -&gt; 4.运输层 -&gt; 5.应用层 </p><h5 id="2、TCP-三次握手"><a href="#2、TCP-三次握手" class="headerlink" title="2、TCP 三次握手"></a>2、TCP 三次握手</h5><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端<br>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端<br>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端<br>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常   </li></ul><h5 id="3、TCP-四次挥手"><a href="#3、TCP-四次挥手" class="headerlink" title="3、TCP 四次挥手"></a>3、TCP 四次挥手</h5><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1  </li></ul><h5 id="4、在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#4、在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="4、在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>4、在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h5><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束  </li></ol><h5 id="5、Cookie的作用是什么-和Session有什么区别？"><a href="#5、Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="5、Cookie的作用是什么?和Session有什么区别？"></a>5、Cookie的作用是什么?和Session有什么区别？</h5><p>Cookie 一般用来保存用户信息<br>Session 的主要作用就是通过服务端记录用户的状态。<br>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。<br>Session 安全性更高。   </p><h5 id="6、HTTP-和-HTTPS-的区别？"><a href="#6、HTTP-和-HTTPS-的区别？" class="headerlink" title="6、HTTP 和 HTTPS 的区别？"></a>6、HTTP 和 HTTPS 的区别？</h5><p>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。<br>安全性和资源消耗：<br>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。<br>HTTPS是运行在SSL/TLS之上的HTTP协议，所有传输的内容都经过加密。  </p><h5 id="7、说一下-tcp-粘包是怎么产生的？"><a href="#7、说一下-tcp-粘包是怎么产生的？" class="headerlink" title="7、说一下 tcp 粘包是怎么产生的？"></a>7、说一下 tcp 粘包是怎么产生的？</h5><p>发送方产生粘包<br>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（ 一次连接发一次数据不存在粘包）,<br>双方在连接不断开的情况下， 可以一直传输数据；<br>但当发送的数据包过于的小时， 那么 TCP 协议默认的会启用 Nagle 算法，<br>将这些较小的数据包进行合并发送（ 缓冲区数据发送是一个堆压的过程） ；<br>这个合并过程就是在发送缓冲区中进行的，<br>也就是说数据发送出来它已经是粘包的状态了。<br>接收方产生粘包<br>接收方采用 TCP 协议接收数据时的过程是这样的： 数据到底接收方，<br>从网络模型的下方传递至传输层， 传输层的 TCP 协议处理是将其放置接收缓冲区，<br>然后由应用层来主动获取（ C 语言用 recv、 read 等函数） ； 这时会出现一个问题，<br>就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，<br>而下一个数据又到来并有一部分放入的缓冲区末尾，<br>等我们读取数据时就是一个粘包。 （ 放数据的速度 &gt; 应用层拿数据速度）  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA并发</title>
    <link href="/2020/04/04/2020-04-04-JAVA%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/04/04/2020-04-04-JAVA%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h4 id="JAVA并发"><a href="#JAVA并发" class="headerlink" title="JAVA并发"></a>JAVA并发</h4><h5 id="24-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#24-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="24. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>24. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h5><p>线程是一个比进程更小的执行单位,一个进程在执行中可以产生多个线程,线程也被称为轻量级进程.<br>进程是系统程序运行的基本单位.    </p><h5 id="25-线程有哪些基本状态"><a href="#25-线程有哪些基本状态" class="headerlink" title="25. 线程有哪些基本状态?"></a>25. 线程有哪些基本状态?</h5><p>-实例化-&gt;NEW(初始状态)<br>-Thread.start()-&gt;RUNNABLE(运行状态包括Ready和Running状态)<br>-等待进入synchronized方法和代码块-&gt;BLOCKED(阻塞状态)-获取到锁-&gt;<br>-Object.wait()/Object.join()-&gt;WAITING(等待状态)-Object.notify()/Object.notifyAll()-&gt;<br>-Object.wait(long)/Object.sleep(long)-&gt;TIME_WAITING(超时等待状态)-Object.notify()/Object.notifyAll()-&gt;<br>-执行完成-&gt; TERMINATED(终止状态)    </p><h5 id="4-什么是上下文切换"><a href="#4-什么是上下文切换" class="headerlink" title="4. 什么是上下文切换?"></a>4. 什么是上下文切换?</h5><p>执行完 CPU 时间片任务从保存到再加载的过程就是一次上下文切换.</p><h5 id="5-认识线程死锁"><a href="#5-认识线程死锁" class="headerlink" title="5. 认识线程死锁"></a>5. 认识线程死锁</h5><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p><h5 id="6-如何避免线程死锁"><a href="#6-如何避免线程死锁" class="headerlink" title="6. 如何避免线程死锁?"></a>6. 如何避免线程死锁?</h5><p>破坏互斥条件<br>一次性申请所有的资源。<br>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。<br>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。    </p><h5 id="7-说说-sleep-方法和-wait-方法区别和共同点"><a href="#7-说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="7. 说说 sleep() 方法和 wait() 方法区别和共同点?"></a>7. 说说 sleep() 方法和 wait() 方法区别和共同点?</h5><p>两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。<br>两者都可以暂停线程的执行。<br>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。<br>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者 notifyAll()方法。<br>sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long)超时后线程会自动苏醒。   </p><h5 id="8-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#8-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="8. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run()方法？"></a>8. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run()方法？</h5><p>调用 start 方法方可开辟新线程并进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h5 id="9-说一说自己对于-synchronized-关键字的了解"><a href="#9-说一说自己对于-synchronized-关键字的了解" class="headerlink" title="9. 说一说自己对于 synchronized 关键字的了解"></a>9. 说一说自己对于 synchronized 关键字的了解</h5><p>synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。<br>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h5 id="10-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#10-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="10. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>10. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h5><p>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁<br>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁<br>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁<br>synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。<br>synchronized 关键字加到实例方法上是给对象实例上锁。<br>尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能</p><h5 id="11-讲一下-synchronized-关键字的底层原理"><a href="#11-讲一下-synchronized-关键字的底层原理" class="headerlink" title="11. 讲一下 synchronized 关键字的底层原理"></a>11. 讲一下 synchronized 关键字的底层原理</h5><p>① synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，<br>其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。<br>② synchronized 修饰的方法是 ACC_SYNCHRONIZED 标识</p><h5 id="12-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗"><a href="#12-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗" class="headerlink" title="12. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗"></a>12. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h5><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。<br>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。<br>注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。  </p><h5 id="13-谈谈-synchronized和ReentrantLock-的区别"><a href="#13-谈谈-synchronized和ReentrantLock-的区别" class="headerlink" title="13. 谈谈 synchronized和ReentrantLock 的区别"></a>13. 谈谈 synchronized和ReentrantLock 的区别</h5><p>① 两者都是可重入锁，自己可以再次获取自己的内部锁<br>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API<br>③ ReentrantLock 比 synchronized 增加:<br>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）  </p><h5 id="14、说说volatile关键字"><a href="#14、说说volatile关键字" class="headerlink" title="14、说说volatile关键字"></a>14、说说volatile关键字</h5><p>volatile关键字的主要作用就是保证变量的可见性然后还有一个作用是防止JVM优化的指令重排序。  </p><h5 id="15-并发编程的三个重要特性"><a href="#15-并发编程的三个重要特性" class="headerlink" title="15. 并发编程的三个重要特性"></a>15. 并发编程的三个重要特性</h5><p>原子性 : 要么所有的操作都执行，要么都不执行。synchronized 可以保证代码片段的原子性。<br>可见性 ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。<br>有序性 ：Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。</p><h5 id="16-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#16-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="16. 说说 synchronized 关键字和 volatile 关键字的区别"></a>16. 说说 synchronized 关键字和 volatile 关键字的区别</h5><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。<br>但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。<br>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞<br>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。<br>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</p><h5 id="17-ThreadPoolExecutor构造函数重要参数分析"><a href="#17-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="17. ThreadPoolExecutor构造函数重要参数分析"></a>17. ThreadPoolExecutor构造函数重要参数分析</h5><p>corePoolSize: 核心线程数线程<br>maximumPoolSize: 最大线程数<br>workQueue: 工作队列</p><h5 id="18-Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#18-Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="18. Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>18. Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h5><p>Executors目前提供了5种不同的线程池创建配置：<br>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；<br>如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。<br>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。<br>这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。<br>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状<br>态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。<br>newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，<br>可以进行定时或周期性的工作调度,区别在于单一工作线程还是多个工作线程。<br>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池， Java 8才加入这个创建方法，其内部会构建ForkJoinPool，<br>利用Work-Stealing算法，并行地处理任务，不保证处理顺序。   </p><p>ThreadPoolExecutor3个最重要的参数：<br>corePoolSize：线程池的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。<br>maximumPoolSize:最大线程数，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。<br>keepAliveTime:线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。<br>unit：这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。<br>workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。<br>threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。<br>handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。<br>任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，<br>如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，<br>如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,<br>如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。</p><p>corePoolSize．核心线程数线程数定义了最小可以同时运行的线程数量。<br>maximumPoolSize：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。<br>workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。<br>ThreadPoolExecutor其他常见参数：<br>1．keepAliveTime:当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，<br>直到等待的时间超过了keepA1iveTime才会被回收销毁；<br>2．unit：keepAliveTime参数的时间单位。<br>3．threadFactory:executor创建新线程的时候会用到。<br>4．handler:饱和策略。<br>ThreadPoolExecutor饱和策略定义：<br>ThreadPoolExecutor.AbortPolicy:抛出RejectedExecutionExcept10n来拒绝新任务的处理。<br>ThreadPoolExecutor.CallerRunsPolicy:调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。<br>ThreadPoolExecutor．DiscardPolicy: 不处理新任务，直接丢弃掉。<br>ThreadPoolExecutor．Discard01destPolicy:此策略将丢弃最早的未处理的任务请求。</p><h5 id="19-介绍一下Atomic-原子类"><a href="#19-介绍一下Atomic-原子类" class="headerlink" title="19. 介绍一下Atomic 原子类"></a>19. 介绍一下Atomic 原子类</h5><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。<br>UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。<br>另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h5 id="20-AQS-原理概览"><a href="#20-AQS-原理概览" class="headerlink" title="20. AQS 原理概览"></a>20. AQS 原理概览</h5><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><h5 id="21-Java并发包提供了哪些并发工具类？"><a href="#21-Java并发包提供了哪些并发工具类？" class="headerlink" title="21. Java并发包提供了哪些并发工具类？"></a>21. Java并发包提供了哪些并发工具类？</h5><p>AQS组件总结<br>Semaphore（信号量）．允许多个线程同时访问：synchronized和ReentrantLock都是一次只允许一个线程访问某个资源，semaphore(信号量）可以指定多个线程同时访问某个资源。<br>CountDownLatch（倒计时器）：CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，允许一个或多个线程等待某些操作完成。<br>CyclicBarrier(循环栅栏）：CyclicBarrier和CountDownLatch非常类似，它也可以实现线程间的技术等待，一种辅助性的同步结构，允许多个线程等待到达某个屏障。  </p><h5 id="22-写出三种单例模式实现-。"><a href="#22-写出三种单例模式实现-。" class="headerlink" title="22. 写出三种单例模式实现 。"></a>22. 写出三种单例模式实现 。</h5><pre><code class="hljs routeros">public class SingletonExample&#123;    private SingletonExample&#123;&#125;    private static SingletonExample<span class="hljs-built_in"> instance </span>= new SingletonExample();    public static SingletonExample getInstance()&#123;        return instance;    &#125;&#125;</code></pre><pre><code class="hljs routeros">public class SingletonExample1&#123;    private SingletonExample1&#123;&#125;    private volatile static SingletonExample1<span class="hljs-built_in"> instance </span>= <span class="hljs-literal">null</span>;    public static SingletonExample1 getInstance()&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;            synchronized(SingletonExample1.class)&#123;                 <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;                   <span class="hljs-built_in"> instance </span>= new SingletonExample1();                 &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><pre><code class="hljs routeros">public class SingletonExample2&#123;   private SingletonExample2&#123;&#125;   private static SingletonExample2<span class="hljs-built_in"> instance </span>= <span class="hljs-literal">null</span>;   static&#123;    <span class="hljs-built_in"> instance </span>= new SingletonExample2();   &#125;   public static SingletonExample2 getInstance()&#123;        return instance;   &#125;&#125;</code></pre><h5 id="23-线程的sleep-方法和yield-方法有什么区别？"><a href="#23-线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="23. 线程的sleep()方法和yield()方法有什么区别？"></a>23. 线程的sleep()方法和yield()方法有什么区别？</h5><p>1、sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>2、线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；<br>3、sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；<br>4、sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。  </p><h5 id="24-请说出与线程同步以及线程调度相关的方法。"><a href="#24-请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="24. 请说出与线程同步以及线程调度相关的方法。"></a>24. 请说出与线程同步以及线程调度相关的方法。</h5><p>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；<br>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；<br>notifyAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。  </p><h5 id="25-Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#25-Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="25. Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？"></a>25. Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？</h5><p>sleep()方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持。<br>调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），<br>只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool）。    </p><h5 id="26-sleep-、join（）、yield（）有什么区别"><a href="#26-sleep-、join（）、yield（）有什么区别" class="headerlink" title="26. sleep() 、join（）、yield（）有什么区别"></a>26. sleep() 、join（）、yield（）有什么区别</h5><p>1、sleep()方法<br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），不释放对象锁。<br>2、yield()方法<br>yield()方法和sleep()方法类似，也不会释放“锁标志”，<br>yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，<br>yield()方法只能使同优先级或者高优先级的线程得到执行机会。<br>3、join()方法<br>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。   </p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA内存</title>
    <link href="/2020/04/03/2020-04-03-JAVA%E5%86%85%E5%AD%98/"/>
    <url>/2020/04/03/2020-04-03-JAVA%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h4 id="JAVA内存"><a href="#JAVA内存" class="headerlink" title="JAVA内存"></a>JAVA内存</h4><h5 id="23、介绍下Java内存区域"><a href="#23、介绍下Java内存区域" class="headerlink" title="23、介绍下Java内存区域"></a>23、介绍下Java内存区域</h5><p>线程私有的:<br>程序计数器: 程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；<br>如果是在执行本地方法，则是未指定值（undefined）。<br>Java虚拟机栈: 对应着一次次的Java方法调用。<br>本地方法栈: 虚拟机对Native本地方法服务调用，也是每个线程都会创建一个。<br>线程共享的:<br>Java堆: 堆又分为新生代和老年代，是Java内存管理的核心区域，用来放置Java对象实例。<br>方法区: 也称为永久代,用于存储元（Meta）数据，如类结构信息，运行时常量池、字段、方法代码等。<br>JDK 8中将永久代移除，取而代之的是元数据区（Metaspace），元数据区使用的是直接内存  </p><p>运行时常量池: 方法区的一部分。Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用。<br>JDK1.7之后JVM运行时常量池从方法区移除，在Java堆中开辟了一块区域存放运行时常量池<br>只有程序计数器不会发生OOM，Java虚拟机栈，本地方法栈，Java堆，方法区，直接内存可能发生OOM  </p><p>-Xmx5G                      指定最大的堆大小<br>-Xms2G                      指定初始堆大小<br>-XX:NewSize=256m            指定新生代的最小256m的内存<br>-XX:MaxNewSize=1024m        指定新生代的最大1024m的内存<br>-XX:NewRatio=2<br>老年代与新生代(包括Eden和两个Survivor区)的大小比例。默认情况下，这个比例是2，也就是说老年代是新生代的2倍大。<br>-XX:SurvivorRatio=value<br>设置Eden与Survivor的大小比例，如果该值为8，代表一个Survivor是Eden的1/8，是整个新生代的1/10。<br>-XX:PermSize=N              方法区 (永久代) 初始大小<br>-XX:MaxPermSize=N<br>方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen<br>-server -Xms512m -Xmx512m -Xss1024K<br>Server模式启动  最小堆内存512m  最大512m  每个线程栈空间1m<br>XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80<br>最大转为老年代检查次数20  Cms回收开启时机：内存占用80% <br>XX:+UseCMSInitiatingOccupancyOnly<br>命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期    </p><h5 id="1-程序计数器为什么是私有的"><a href="#1-程序计数器为什么是私有的" class="headerlink" title="1. 程序计数器为什么是私有的?"></a>1. 程序计数器为什么是私有的?</h5><p>序计数器用于记录当前线程执行的位置,如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址</p><h5 id="2-虚拟机栈和本地方法栈为什么是私有的"><a href="#2-虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="2. 虚拟机栈和本地方法栈为什么是私有的?"></a>2. 虚拟机栈和本地方法栈为什么是私有的?</h5><p>虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。<br>本地方法栈：本地方法栈则为虚拟机使用到的 Native 方法服务.</p><h5 id="3-一句话简单了解堆和方法区"><a href="#3-一句话简单了解堆和方法区" class="headerlink" title="3. 一句话简单了解堆和方法区"></a>3. 一句话简单了解堆和方法区</h5><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，<br>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h5 id="4-对象的创建"><a href="#4-对象的创建" class="headerlink" title="4. 对象的创建"></a>4. 对象的创建</h5><p>类加载检查 -&gt; 分配内存 -&gt; 初始化零值 -&gt; 设置对象头 -&gt; 执行 init 方法</p><h5 id="5-Java堆"><a href="#5-Java堆" class="headerlink" title="5. Java堆"></a>5. Java堆</h5><p>也被称作GC 堆,eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代<br>Eden和Survivor默认比例为8:1<br>对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，<br>并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，<br>当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中.<br>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）.   </p><h5 id="6-Minor-GC-和-Full-GC-有什么不同呢？"><a href="#6-Minor-GC-和-Full-GC-有什么不同呢？" class="headerlink" title="6. Minor GC 和 Full GC 有什么不同呢？"></a>6. Minor GC 和 Full GC 有什么不同呢？</h5><p>新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，回收速度比较快。<br>老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。   </p><h5 id="6-对象已经死亡？"><a href="#6-对象已经死亡？" class="headerlink" title="6. 对象已经死亡？"></a>6. 对象已经死亡？</h5><p>引用计数法:<br>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用<br>可达性分析算法:<br>当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。  </p><h5 id="7-强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#7-强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="7. 强引用、软引用、弱引用、幻象引用有什么区别？"></a>7. 强引用、软引用、弱引用、幻象引用有什么区别？</h5><p>强引用：常见的普通对象引用，只要强引用指向一个对象，垃圾收集器不会碰这种对象。<br>软引用：只有当JVM认为内存不足时，才会去回收软引用指向的对象。<br>弱引用：不能使对象豁免垃圾收集，当GC发现时会被回收。<br>幻象引用：无法通过幻象引用获得对象。和没有任何引用一样，任何时候都会被垃圾回收。<br>幻象引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。    </p><h5 id="8、Java常见的垃圾收集器有哪些，垃圾收集算法？"><a href="#8、Java常见的垃圾收集器有哪些，垃圾收集算法？" class="headerlink" title="8、Java常见的垃圾收集器有哪些，垃圾收集算法？"></a>8、Java常见的垃圾收集器有哪些，垃圾收集算法？</h5><p>Serial： 最早的单线程串行垃圾回收器<br>ParNew： Serial收集器的多线程版本<br>Parallel Scavenge： 使用复制算法的多线程收集器<br>Parallel Scavenge: 类似ParNew收集器，更关注吞吐量（高效率的利用CPU）<br>CMS： 一种以获得最短停顿时间为目标的收集器，注重用户体验,非常适用 B/S 系统<br>G1： 一种兼顾吞吐量和停顿时间的 GC 实现, 是 JDK 9 以后的默认 GC 选项    </p><p>标记-清除算法: 标记无用对象，进行清除回收。 缺点： 效率不高， 无法清除垃圾碎片<br>标记-整理算法: 标记无用对象，让所有存活的对象都向一端移动，然后清除掉端边界以外的内存<br>复制算法： 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着对象复制到另一块上，<br>然后再把已使用的内存空间一次清理掉。 缺点： 内存使用率不高， 只有原来的一半<br>分代算法： 根据对象存活周期的不同将内存划分为几块，<br>一般是新生代基本采用复制算法， 老年代采用标记整理算法  </p><h5 id="9-请介绍类加载过程，什么是双亲委派模型？"><a href="#9-请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="9. 请介绍类加载过程，什么是双亲委派模型？"></a>9. 请介绍类加载过程，什么是双亲委派模型？</h5><p>类加载过程：加载、链接（验证-&gt;准备-&gt;解析）、初始化<br>BootstrapClassLoader(启动类加载器）-&gt;<br>ExtensionClassLoader(扩展类加载器）-&gt;<br>AppClassLoader(应用程序类加载器）-&gt;<br>自定义类加载器  </p><p>双亲委派模型介绍<br>如果一个类加载器收到了类加载的请求， 它首先不会自己去加载这个类， 而是把这个请求委派给父类加载器去完成。<br>所有的加载请求都会被传送到顶层的启动类加载器中， 只有当父加载无法完成加载请求时，子加载器才会尝试去加载类己来处理。<br>当父类加载器为null时，会使用启动类加载器BootstrapC1assLoader作为父类加载器。<br>双亲委派模型可以避免类的重复加载。<br>如何打破双亲委派机制<br>1、自己写一个类加载器 2、重写loadClass方法 3、重写findClass方法  </p><h5 id="10-什么情况下会发生栈内存溢出。"><a href="#10-什么情况下会发生栈内存溢出。" class="headerlink" title="10. 什么情况下会发生栈内存溢出。"></a>10. 什么情况下会发生栈内存溢出。</h5><p>内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。<br>如果出现这种现象可行代码排查：<br>一）是否App中的类中和引用变量过多使用了Static修饰 如public static Student s;<br>在类中的属性中使用 static修饰的最好只用基本类型或字符串。如public static int i = 0;<br>二）是否App中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）<br>是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）   </p><h5 id="11-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"><a href="#11-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。" class="headerlink" title="11. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"></a>11. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h5><p>为了提升GC效率，根据各个年代的特点使用垃圾收集算法</p><h5 id="12-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。"><a href="#12-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。" class="headerlink" title="12. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。"></a>12. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</h5><p>不可以，双亲委派模式会保证父类加载器先加载类，<br>BootStrap（启动类）加载器加载jdk里面的java.lang.String类，<br>自定义的java.lang.String类永远不会被加载到       </p><h5 id="13-jvm为什么采用分带收集"><a href="#13-jvm为什么采用分带收集" class="headerlink" title="13. jvm为什么采用分带收集"></a>13. jvm为什么采用分带收集</h5><p>我们根据不同的年代选择适合的垃圾回收算法 比如在新生代中，每次收集都会有大量对象死去，<br>所以可以选择复制算法，而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，<br>所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA容器</title>
    <link href="/2020/04/02/2020-04-02-JAVA%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/04/02/2020-04-02-JAVA%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="JAVA容器"><a href="#JAVA容器" class="headerlink" title="JAVA容器"></a>JAVA容器</h4><h5 id="1-说说List-Set-Map三者的区别？"><a href="#1-说说List-Set-Map三者的区别？" class="headerlink" title="1. 说说List,Set,Map三者的区别？"></a>1. 说说List,Set,Map三者的区别？</h5><p>List、Set继承自Collection接口<br>List（对付顺序的好帮手）: List接口存储一组不唯一(可以有多个元素引用相同的对象),有序的对象<br>set（注重独一无二的性质）:不允许重复的集合。不会有多个元素引用相同的对象。<br>Map（用Key来搜索的专家）:使用键值对存储。Map会维护与Key有关联的值。<br>两个Key可以引用相同的对象，但Key不能重复。    </p><h5 id="2-ArrayList、Vector与-LinkedList区别"><a href="#2-ArrayList、Vector与-LinkedList区别" class="headerlink" title="2. ArrayList、Vector与 LinkedList区别?"></a>2. ArrayList、Vector与 LinkedList区别?</h5><p>有序列表，可存放重复对象元素<br>ArrayList 和 LinkedList 不保证线程安全,Vector是线程安全，所有方法都是同步的<br>ArrayList底层是Object数组结构，LinkedList是双向链表结构（1.6之前是循环链表，1.7之后取消了循环）<br>ArrayList随机访问效率高，增删效率低<br>LinkedList增删效率高，随机访问慢<br>ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间<br>LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间     </p><h5 id="3-HashMap-和-Hashtable-、TreeMap的区别"><a href="#3-HashMap-和-Hashtable-、TreeMap的区别" class="headerlink" title="3. HashMap 和 Hashtable 、TreeMap的区别"></a>3. HashMap 和 Hashtable 、TreeMap的区别</h5><p>HashMap是非线程安全的，HashTable是线程安全的，HashTable内部的方法基本都经过synchronized修饰。<br>效率：线程安全的问题，HashMap要比HashTable效率高，HashTable基本被淘汰，建议使用ConcurrentHashMap；<br>HashMap中，支持一个null键多个null值。HashTable不支持null键null值<br>HashTable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。<br>HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。<br>Hashtable 会直接使用你给定的容量大小，<br>HashMap 会将其扩充为2的幂次方大小<br>JDK1.8以后的HashMap在解决哈希冲突时，当链表长度大于（默认为8）时，将链表转化为红黑树。<br>TreeMap底层是基于红黑树，提供顺序访问的Map。       </p><h5 id="4-HashMap-和-HashSet区别"><a href="#4-HashMap-和-HashSet区别" class="headerlink" title="4. HashMap 和 HashSet区别"></a>4. HashMap 和 HashSet区别</h5><p>HashSet底层是基于HashMap实现的,<br>hashSet的值存放HashMap的key,value为公用的PRESENT     </p><h5 id="5-HashMap的底层实现"><a href="#5-HashMap的底层实现" class="headerlink" title="5. HashMap的底层实现"></a>5. HashMap的底层实现</h5><p>JDK1.8之前HashMap底层是数组和链表结合在一起使用也就是链表散列。<br>HashMap通过key的hashCode 经过扰动函数处理过后得到 hash 值，<br>然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（n指数组的长度）,<br>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，<br>如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。<br>JDK1.8之后在解决哈希冲突时有了较大的变化，<br>当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><h5 id="6-HashMap-的长度为什么是2的幂次方"><a href="#6-HashMap-的长度为什么是2的幂次方" class="headerlink" title="6. HashMap 的长度为什么是2的幂次方"></a>6. HashMap 的长度为什么是2的幂次方</h5><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。<br>对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。<br>这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n代表数组长度）。</p><h5 id="7-ConcurrentHashMap线程安全的具体实现方式／底层具体实现-及和HashTable区别？"><a href="#7-ConcurrentHashMap线程安全的具体实现方式／底层具体实现-及和HashTable区别？" class="headerlink" title="7. ConcurrentHashMap线程安全的具体实现方式／底层具体实现,及和HashTable区别？"></a>7. ConcurrentHashMap线程安全的具体实现方式／底层具体实现,及和HashTable区别？</h5><p>底层数据结:<br>JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，<br>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。<br>Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用数组+链表的形式.<br>实现线程安全:<br>① 在JDK1.7的时候，ConcurrentHashMap（分段锁）对整个桶数组进行了分割分段(Segment)，<br>每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争。<br>JDK1.8 的时候已经摒弃了Segment的概念，<br>直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作。<br>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，提升效率。<br>② Hashtable(同一把锁) : 使用synchronized来保证线程安全，效率非常低下。   </p><h5 id="8-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"><a href="#8-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。" class="headerlink" title="8. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"></a>8. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</h5><p>hashMap是线程不安全的map,ConcurrentHashMap是线程安全的，hashTable是线程安全的，使用synchronized修饰所有内部方法<br>hashMap支持一个null键和多个null值，ConcurrentHashMap和hashTable不支持null键和null值<br>hashMap1.7之前底层使用数组+链表数据结构，1.8之后使用Node数组+链表/红黑树数据结构，当链表长度大于默认为8时转换为红黑树结构<br>ConcurrentHashMap1.7采用分段锁segment和hashEntry数组来保证数据同步，<br>1.8之后采用cas+synchronized来保证并发，1.8之后使用Node数组+链表/红黑树数据结构，当链表长度大于默认为8时转换为红黑树结构<br>hashTable默认初始值是11，之后每次扩容为2n+1<br>HashMap默认是16，每次扩容为2倍</p><h5 id="9-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"><a href="#9-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。" class="headerlink" title="9. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"></a>9. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</h5><p>分段锁锁住的是Segment整个桶的HashEntry数据，相比jdk1.8的cas+synchronized性能更差,<br>锁的力度更大，1.8只有处理相同的hash值才会获取锁。</p><h5 id="10-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"><a href="#10-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="10. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"></a>10. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</h5><p>TreeSet要求存放的对象所属的类必须实现Comparable接口，<br>该接口提供了比较元素的compareTo()方法，<br>当插入元素时会回调该方法比较元素的大小。<br>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。<br>Collections工具类的sort方法有两种重载的形式，<br>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；<br>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较）。<br>TreeMap和LinkedHashMap是有序的（TreeMap是默认key升序的，LinkedHashMap是默认数据的插入顺序的）<br>TreeMap是基于比较器Comparator来实现有序的。<br>LinkedHashMap是基于链表来实现数据插入有序的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础</title>
    <link href="/2020/04/01/2020-04-01-JAVA%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/04/01/2020-04-01-JAVA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h4><h5 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h5><ul><li>面向过程 ：面向过程性能比面向对象高。         </li><li>面向对象 ：面向对象易维护、易复用、易扩展。面向对象性能比面向过程低。       </li></ul><h5 id="2-Java-语言有哪些特点-“Java是解释执行”，这句话正确吗？"><a href="#2-Java-语言有哪些特点-“Java是解释执行”，这句话正确吗？" class="headerlink" title="2. Java 语言有哪些特点? “Java是解释执行”，这句话正确吗？"></a>2. Java 语言有哪些特点? “Java是解释执行”，这句话正确吗？</h5><ol><li>面向对象（封装，继承，多态）；     </li><li>平台无关性（ Java 虚拟机实现平台无关性）；     </li><li>垃圾回收器（GC）;     </li><li>编译与解释并存；     </li></ol><p>Java的源代码，首先通过Javac编译成为字节码（bytecode），在通过JVM内嵌的解释器将字节码转换成为机器码。<br>HotspotJVM提供了JIT（动态编译器）编译器，能够在运行时将热点代码编译成机器码。<br>部分热点代码就属于编译执行，而不是解释执行了。    </p><h5 id="3-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#3-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="3. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>3. 关于 JVM JDK 和 JRE 最详细通俗的解答</h5><p>JVM: Java虚拟机是运行 Java 字节码的虚拟机。<br>JVM: 针对不同系统使用相同的字节码，给出相同的结果。<br>JDK: 创建和编译程序环境。<br>JRE: 是 Java 运行时环境。    </p><h5 id="4-Java-和-C-的区别"><a href="#4-Java-和-C-的区别" class="headerlink" title="4. Java 和 C++的区别?"></a>4. Java 和 C++的区别?</h5><p>都是面向对象的语言，支持封装、继承和多态<br>Java 不提供指针来直接访问内存，内存更加安全<br>Java 的类是单继承的，C++ 支持多重继承；Java 接口可以多继承<br>Java 有自动内存管理机制，不需要手动释放无用内存    </p><h5 id="5-字符型常量和字符串常量的区别"><a href="#5-字符型常量和字符串常量的区别" class="headerlink" title="5. 字符型常量和字符串常量的区别?"></a>5. 字符型常量和字符串常量的区别?</h5><p>字符常量是单引号引起的一个字符;字符串常量是双引号引起的若干个字符<br>占内存大小:字符常量只占2个字节;字符串常量占若干个字节(char占两个字节)<br>int         4个字节<br>long        8个字节<br>float       4个字节<br>double      8个字节<br>char        2个字节<br>byte        1个字节<br>short       2个字节<br>boolean     1bit    </p><h5 id="6-构造器-Constructor-是否可被-override"><a href="#6-构造器-Constructor-是否可被-override" class="headerlink" title="6. 构造器 Constructor 是否可被 override?"></a>6. 构造器 Constructor 是否可被 override?</h5><p>Constructor 不能被 override（重写）,但是可以 overload（重载）    </p><h5 id="7-重载和重写的区别"><a href="#7-重载和重写的区别" class="headerlink" title="7. 重载和重写的区别"></a>7. 重载和重写的区别</h5><p>重载: 同一个类中，方法名相同，参数类型不同、个数不同、顺序不同<br>重写: 运行期间，子类对父类的允许访问的方法的进行重写    </p><h5 id="8-Java-面向对象编程三大特性-封装-继承-多态"><a href="#8-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="8. Java 面向对象编程三大特性: 封装 继承 多态"></a>8. Java 面向对象编程三大特性: 封装 继承 多态</h5><p>抽象: 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为。接口是对行为的抽象<br>继承: 继承是从已有类得到继承信息创建新类的过程。<br>封装: 把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。<br>多态性: 多态性是指允许不同子类型的对象对同一消息作出不同的响应。<br>方法重载（overload）实现的是编译时的多态性（也称为前绑定）。<br>方法重写（override）实现的是运行时的多态性（也称为后绑定）。<br>在 Java 中有两种形式可以实现多态:<br>继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。  </p><h5 id="9-String-StringBuffer-和-StringBuilder-的区别是什么"><a href="#9-String-StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="9. String StringBuffer 和 StringBuilder 的区别是什么?"></a>9. String StringBuffer 和 StringBuilder 的区别是什么?</h5><p>String 类中使用 final 关键字修饰字符(char)数组来保存字符串（jdk1.9使用byte数组来保存）,String 对象是不可变的。<br>StringBuffer和StringBuilder继承自AbstractStringBuilder,对象是可变的<br>StringBuffer是线程安全的，StringBuilder非线程安全    </p><h5 id="10-自动装箱与拆箱"><a href="#10-自动装箱与拆箱" class="headerlink" title="10. 自动装箱与拆箱"></a>10. 自动装箱与拆箱</h5><p>装箱：将基本类型用它们对应的引用类型包装起来；<br>拆箱：将包装类型转换为基本数据类型；    </p><h5 id="11-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#11-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="11. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>11. 在一个静态方法内调用一个非静态成员为什么是非法的?</h5><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。    </p><h5 id="12-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#12-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="12. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>12. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h5><p>Java 在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，<br>则会调用父类中无参构造方法<br>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，<br>则编译时将发生错误，<br>因为 Java 程序在父类中找不到没有参数的构造方法可供执行。<br>解决办法是在父类里加上一个不做事且没有参数的构造方法。       </p><h5 id="13-接口和抽象类的区别是什么？"><a href="#13-接口和抽象类的区别是什么？" class="headerlink" title="13. 接口和抽象类的区别是什么？"></a>13. 接口和抽象类的区别是什么？</h5><p>接口的方法默认是 public，方法在接口中不能有实现(Java8接口有default默认实现）,<br>抽象类可以有非抽象的方法<br>接口中除了 static、final 变量，不能有其他变量，抽象类不一定。<br>一个类可以实现多个接口，但只能实现一个抽象类。接口可以extends继承多个接口。<br>接口方法默认修饰符是 public,抽象方法可以有 public、protected和default修饰符<br>（抽象方法不能使用 private修饰！）<br>抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。      </p><h5 id="14-成员变量与局部变量的区别有哪些？"><a href="#14-成员变量与局部变量的区别有哪些？" class="headerlink" title="14. 成员变量与局部变量的区别有哪些？"></a>14. 成员变量与局部变量的区别有哪些？</h5><p>成员变量是属于类的，局部变量是在方法中定义的变量或是方法的参数;<br>成员变量可以被 public,private,static 等修饰符所修饰，<br>局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。<br>如果成员变量是使用static修饰的，那么这个成员变量是属于类的，<br>如果没有使用static修饰，这个成员变量是属于实例的。<br>对象存在于堆内存，局部变量则存在于栈内存。      </p><h5 id="15-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#15-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="15. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>15. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h5><p>new 运算符，new 创建对象实例（对象实例在堆内存中），<br>对象引用指向对象实例（对象引用存放在栈内存中）。<br>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;<br>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。    </p><h5 id="16-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#16-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="16. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>16. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h5><p>主要作用是完成对类对象的初始化工作。可以执行。<br>因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。       </p><h5 id="17-静态方法和实例方法有何不同"><a href="#17-静态方法和实例方法有何不同" class="headerlink" title="17.  静态方法和实例方法有何不同"></a>17.  静态方法和实例方法有何不同</h5><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。<br>而实例方法只有后面这种方式。<br>也就是说，调用静态方法可以无需创建对象。<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），<br>而不允许访问实例成员变量和实例方法；实例方法则无此限制。     </p><h5 id="18-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#18-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="18. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>18. 对象的相等与指向他们的引用相等,两者有什么不同?</h5><p>对象的相等，比的是内存中存放的内容是否相等。<br>引用相等，比较的是他们指向的内存地址是否相等。       </p><h5 id="19-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#19-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="19. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>19. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h5><p>帮助子类做初始化工作。    </p><h5 id="20-与-equals-重要"><a href="#20-与-equals-重要" class="headerlink" title="20. == 与 equals(重要)"></a>20. == 与 equals(重要)</h5><p>== : 判断两个对象的地址是不是相等。判断两个对象是不是同一个对象。<br>(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)<br>equals() : 它的作用也是判断两个对象是否相等。</p><ul><li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。      </li><li>情况 2：类覆盖了 equals()方法。都覆盖 equals()方法来比较两个对象的内容相等；内容相等，则返回true。     </li></ul><h5 id="21-hashCode-与-equals-重要-为什么要有-hashCode"><a href="#21-hashCode-与-equals-重要-为什么要有-hashCode" class="headerlink" title="21. hashCode 与 equals (重要),为什么要有 hashCode"></a>21. hashCode 与 equals (重要),为什么要有 hashCode</h5><p>hashCode() 的作用是获取哈希码，也称为散列码；<br>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，<br>同时也会与其他已经加入的对象的 hashcode 值作比较，<br>如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。<br>但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。<br>如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。<br>这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。      </p><h5 id="22-hashCode（）与-equals（）的相关规定"><a href="#22-hashCode（）与-equals（）的相关规定" class="headerlink" title="22. hashCode（）与 equals（）的相关规定"></a>22. hashCode（）与 equals（）的相关规定</h5><ol><li>如果两个对象相等，则 hashcode 一定也是相同的    </li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的    </li></ol><h5 id="23-为什么-Java-中只有值传递？"><a href="#23-为什么-Java-中只有值传递？" class="headerlink" title="23. 为什么 Java 中只有值传递？"></a>23. 为什么 Java 中只有值传递？</h5><p>按值调用表示方法接收的是调用者提供的值，<br>按引用调用表示方法接收的是调用者提供的变量地址。<br>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。<br>Java 程序设计语言总是采用按值调用。方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。    </p><h5 id="26-关于-final-关键字的一些总结finally、-finalize有什么不同？"><a href="#26-关于-final-关键字的一些总结finally、-finalize有什么不同？" class="headerlink" title="26. 关于 final 关键字的一些总结finally、 finalize有什么不同？"></a>26. 关于 final 关键字的一些总结finally、 finalize有什么不同？</h5><p>final修饰的类不可以继承，<br>final的变量是不可以修改的，<br>final的方法不可以重写的（override）。<br>finally则是Java保证重点代码一定要被执行的一种机制。<br>我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。<br>finalize是基础类java.lang.Object的一个方法，垃圾收集器将对象从内存中清除出去之前做必要的清理工作。         </p><h5 id="27-Java-中的异常处理"><a href="#27-Java-中的异常处理" class="headerlink" title="27. Java 中的异常处理"></a>27. Java 中的异常处理</h5><p>Exception和Error都是继承了Throwable类<br>Error是指在程序无法处理的错误，JVM会选择线程终止。OutOfMemoryError都是Error的子类。<br>Exception是程序本身可以处理的异常。<br>Exception又分为运行时异常，受检查异常。<br>       RuntimeException(运行时异常):<br>       表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止程序，因此，编译器不检查这些异常。<br>       CheckedException(受检查异常):<br>       表示程序可以处理的异常，也即表示程序可以修复， 所以称之为受检查异常。<br>ArithmeticException（算术异常）<br>ClassCastException （类转换异常）<br>IllegalArgumentException （非法参数异常）<br>IndexOutOfBoundsException （下标越界异常）<br>NullPointerException （空指针异常）<br>SecurityException （安全异常）      </p><h5 id="28-Java-中-IO-流分为几种"><a href="#28-Java-中-IO-流分为几种" class="headerlink" title="28. Java 中 IO 流分为几种?"></a>28. Java 中 IO 流分为几种?</h5><p>按照流的流向分，可以分为输入流和输出流；<br>按照操作单元划分，可以划分为字节流和字符流；<br>按照流的角色划分为节点流和处理流。<br>字符流是由Java虚拟机将字节转换得到的，如果不知道编码类型就很容易出现乱码问题。<br>所以，I/O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。<br>如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。<br>BIO(Blocking1/0):同步阻塞1/0模式，数据的读取写入必须阻塞在一个线程内等待其完成。模式简单使用方便，并发处理能力低。<br>NIO(NewI/O):NIO是一种同步非阻塞的I/O模型,在Java1.4中引入了NIO框架,对应java.nio包，提供了Channel，Selector，Buffer等抽象。<br>AIO(AsynchronousI/O):AIO也就是NIO2。在Java7中引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO的操作是基于事件和回调机制。         </p><h5 id="29-深拷贝-vs-浅拷贝"><a href="#29-深拷贝-vs-浅拷贝" class="headerlink" title="29. 深拷贝 vs 浅拷贝"></a>29. 深拷贝 vs 浅拷贝</h5><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。<br>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。      </p><h5 id="30-谈谈Java反射机制，动态代理是基于什么原理？"><a href="#30-谈谈Java反射机制，动态代理是基于什么原理？" class="headerlink" title="30. 谈谈Java反射机制，动态代理是基于什么原理？"></a>30. 谈谈Java反射机制，动态代理是基于什么原理？</h5><p>反射机制是运行状态中可以直接操作类或者对象，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。<br>反射创建类实例的三种方式:<br>Class.forName(“com.A”)<br>A a= new A();<br>Class clazz = a.getClass();<br>Class clazz = A.class      </p><h5 id="31-反射中，Class-forName和ClassLoader区别-。"><a href="#31-反射中，Class-forName和ClassLoader区别-。" class="headerlink" title="31. 反射中，Class.forName和ClassLoader区别 。"></a>31. 反射中，Class.forName和ClassLoader区别 。</h5><p>class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。<br>classLoader只会将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块      </p><h5 id="32-描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#32-描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="32. 描述动态代理的几种实现方式，分别说出相应的优缺点。"></a>32. 描述动态代理的几种实现方式，分别说出相应的优缺点。</h5><p>JDK原生动态代理、CGLIB动态代理<br>JDK原生动态代理是java原生支持，不需要外部依赖，只能基于接口进行代理<br>CGLIB动态代理基于继承进行代理，无需接口，无法代理final方法的情况      </p><h5 id="33-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><a href="#33-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。" class="headerlink" title="33. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"></a>33. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h5><p>父类静态数据-&gt;子类静态数据-&gt;父类构造方法-&gt;子类构造方法-&gt;调用方法（子类）      </p><h5 id="34-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"><a href="#34-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。" class="headerlink" title="34. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"></a>34. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</h5><p>默认Object的equals方法，在比较两个对象的时候，是看他们是否指向同一个地址。<br>但是我们的需求是对象的某个属性相同，就相等了，我们要重写equals方法。<br>重写equals 方法就必须重写hashcode方法，否则就会降低map等集合的索引速度。        </p><h5 id="35-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"><a href="#35-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。" class="headerlink" title="35. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"></a>35. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</h5><p>关键字      类内部   本包   子类   外部包<br>public       √     √      √      √<br>protected    √     √      √      ×<br>default      √     √      ×      ×<br>private      √     ×      ×      ×            </p><h5 id="36-数组和链表数据结构描述，各自的时间复杂度。"><a href="#36-数组和链表数据结构描述，各自的时间复杂度。" class="headerlink" title="36. 数组和链表数据结构描述，各自的时间复杂度。"></a>36. 数组和链表数据结构描述，各自的时间复杂度。</h5><p>数组O(1) 链表O(n)         </p><h5 id="37-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。"><a href="#37-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。" class="headerlink" title="37. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。"></a>37. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</h5><p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。         </p><h5 id="38-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"><a href="#38-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。" class="headerlink" title="38. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"></a>38. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</h5><p>序列化是一种用来处理对象流的机制 ,所谓对象流就是将对象的内容进行流化。<br>序列化是为了解决在对对象流进行读写操作时所引发的问题。<br>序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，         </p><h5 id="39-java8的新特性。"><a href="#39-java8的新特性。" class="headerlink" title="39. java8的新特性。"></a>39. java8的新特性。</h5><p>1 Lambda表达式和函数式接口<br>2.2 接口的默认方法和静态方法<br>2.4 重复注解<br>4.1 Optional<br>4.2 Streams<br>4.3 Date/Time API(JSR 310)<br>4.5 Java 8 方法引用   </p><h5 id="40、静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？"><a href="#40、静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？" class="headerlink" title="40、静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？"></a>40、静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？</h5><p>静态嵌套类是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。<br>内部类需要在外部类实例化后才能实例化。      </p><h5 id="41、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？"><a href="#41、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？" class="headerlink" title="41、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？"></a>41、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？</h5><p>在Java 5以前，switch(expr)中，expr只能是byte、short、char、int；<br>从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型；<br>从Java 7开始，expr还可以是字符串（String），<br>但是长整型（long）在目前所有的版本中都是不可以的。  </p><h5 id="42、String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#42、String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="42、String s = new String(“xyz”);创建了几个字符串对象？"></a>42、String s = new String(“xyz”);创建了几个字符串对象？</h5><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。   </p><h5 id="43、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><a href="#43、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。" class="headerlink" title="43、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"></a>43、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h5><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;    <span class="hljs-keyword">static</span> &#123;        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;2&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">extends</span> <span class="hljs-title">A</span> &#123;    <span class="hljs-keyword">static</span> &#123;        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;a&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>)</span> &#123;        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;b&quot;</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;    A ab = <span class="hljs-keyword">new</span> B();    ab = <span class="hljs-keyword">new</span> B();&#125;</code></pre><p>执行结果：1a2b2b。<br>创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。     </p><h5 id="44、throw和throws的区别"><a href="#44、throw和throws的区别" class="headerlink" title="44、throw和throws的区别"></a>44、throw和throws的区别</h5><p>throw 则是指抛出的一个具体异常类型<br>throws 是用来声明一个方法可能抛出的所有异常信息          </p><h5 id="45、int和Integer有什么区别？谈谈Integer的值缓存范围"><a href="#45、int和Integer有什么区别？谈谈Integer的值缓存范围" class="headerlink" title="45、int和Integer有什么区别？谈谈Integer的值缓存范围"></a>45、int和Integer有什么区别？谈谈Integer的值缓存范围</h5><p>Integer是int对应的包装类。<br>装箱．将基本类型用它们对应的引用类型包装起来；<br>拆箱：将包装类型转换为基本数据类型；<br>在Java 5中，引入了自动装箱和自动拆箱功能（boxing/unboxing）。<br>关于Integer的值缓存， 这个值默认缓存是-128到127之间。   </p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;       <span class="hljs-type">Integer</span> a = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">3</span>);       <span class="hljs-type">Integer</span> b = <span class="hljs-number">3</span>;// 将<span class="hljs-number">3</span>自动装箱成<span class="hljs-type">Integer</span>类型       <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;       <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a == b); // <span class="hljs-keyword">false</span> 两个引用没有引用同一对象       <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a == c); // <span class="hljs-keyword">true</span>  a自动拆箱成<span class="hljs-type">int</span>类型再和c比较       <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(b == c); // <span class="hljs-keyword">true</span>  b自动拆箱成<span class="hljs-type">int</span>类型再和c比较&#125;</code></pre><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;    Integer f1=<span class="hljs-number">100</span>,f2=<span class="hljs-number">100</span>,f3=<span class="hljs-number">150</span>,f4=<span class="hljs-number">150</span>;    System.<span class="hljs-keyword">out</span>.println(f1==f2); <span class="hljs-comment">//true</span>    System.<span class="hljs-keyword">out</span>.println(f3==f4); <span class="hljs-comment">//false</span>&#125;</code></pre><p>如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，<br>所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。  </p><h5 id="46、Java有几种文件拷贝方式？哪一种最高效？"><a href="#46、Java有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="46、Java有几种文件拷贝方式？哪一种最高效？"></a>46、Java有几种文件拷贝方式？哪一种最高效？</h5><p>利用java.io类库，直接为源文件构建一个FileInputStream读取，然后再为目标文件构建一个FileOutputStream，完成写入工作。</p><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> copyFileByStream(<span class="hljs-keyword">File</span> <span class="hljs-keyword">source</span>, <span class="hljs-keyword">File</span> des) <span class="hljs-keyword">throws</span> IOException &#123;      <span class="hljs-keyword">try</span> (InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">source</span>);           OutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(des);) &#123;          <span class="hljs-keyword">byte</span>[] bufer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];          <span class="hljs-keyword">int</span> length;          <span class="hljs-keyword">while</span> ((length = is.<span class="hljs-keyword">read</span>(bufer)) &gt; <span class="hljs-number">0</span>) &#123;              os.<span class="hljs-keyword">write</span>(bufer, <span class="hljs-number">0</span>, length);          &#125;      &#125;  &#125;</code></pre><p>或者，利用java.nio类库提供的transferTo或transferFrom方法实现。  </p><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> copyFileByChannel(<span class="hljs-keyword">File</span> <span class="hljs-keyword">source</span>, <span class="hljs-keyword">File</span> des) <span class="hljs-keyword">throws</span> IOException &#123;       <span class="hljs-keyword">try</span> (FileChannel sourceChannel = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">source</span>)               .getChannel();            FileChannel targetChannel = <span class="hljs-keyword">new</span> FileOutputStream(des).getChannel                    ();) &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = sourceChannel.<span class="hljs-keyword">size</span>(); <span class="hljs-keyword">count</span> &gt; <span class="hljs-number">0</span>; ) &#123;               <span class="hljs-keyword">long</span> transferred = sourceChannel.transferTo(                       sourceChannel.position(), <span class="hljs-keyword">count</span>, targetChannel);               sourceChannel.position(sourceChannel.position() + transferred);               <span class="hljs-keyword">count</span> -= transferred;           &#125;       &#125;   &#125;</code></pre><p>又或者，Java标准类库本身已经提供了几种Files.copy的实现。<br>对于Copy的效率，总体上来说， NIO transferTo/From的方式可能更快，<br>因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换      </p><h5 id="47、类ExampleA继承Exception，类ExampleB继承ExampleA。"><a href="#47、类ExampleA继承Exception，类ExampleB继承ExampleA。" class="headerlink" title="47、类ExampleA继承Exception，类ExampleB继承ExampleA。"></a>47、类ExampleA继承Exception，类ExampleB继承ExampleA。</h5><pre><code class="hljs arduino"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExampleB(<span class="hljs-string">&quot;b&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (ExampleA e) &#123;    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;ExampleA&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Exception&quot;</span>);&#125;</code></pre><p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）</p><pre><code class="java">class A extends Exception &#123;&#125;class B extends A &#123;&#125;public class Test &#123;      public static void main(String[] args) &#123;            try &#123;                try &#123;                    throw new B();                &#125; catch (A a) &#123;                    System.out.println(&quot;Caught A&quot;);                    throw a;                &#125;            &#125;            catch (B b) &#123;                System.out.println(&quot;Caught B&quot;);                return;            &#125;            finally &#123;                System.out.println(&quot;Hello World!&quot;);            &#125;        &#125;      &#125;// Caught A// Caught B// Hello World!</code></pre><p>先执行try -&gt; 再执行finally -&gt; 最后执行return<br>如果finally有返回值会返回finally值<br>如果try抛出异常会执行catch代码块,再执行finally语句,catch代码块有return返回return值</p><h5 id="48、讲一下类加载机制"><a href="#48、讲一下类加载机制" class="headerlink" title="48、讲一下类加载机制"></a>48、讲一下类加载机制</h5><p>将我们编译好的.class文件加载到内存当中，将静态数据放进方法区内，并在堆中创建对象，<br>用来封装方法区中的数据结构，并提供了访问数据的入口<br>类的加载过程包括了加载、验证、准备、解析、初始化五个阶段。</p><h5 id="49、讲讲java字符串常量池"><a href="#49、讲讲java字符串常量池" class="headerlink" title="49、讲讲java字符串常量池"></a>49、讲讲java字符串常量池</h5><p>因为java中字符串是不可变对象，jvm在字符串池中仅保存一份字符串常量，用于优化内存分配。这个过程称为驻留（interning）。<br>通过直接赋值方式创建字符串变量，jvm在字符串池搜索相应的值。如果找到，java编译器简单返回该内存地址引用，无需额外分配内存。<br>没找到，字符串值被增加至字符串池中驻留，并返回其引用。</p><h5 id="50、Spring加载机制"><a href="#50、Spring加载机制" class="headerlink" title="50、Spring加载机制"></a>50、Spring加载机制</h5>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaGuide</title>
    <link href="/2020/03/30/2020-04-07-JavaGuide/"/>
    <url>/2020/03/30/2020-04-07-JavaGuide/</url>
    
    <content type="html"><![CDATA[<h5 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h5><h6 id="1-JAVA中的几种基本数据类型是什么，各自占用多少字节。"><a href="#1-JAVA中的几种基本数据类型是什么，各自占用多少字节。" class="headerlink" title="1. JAVA中的几种基本数据类型是什么，各自占用多少字节。"></a>1. JAVA中的几种基本数据类型是什么，各自占用多少字节。</h6><h6 id="2-String类能被继承吗，为什么。"><a href="#2-String类能被继承吗，为什么。" class="headerlink" title="2. String类能被继承吗，为什么。"></a>2. String类能被继承吗，为什么。</h6><h6 id="3-String，StringBuffer，StringBuilder的区别。"><a href="#3-String，StringBuffer，StringBuilder的区别。" class="headerlink" title="3. String，StringBuffer，StringBuilder的区别。"></a>3. String，StringBuffer，StringBuilder的区别。</h6><h6 id="4-ArrayList和LinkedList有什么区别。"><a href="#4-ArrayList和LinkedList有什么区别。" class="headerlink" title="4. ArrayList和LinkedList有什么区别。"></a>4. ArrayList和LinkedList有什么区别。</h6><h6 id="5-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><a href="#5-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。" class="headerlink" title="5. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"></a>5. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h6><h6 id="6-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"><a href="#6-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。" class="headerlink" title="6. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"></a>6. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</h6><h6 id="7-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"><a href="#7-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。" class="headerlink" title="7. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"></a>7. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</h6><h6 id="8-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"><a href="#8-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="8. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"></a>8. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</h6><h6 id="9-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><a href="#9-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。" class="headerlink" title="9. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。"></a>9. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</h6><h6 id="10-继承和聚合的区别在哪。"><a href="#10-继承和聚合的区别在哪。" class="headerlink" title="10. 继承和聚合的区别在哪。"></a>10. 继承和聚合的区别在哪。</h6><h6 id="11-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。"><a href="#11-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。" class="headerlink" title="11. IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。"></a>11. IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</h6><h6 id="12-反射的原理，反射创建类实例的三种方式是什么。"><a href="#12-反射的原理，反射创建类实例的三种方式是什么。" class="headerlink" title="12. 反射的原理，反射创建类实例的三种方式是什么。"></a>12. 反射的原理，反射创建类实例的三种方式是什么。</h6><h6 id="13-反射中，Class-forName和ClassLoader区别-。"><a href="#13-反射中，Class-forName和ClassLoader区别-。" class="headerlink" title="13. 反射中，Class.forName和ClassLoader区别 。"></a>13. 反射中，Class.forName和ClassLoader区别 。</h6><h6 id="14-描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#14-描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="14. 描述动态代理的几种实现方式，分别说出相应的优缺点。"></a>14. 描述动态代理的几种实现方式，分别说出相应的优缺点。</h6><h6 id="15-动态代理与cglib实现的区别。"><a href="#15-动态代理与cglib实现的区别。" class="headerlink" title="15. 动态代理与cglib实现的区别。"></a>15. 动态代理与cglib实现的区别。</h6><h6 id="16-为什么CGlib方式可以对接口实现代理。"><a href="#16-为什么CGlib方式可以对接口实现代理。" class="headerlink" title="16. 为什么CGlib方式可以对接口实现代理。"></a>16. 为什么CGlib方式可以对接口实现代理。</h6><h6 id="17-final的用途。"><a href="#17-final的用途。" class="headerlink" title="17. final的用途。"></a>17. final的用途。</h6><h6 id="18-写出三种单例模式实现-。"><a href="#18-写出三种单例模式实现-。" class="headerlink" title="18. 写出三种单例模式实现 。"></a>18. 写出三种单例模式实现 。</h6><h6 id="19-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"><a href="#19-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。" class="headerlink" title="19. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"></a>19. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</h6><h6 id="20-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"><a href="#20-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。" class="headerlink" title="20. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"></a>20. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</h6><h6 id="21-深拷贝和浅拷贝区别。"><a href="#21-深拷贝和浅拷贝区别。" class="headerlink" title="21. 深拷贝和浅拷贝区别。"></a>21. 深拷贝和浅拷贝区别。</h6><h6 id="22-数组和链表数据结构描述，各自的时间复杂度。"><a href="#22-数组和链表数据结构描述，各自的时间复杂度。" class="headerlink" title="22. 数组和链表数据结构描述，各自的时间复杂度。"></a>22. 数组和链表数据结构描述，各自的时间复杂度。</h6><h6 id="23-error和exception的区别，CheckedException，RuntimeException的区别。"><a href="#23-error和exception的区别，CheckedException，RuntimeException的区别。" class="headerlink" title="23. error和exception的区别，CheckedException，RuntimeException的区别。"></a>23. error和exception的区别，CheckedException，RuntimeException的区别。</h6><h6 id="24-请列出5个运行时异常。"><a href="#24-请列出5个运行时异常。" class="headerlink" title="24. 请列出5个运行时异常。"></a>24. 请列出5个运行时异常。</h6><h6 id="25-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。"><a href="#25-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。" class="headerlink" title="25. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。"></a>25. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</h6><h6 id="26-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"><a href="#26-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。" class="headerlink" title="26. 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"></a>26. 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。</h6><h6 id="27-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。"><a href="#27-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。" class="headerlink" title="27. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。"></a>27. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</h6><h6 id="28-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。"><a href="#28-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。" class="headerlink" title="28. 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。"></a>28. 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</h6><h6 id="29-有没有可能2个不相等的对象有相同的hashcode。"><a href="#29-有没有可能2个不相等的对象有相同的hashcode。" class="headerlink" title="29. 有没有可能2个不相等的对象有相同的hashcode。"></a>29. 有没有可能2个不相等的对象有相同的hashcode。</h6><h6 id="30-Java中的HashSet内部是如何工作的。"><a href="#30-Java中的HashSet内部是如何工作的。" class="headerlink" title="30. Java中的HashSet内部是如何工作的。"></a>30. Java中的HashSet内部是如何工作的。</h6><h6 id="31-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"><a href="#31-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。" class="headerlink" title="31. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"></a>31. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</h6><h6 id="32-java8的新特性。"><a href="#32-java8的新特性。" class="headerlink" title="32. java8的新特性。"></a>32. java8的新特性。</h6><h5 id="JVM知识"><a href="#JVM知识" class="headerlink" title="JVM知识"></a>JVM知识</h5><h6 id="1-什么情况下会发生栈内存溢出。"><a href="#1-什么情况下会发生栈内存溢出。" class="headerlink" title="1. 什么情况下会发生栈内存溢出。"></a>1. 什么情况下会发生栈内存溢出。</h6><h6 id="2-JVM的内存结构，Eden和Survivor比例。"><a href="#2-JVM的内存结构，Eden和Survivor比例。" class="headerlink" title="2. JVM的内存结构，Eden和Survivor比例。"></a>2. JVM的内存结构，Eden和Survivor比例。</h6><h6 id="3-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"><a href="#3-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。" class="headerlink" title="3. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"></a>3. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h6><h6 id="4-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"><a href="#4-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。" class="headerlink" title="4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"></a>4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。</h6><h6 id="5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h6><h6 id="6-垃圾回收算法的实现原理。"><a href="#6-垃圾回收算法的实现原理。" class="headerlink" title="6. 垃圾回收算法的实现原理。"></a>6. 垃圾回收算法的实现原理。</h6><h6 id="7-当出现了内存溢出，你怎么排错。"><a href="#7-当出现了内存溢出，你怎么排错。" class="headerlink" title="7. 当出现了内存溢出，你怎么排错。"></a>7. 当出现了内存溢出，你怎么排错。</h6><h6 id="8-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"><a href="#8-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。" class="headerlink" title="8. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"></a>8. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</h6><h6 id="9-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><a href="#9-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。" class="headerlink" title="9. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"></a>9. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h6><h6 id="10-讲讲JAVA的反射机制。"><a href="#10-讲讲JAVA的反射机制。" class="headerlink" title="10. 讲讲JAVA的反射机制。"></a>10. 讲讲JAVA的反射机制。</h6><h6 id="11-你们线上应用的JVM参数有哪些。"><a href="#11-你们线上应用的JVM参数有哪些。" class="headerlink" title="11. 你们线上应用的JVM参数有哪些。"></a>11. 你们线上应用的JVM参数有哪些。</h6><h6 id="12-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择。"><a href="#12-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择。" class="headerlink" title="12. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。"></a>12. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。</h6><h6 id="13-怎么打出线程栈信息。"><a href="#13-怎么打出线程栈信息。" class="headerlink" title="13. 怎么打出线程栈信息。"></a>13. 怎么打出线程栈信息。</h6><h6 id="14-请解释如下jvm参数的含义："><a href="#14-请解释如下jvm参数的含义：" class="headerlink" title="14. 请解释如下jvm参数的含义："></a>14. 请解释如下jvm参数的含义：</h6><h6 id="15-server-Xms512m-Xmx512m-Xss1024K"><a href="#15-server-Xms512m-Xmx512m-Xss1024K" class="headerlink" title="15. -server -Xms512m -Xmx512m -Xss1024K"></a>15. -server -Xms512m -Xmx512m -Xss1024K</h6><h6 id="16-XX-PermSize-256m-XX-MaxPermSize-512m"><a href="#16-XX-PermSize-256m-XX-MaxPermSize-512m" class="headerlink" title="16. -XX:PermSize=256m -XX:MaxPermSize=512m -"></a>16. -XX:PermSize=256m -XX:MaxPermSize=512m -</h6><h6 id="17-XX-MaxTenuringThreshold-20XX-CMSInitiatingOccupancyFraction-80"><a href="#17-XX-MaxTenuringThreshold-20XX-CMSInitiatingOccupancyFraction-80" class="headerlink" title="17. XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 -"></a>17. XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 -</h6><h6 id="18-XX-UseCMSInitiatingOccupancyOnly。"><a href="#18-XX-UseCMSInitiatingOccupancyOnly。" class="headerlink" title="18. XX:+UseCMSInitiatingOccupancyOnly。"></a>18. XX:+UseCMSInitiatingOccupancyOnly。</h6><h5 id="开源框架知识"><a href="#开源框架知识" class="headerlink" title="开源框架知识"></a>开源框架知识</h5><h6 id="1-简单讲讲tomcat结构，以及其类加载器流程，线程模型等。"><a href="#1-简单讲讲tomcat结构，以及其类加载器流程，线程模型等。" class="headerlink" title="1. 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。"></a>1. 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。</h6><h6 id="2-tomcat如何调优，涉及哪些参数-。"><a href="#2-tomcat如何调优，涉及哪些参数-。" class="headerlink" title="2. tomcat如何调优，涉及哪些参数 。"></a>2. tomcat如何调优，涉及哪些参数 。</h6><h6 id="3-讲讲Spring加载流程。"><a href="#3-讲讲Spring加载流程。" class="headerlink" title="3. 讲讲Spring加载流程。"></a>3. 讲讲Spring加载流程。</h6><h6 id="4-Spring-AOP的实现原理。"><a href="#4-Spring-AOP的实现原理。" class="headerlink" title="4. Spring AOP的实现原理。"></a>4. Spring AOP的实现原理。</h6><h6 id="5-讲讲Spring事务的传播属性。"><a href="#5-讲讲Spring事务的传播属性。" class="headerlink" title="5. 讲讲Spring事务的传播属性。"></a>5. 讲讲Spring事务的传播属性。</h6><h6 id="6-Spring如何管理事务的。"><a href="#6-Spring如何管理事务的。" class="headerlink" title="6. Spring如何管理事务的。"></a>6. Spring如何管理事务的。</h6><h6 id="7-Spring怎么配置事务（具体说出一些关键的xml-元素）。"><a href="#7-Spring怎么配置事务（具体说出一些关键的xml-元素）。" class="headerlink" title="7. Spring怎么配置事务（具体说出一些关键的xml 元素）。"></a>7. Spring怎么配置事务（具体说出一些关键的xml 元素）。</h6><h6 id="8-说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，"><a href="#8-说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，" class="headerlink" title="8. 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，"></a>8. 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，</h6><h6 id="9-说说aop中的几个术语，它们是怎么相互工作的。"><a href="#9-说说aop中的几个术语，它们是怎么相互工作的。" class="headerlink" title="9. 说说aop中的几个术语，它们是怎么相互工作的。"></a>9. 说说aop中的几个术语，它们是怎么相互工作的。</h6><h6 id="10-SpringMvc-中DispatcherServlet初始化过程。"><a href="#10-SpringMvc-中DispatcherServlet初始化过程。" class="headerlink" title="10. SpringMvc 中DispatcherServlet初始化过程。"></a>10. SpringMvc 中DispatcherServlet初始化过程。</h6><h6 id="11-netty的线程模型，netty如何基于reactor模型上实现的。"><a href="#11-netty的线程模型，netty如何基于reactor模型上实现的。" class="headerlink" title="11. netty的线程模型，netty如何基于reactor模型上实现的。"></a>11. netty的线程模型，netty如何基于reactor模型上实现的。</h6><h6 id="12-为什么选择netty。"><a href="#12-为什么选择netty。" class="headerlink" title="12. 为什么选择netty。"></a>12. 为什么选择netty。</h6><h6 id="13-什么是TCP粘包，拆包。解决方式是什么。"><a href="#13-什么是TCP粘包，拆包。解决方式是什么。" class="headerlink" title="13. 什么是TCP粘包，拆包。解决方式是什么。"></a>13. 什么是TCP粘包，拆包。解决方式是什么。</h6><h6 id="14-netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。"><a href="#14-netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。" class="headerlink" title="14. netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。"></a>14. netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。</h6><h6 id="15-netty的心跳处理在弱网下怎么办。"><a href="#15-netty的心跳处理在弱网下怎么办。" class="headerlink" title="15. netty的心跳处理在弱网下怎么办。"></a>15. netty的心跳处理在弱网下怎么办。</h6><h6 id="16-netty的通讯协议是什么样的。"><a href="#16-netty的通讯协议是什么样的。" class="headerlink" title="16. netty的通讯协议是什么样的。"></a>16. netty的通讯协议是什么样的。</h6><h6 id="17-springMvc用到的注解，作用是什么，原理。"><a href="#17-springMvc用到的注解，作用是什么，原理。" class="headerlink" title="17. springMvc用到的注解，作用是什么，原理。"></a>17. springMvc用到的注解，作用是什么，原理。</h6><h6 id="18-springboot启动机制。"><a href="#18-springboot启动机制。" class="headerlink" title="18. springboot启动机制。"></a>18. springboot启动机制。</h6><h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><h6 id="1-Linux系统下你关注过哪些内核参数，说说你知道的。"><a href="#1-Linux系统下你关注过哪些内核参数，说说你知道的。" class="headerlink" title="1. Linux系统下你关注过哪些内核参数，说说你知道的。"></a>1. Linux系统下你关注过哪些内核参数，说说你知道的。</h6><h6 id="2-Linux下IO模型有几种，各自的含义是什么。"><a href="#2-Linux下IO模型有几种，各自的含义是什么。" class="headerlink" title="2. Linux下IO模型有几种，各自的含义是什么。"></a>2. Linux下IO模型有几种，各自的含义是什么。</h6><h6 id="3-epoll和poll有什么区别。"><a href="#3-epoll和poll有什么区别。" class="headerlink" title="3. epoll和poll有什么区别。"></a>3. epoll和poll有什么区别。</h6><h6 id="4-平时用到哪些Linux命令。"><a href="#4-平时用到哪些Linux命令。" class="headerlink" title="4. 平时用到哪些Linux命令。"></a>4. 平时用到哪些Linux命令。</h6><h6 id="5-用一行命令查看文件的最后五行。"><a href="#5-用一行命令查看文件的最后五行。" class="headerlink" title="5. 用一行命令查看文件的最后五行。"></a>5. 用一行命令查看文件的最后五行。</h6><h6 id="6-用一行命令输出正在运行的java进程。"><a href="#6-用一行命令输出正在运行的java进程。" class="headerlink" title="6. 用一行命令输出正在运行的java进程。"></a>6. 用一行命令输出正在运行的java进程。</h6><h6 id="7-介绍下你理解的操作系统中线程切换过程。"><a href="#7-介绍下你理解的操作系统中线程切换过程。" class="headerlink" title="7. 介绍下你理解的操作系统中线程切换过程。"></a>7. 介绍下你理解的操作系统中线程切换过程。</h6><h6 id="8-进程和线程的区别。"><a href="#8-进程和线程的区别。" class="headerlink" title="8. 进程和线程的区别。"></a>8. 进程和线程的区别。</h6><h6 id="9-top-命令之后有哪些内容，有什么作用。"><a href="#9-top-命令之后有哪些内容，有什么作用。" class="headerlink" title="9. top 命令之后有哪些内容，有什么作用。"></a>9. top 命令之后有哪些内容，有什么作用。</h6><h6 id="10-线上CPU爆高，请问你如何找到问题所在。"><a href="#10-线上CPU爆高，请问你如何找到问题所在。" class="headerlink" title="10. 线上CPU爆高，请问你如何找到问题所在。"></a>10. 线上CPU爆高，请问你如何找到问题所在。</h6><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><h6 id="1-多线程的几种实现方式，什么是线程安全。"><a href="#1-多线程的几种实现方式，什么是线程安全。" class="headerlink" title="1. 多线程的几种实现方式，什么是线程安全。"></a>1. 多线程的几种实现方式，什么是线程安全。</h6><h6 id="2-volatile的原理，作用，能代替锁么。"><a href="#2-volatile的原理，作用，能代替锁么。" class="headerlink" title="2. volatile的原理，作用，能代替锁么。"></a>2. volatile的原理，作用，能代替锁么。</h6><h6 id="3-画一个线程的生命周期状态图。"><a href="#3-画一个线程的生命周期状态图。" class="headerlink" title="3. 画一个线程的生命周期状态图。"></a>3. 画一个线程的生命周期状态图。</h6><h6 id="4-sleep和wait的区别。"><a href="#4-sleep和wait的区别。" class="headerlink" title="4. sleep和wait的区别。"></a>4. sleep和wait的区别。</h6><h6 id="5-sleep和sleep-0-的区别。"><a href="#5-sleep和sleep-0-的区别。" class="headerlink" title="5. sleep和sleep(0)的区别。"></a>5. sleep和sleep(0)的区别。</h6><h6 id="6-Lock与Synchronized的区别-。"><a href="#6-Lock与Synchronized的区别-。" class="headerlink" title="6. Lock与Synchronized的区别 。"></a>6. Lock与Synchronized的区别 。</h6><h6 id="7-synchronized的原理是什么，一般用在什么地方-比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗-，"><a href="#7-synchronized的原理是什么，一般用在什么地方-比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗-，" class="headerlink" title="7. synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)，"></a>7. synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)，</h6><h6 id="8-解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。"><a href="#8-解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。" class="headerlink" title="8. 解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。"></a>8. 解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。</h6><h6 id="9-用过哪些原子类，他们的原理是什么。"><a href="#9-用过哪些原子类，他们的原理是什么。" class="headerlink" title="9. 用过哪些原子类，他们的原理是什么。"></a>9. 用过哪些原子类，他们的原理是什么。</h6><h6 id="10-JUC下研究过哪些并发工具，讲讲原理。"><a href="#10-JUC下研究过哪些并发工具，讲讲原理。" class="headerlink" title="10. JUC下研究过哪些并发工具，讲讲原理。"></a>10. JUC下研究过哪些并发工具，讲讲原理。</h6><h6 id="11-用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。"><a href="#11-用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。" class="headerlink" title="11. 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。"></a>11. 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。</h6><h6 id="12-线程池的关闭方式有几种，各自的区别是什么。"><a href="#12-线程池的关闭方式有几种，各自的区别是什么。" class="headerlink" title="12. 线程池的关闭方式有几种，各自的区别是什么。"></a>12. 线程池的关闭方式有几种，各自的区别是什么。</h6><h6 id="13-假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。"><a href="#13-假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。" class="headerlink" title="13. 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。"></a>13. 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。</h6><h6 id="14-spring的controller是单例还是多例，怎么保证并发的安全。"><a href="#14-spring的controller是单例还是多例，怎么保证并发的安全。" class="headerlink" title="14. spring的controller是单例还是多例，怎么保证并发的安全。"></a>14. spring的controller是单例还是多例，怎么保证并发的安全。</h6><h6 id="15-用三个线程按顺序循环打印abc三个字母，比如abcabcabc。"><a href="#15-用三个线程按顺序循环打印abc三个字母，比如abcabcabc。" class="headerlink" title="15. 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。"></a>15. 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。</h6><h6 id="16-ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。"><a href="#16-ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。" class="headerlink" title="16. ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。"></a>16. ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。</h6><h6 id="17-如果让你实现一个并发安全的链表，你会怎么做。"><a href="#17-如果让你实现一个并发安全的链表，你会怎么做。" class="headerlink" title="17. 如果让你实现一个并发安全的链表，你会怎么做。"></a>17. 如果让你实现一个并发安全的链表，你会怎么做。</h6><h6 id="18-有哪些无锁数据结构，他们实现的原理是什么。"><a href="#18-有哪些无锁数据结构，他们实现的原理是什么。" class="headerlink" title="18. 有哪些无锁数据结构，他们实现的原理是什么。"></a>18. 有哪些无锁数据结构，他们实现的原理是什么。</h6><h6 id="19-讲讲java同步机制的wait和notify。"><a href="#19-讲讲java同步机制的wait和notify。" class="headerlink" title="19. 讲讲java同步机制的wait和notify。"></a>19. 讲讲java同步机制的wait和notify。</h6><h6 id="20-CAS机制是什么，如何解决ABA问题。"><a href="#20-CAS机制是什么，如何解决ABA问题。" class="headerlink" title="20. CAS机制是什么，如何解决ABA问题。"></a>20. CAS机制是什么，如何解决ABA问题。</h6><h6 id="21-多线程如果线程挂住了怎么办。"><a href="#21-多线程如果线程挂住了怎么办。" class="headerlink" title="21. 多线程如果线程挂住了怎么办。"></a>21. 多线程如果线程挂住了怎么办。</h6><h6 id="22-countDowLatch和cyclicbarrier的内部原理和用法，以及相互之间的差别-比如countDowLatch的await方法和是怎么实现的-。"><a href="#22-countDowLatch和cyclicbarrier的内部原理和用法，以及相互之间的差别-比如countDowLatch的await方法和是怎么实现的-。" class="headerlink" title="22. countDowLatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countDowLatch的await方法和是怎么实现的)。"></a>22. countDowLatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countDowLatch的await方法和是怎么实现的)。</h6><h6 id="23-对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。"><a href="#23-对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。" class="headerlink" title="23. 对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。"></a>23. 对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。</h6><h6 id="24-使用synchronized修饰静态方法和非静态方法有什么区别。"><a href="#24-使用synchronized修饰静态方法和非静态方法有什么区别。" class="headerlink" title="24. 使用synchronized修饰静态方法和非静态方法有什么区别。"></a>24. 使用synchronized修饰静态方法和非静态方法有什么区别。</h6><h6 id="25-简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。"><a href="#25-简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。" class="headerlink" title="25. 简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。"></a>25. 简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。</h6><h6 id="26-导致线程死锁的原因？怎么解除线程死锁。"><a href="#26-导致线程死锁的原因？怎么解除线程死锁。" class="headerlink" title="26. 导致线程死锁的原因？怎么解除线程死锁。"></a>26. 导致线程死锁的原因？怎么解除线程死锁。</h6><h6 id="27-非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。"><a href="#27-非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。" class="headerlink" title="27. 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。"></a>27. 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。</h6><h6 id="28-用过读写锁吗，原理是什么，一般在什么场景下用。"><a href="#28-用过读写锁吗，原理是什么，一般在什么场景下用。" class="headerlink" title="28. 用过读写锁吗，原理是什么，一般在什么场景下用。"></a>28. 用过读写锁吗，原理是什么，一般在什么场景下用。</h6><h6 id="29-开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。"><a href="#29-开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。" class="headerlink" title="29. 开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。"></a>29. 开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。</h6><h6 id="30-延迟队列的实现方式，delayQueue和时间轮算法的异同。"><a href="#30-延迟队列的实现方式，delayQueue和时间轮算法的异同。" class="headerlink" title="30. 延迟队列的实现方式，delayQueue和时间轮算法的异同。"></a>30. 延迟队列的实现方式，delayQueue和时间轮算法的异同。</h6><h5 id="TCP与HTTP"><a href="#TCP与HTTP" class="headerlink" title="TCP与HTTP"></a>TCP与HTTP</h5><h6 id="1-http1-0和http1-1有什么区别。"><a href="#1-http1-0和http1-1有什么区别。" class="headerlink" title="1. http1.0和http1.1有什么区别。"></a>1. http1.0和http1.1有什么区别。</h6><h6 id="2-TCP三次握手和四次挥手的流程，为什么断开连接要4次-如果握手只有两次，会出现什么。"><a href="#2-TCP三次握手和四次挥手的流程，为什么断开连接要4次-如果握手只有两次，会出现什么。" class="headerlink" title="2. TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。"></a>2. TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。</h6><h6 id="3-TIME-WAIT和CLOSE-WAIT的区别。"><a href="#3-TIME-WAIT和CLOSE-WAIT的区别。" class="headerlink" title="3. TIME_WAIT和CLOSE_WAIT的区别。"></a>3. TIME_WAIT和CLOSE_WAIT的区别。</h6><h6 id="4-说说你知道的几种HTTP响应码，比如200-302-404。"><a href="#4-说说你知道的几种HTTP响应码，比如200-302-404。" class="headerlink" title="4. 说说你知道的几种HTTP响应码，比如200, 302, 404。"></a>4. 说说你知道的几种HTTP响应码，比如200, 302, 404。</h6><h6 id="5-当你用浏览器打开一个链接（如：http-www-javastack-cn）的时候，计算机做了哪些工作步骤。"><a href="#5-当你用浏览器打开一个链接（如：http-www-javastack-cn）的时候，计算机做了哪些工作步骤。" class="headerlink" title="5. 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。"></a>5. 当你用浏览器打开一个链接（如：<a href="http://www.javastack.cn)的时候,计算机做了哪些工作步骤./">http://www.javastack.cn）的时候，计算机做了哪些工作步骤。</a></h6><h6 id="6-TCP-IP如何保证可靠性，说说TCP头的结构。"><a href="#6-TCP-IP如何保证可靠性，说说TCP头的结构。" class="headerlink" title="6. TCP/IP如何保证可靠性，说说TCP头的结构。"></a>6. TCP/IP如何保证可靠性，说说TCP头的结构。</h6><h6 id="7-如何避免浏览器缓存。"><a href="#7-如何避免浏览器缓存。" class="headerlink" title="7. 如何避免浏览器缓存。"></a>7. 如何避免浏览器缓存。</h6><h6 id="8-如何理解HTTP协议的无状态性。"><a href="#8-如何理解HTTP协议的无状态性。" class="headerlink" title="8. 如何理解HTTP协议的无状态性。"></a>8. 如何理解HTTP协议的无状态性。</h6><h6 id="9-简述Http请求get和post的区别以及数据包格式。"><a href="#9-简述Http请求get和post的区别以及数据包格式。" class="headerlink" title="9. 简述Http请求get和post的区别以及数据包格式。"></a>9. 简述Http请求get和post的区别以及数据包格式。</h6><h6 id="10-HTTP有哪些method"><a href="#10-HTTP有哪些method" class="headerlink" title="10. HTTP有哪些method"></a>10. HTTP有哪些method</h6><h6 id="11-简述HTTP请求的报文格式。"><a href="#11-简述HTTP请求的报文格式。" class="headerlink" title="11. 简述HTTP请求的报文格式。"></a>11. 简述HTTP请求的报文格式。</h6><h6 id="12-HTTP的长连接是什么意思。"><a href="#12-HTTP的长连接是什么意思。" class="headerlink" title="12. HTTP的长连接是什么意思。"></a>12. HTTP的长连接是什么意思。</h6><h6 id="13-HTTPS的加密方式是什么，讲讲整个加密解密流程。"><a href="#13-HTTPS的加密方式是什么，讲讲整个加密解密流程。" class="headerlink" title="13. HTTPS的加密方式是什么，讲讲整个加密解密流程。"></a>13. HTTPS的加密方式是什么，讲讲整个加密解密流程。</h6><h6 id="14-Http和https的三次握手有什么区别。"><a href="#14-Http和https的三次握手有什么区别。" class="headerlink" title="14. Http和https的三次握手有什么区别。"></a>14. Http和https的三次握手有什么区别。</h6><h6 id="15-什么是分块传送。"><a href="#15-什么是分块传送。" class="headerlink" title="15. 什么是分块传送。"></a>15. 什么是分块传送。</h6><h6 id="16-Session和cookie的区别。"><a href="#16-Session和cookie的区别。" class="headerlink" title="16. Session和cookie的区别。"></a>16. Session和cookie的区别。</h6><h5 id="架构设计与分布式"><a href="#架构设计与分布式" class="headerlink" title="架构设计与分布式"></a>架构设计与分布式</h5><h6 id="1-用java自己实现一个LRU。"><a href="#1-用java自己实现一个LRU。" class="headerlink" title="1. 用java自己实现一个LRU。"></a>1. 用java自己实现一个LRU。</h6><h6 id="2-分布式集群下如何做到唯一序列号。"><a href="#2-分布式集群下如何做到唯一序列号。" class="headerlink" title="2. 分布式集群下如何做到唯一序列号。"></a>2. 分布式集群下如何做到唯一序列号。</h6><h6 id="3-设计一个秒杀系统，30分钟没付款就自动关闭交易。"><a href="#3-设计一个秒杀系统，30分钟没付款就自动关闭交易。" class="headerlink" title="3. 设计一个秒杀系统，30分钟没付款就自动关闭交易。"></a>3. 设计一个秒杀系统，30分钟没付款就自动关闭交易。</h6><h6 id="4-如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）"><a href="#4-如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）" class="headerlink" title="4. 如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）"></a>4. 如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）</h6><h6 id="5-如果有人恶意创建非法连接，怎么解决。"><a href="#5-如果有人恶意创建非法连接，怎么解决。" class="headerlink" title="5. 如果有人恶意创建非法连接，怎么解决。"></a>5. 如果有人恶意创建非法连接，怎么解决。</h6><h6 id="6-分布式事务的原理，优缺点，如何使用分布式事务，2pc-3pc-的区别，解决了哪些问题，还有"><a href="#6-分布式事务的原理，优缺点，如何使用分布式事务，2pc-3pc-的区别，解决了哪些问题，还有" class="headerlink" title="6. 分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有"></a>6. 分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有</h6><h6 id="7-哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。"><a href="#7-哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。" class="headerlink" title="7. 哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。"></a>7. 哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。</h6><h6 id="8-什么是一致性hash。"><a href="#8-什么是一致性hash。" class="headerlink" title="8. 什么是一致性hash。"></a>8. 什么是一致性hash。</h6><h6 id="9-什么是restful，讲讲你理解的restful。"><a href="#9-什么是restful，讲讲你理解的restful。" class="headerlink" title="9. 什么是restful，讲讲你理解的restful。"></a>9. 什么是restful，讲讲你理解的restful。</h6><h6 id="10-如何设计一个良好的API。"><a href="#10-如何设计一个良好的API。" class="headerlink" title="10. 如何设计一个良好的API。"></a>10. 如何设计一个良好的API。</h6><h6 id="11-如何设计建立和保持100w的长连接。"><a href="#11-如何设计建立和保持100w的长连接。" class="headerlink" title="11. 如何设计建立和保持100w的长连接。"></a>11. 如何设计建立和保持100w的长连接。</h6><h6 id="12-解释什么是MESI协议-缓存一致性-。"><a href="#12-解释什么是MESI协议-缓存一致性-。" class="headerlink" title="12. 解释什么是MESI协议(缓存一致性)。"></a>12. 解释什么是MESI协议(缓存一致性)。</h6><h6 id="13-说说你知道的几种HASH算法，简单的也可以。"><a href="#13-说说你知道的几种HASH算法，简单的也可以。" class="headerlink" title="13. 说说你知道的几种HASH算法，简单的也可以。"></a>13. 说说你知道的几种HASH算法，简单的也可以。</h6><h6 id="14-什么是paxos算法，-什么是zab协议。"><a href="#14-什么是paxos算法，-什么是zab协议。" class="headerlink" title="14. 什么是paxos算法， 什么是zab协议。"></a>14. 什么是paxos算法， 什么是zab协议。</h6><h6 id="15-一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。"><a href="#15-一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。" class="headerlink" title="15. 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。"></a>15. 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。</h6><h6 id="16-线上系统突然变得异常缓慢，你如何查找问题。"><a href="#16-线上系统突然变得异常缓慢，你如何查找问题。" class="headerlink" title="16. 线上系统突然变得异常缓慢，你如何查找问题。"></a>16. 线上系统突然变得异常缓慢，你如何查找问题。</h6><h6 id="17-说说你平时用到的设计模式。"><a href="#17-说说你平时用到的设计模式。" class="headerlink" title="17. 说说你平时用到的设计模式。"></a>17. 说说你平时用到的设计模式。</h6><h6 id="18-Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册"><a href="#18-Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册" class="headerlink" title="18. Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册"></a>18. Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册</h6><h6 id="19-和发现，重试转发，快速失败的策略是怎样的-。"><a href="#19-和发现，重试转发，快速失败的策略是怎样的-。" class="headerlink" title="19. 和发现，重试转发，快速失败的策略是怎样的 。"></a>19. 和发现，重试转发，快速失败的策略是怎样的 。</h6><h6 id="20-一次RPC请求的流程是什么。"><a href="#20-一次RPC请求的流程是什么。" class="headerlink" title="20. 一次RPC请求的流程是什么。"></a>20. 一次RPC请求的流程是什么。</h6><h6 id="21-自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。"><a href="#21-自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。" class="headerlink" title="21. 自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。"></a>21. 自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。</h6><h6 id="22-异步模式的用途和意义。"><a href="#22-异步模式的用途和意义。" class="headerlink" title="22. 异步模式的用途和意义。"></a>22. 异步模式的用途和意义。</h6><h6 id="23-编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。"><a href="#23-编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。" class="headerlink" title="23. 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。"></a>23. 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。</h6><h6 id="24-设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。-画一下架构图。"><a href="#24-设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。-画一下架构图。" class="headerlink" title="24. 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。"></a>24. 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。</h6><h6 id="25-MVC模式，即常见的MVC框架。"><a href="#25-MVC模式，即常见的MVC框架。" class="headerlink" title="25. MVC模式，即常见的MVC框架。"></a>25. MVC模式，即常见的MVC框架。</h6><h6 id="26-聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。"><a href="#26-聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。" class="headerlink" title="26. 聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。"></a>26. 聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。</h6><h6 id="27-应用服务器怎么监控性能，各种方式的区别。"><a href="#27-应用服务器怎么监控性能，各种方式的区别。" class="headerlink" title="27. 应用服务器怎么监控性能，各种方式的区别。"></a>27. 应用服务器怎么监控性能，各种方式的区别。</h6><h6 id="28-如何设计一套高并发支付方案，架构如何设计。"><a href="#28-如何设计一套高并发支付方案，架构如何设计。" class="headerlink" title="28. 如何设计一套高并发支付方案，架构如何设计。"></a>28. 如何设计一套高并发支付方案，架构如何设计。</h6><h6 id="29-如何实现负载均衡，有哪些算法可以实现。"><a href="#29-如何实现负载均衡，有哪些算法可以实现。" class="headerlink" title="29. 如何实现负载均衡，有哪些算法可以实现。"></a>29. 如何实现负载均衡，有哪些算法可以实现。</h6><h6 id="30-Zookeeper的用途，选举的原理是什么。"><a href="#30-Zookeeper的用途，选举的原理是什么。" class="headerlink" title="30. Zookeeper的用途，选举的原理是什么。"></a>30. Zookeeper的用途，选举的原理是什么。</h6><h6 id="31-Zookeeper-watch机制原理。"><a href="#31-Zookeeper-watch机制原理。" class="headerlink" title="31. Zookeeper watch机制原理。"></a>31. Zookeeper watch机制原理。</h6><h6 id="32-Mybatis的底层实现原理。"><a href="#32-Mybatis的底层实现原理。" class="headerlink" title="32. Mybatis的底层实现原理。"></a>32. Mybatis的底层实现原理。</h6><h6 id="33-请思考一个方案，实现分布式环境下的countDownLatch。"><a href="#33-请思考一个方案，实现分布式环境下的countDownLatch。" class="headerlink" title="33. 请思考一个方案，实现分布式环境下的countDownLatch。"></a>33. 请思考一个方案，实现分布式环境下的countDownLatch。</h6><h6 id="34-后台系统怎么防止请求重复提交。"><a href="#34-后台系统怎么防止请求重复提交。" class="headerlink" title="34. 后台系统怎么防止请求重复提交。"></a>34. 后台系统怎么防止请求重复提交。</h6><h6 id="35-描述一个服务从发布到被消费的详细过程。"><a href="#35-描述一个服务从发布到被消费的详细过程。" class="headerlink" title="35. 描述一个服务从发布到被消费的详细过程。"></a>35. 描述一个服务从发布到被消费的详细过程。</h6><h6 id="36-讲讲你理解的服务治理。"><a href="#36-讲讲你理解的服务治理。" class="headerlink" title="36. 讲讲你理解的服务治理。"></a>36. 讲讲你理解的服务治理。</h6><h6 id="37-如何做到接口的幂等性。"><a href="#37-如何做到接口的幂等性。" class="headerlink" title="37. 如何做到接口的幂等性。"></a>37. 如何做到接口的幂等性。</h6><h6 id="38-如何做限流策略，令牌桶和漏斗算法的使用场景。"><a href="#38-如何做限流策略，令牌桶和漏斗算法的使用场景。" class="headerlink" title="38. 如何做限流策略，令牌桶和漏斗算法的使用场景。"></a>38. 如何做限流策略，令牌桶和漏斗算法的使用场景。</h6><h6 id="39-什么叫数据一致性，你怎么理解数据一致性。"><a href="#39-什么叫数据一致性，你怎么理解数据一致性。" class="headerlink" title="39. 什么叫数据一致性，你怎么理解数据一致性。"></a>39. 什么叫数据一致性，你怎么理解数据一致性。</h6><h6 id="40-分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求"><a href="#40-分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求" class="headerlink" title="40. 分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求"></a>40. 分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求</h6><h6 id="41-的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎么做到最小的资源浪费，流量半开的实现机制是什么。"><a href="#41-的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎么做到最小的资源浪费，流量半开的实现机制是什么。" class="headerlink" title="41. 的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎么做到最小的资源浪费，流量半开的实现机制是什么。"></a>41. 的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎么做到最小的资源浪费，流量半开的实现机制是什么。</h6><h6 id="42-dubbo的泛化调用怎么实现的，如果是你，你会怎么做。"><a href="#42-dubbo的泛化调用怎么实现的，如果是你，你会怎么做。" class="headerlink" title="42. dubbo的泛化调用怎么实现的，如果是你，你会怎么做。"></a>42. dubbo的泛化调用怎么实现的，如果是你，你会怎么做。</h6><h6 id="43-远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。"><a href="#43-远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。" class="headerlink" title="43. 远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。"></a>43. 远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。</h6><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><h6 id="1-10亿个数字里里面找最小的10个。"><a href="#1-10亿个数字里里面找最小的10个。" class="headerlink" title="1. 10亿个数字里里面找最小的10个。"></a>1. 10亿个数字里里面找最小的10个。</h6><h6 id="2-有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。"><a href="#2-有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。" class="headerlink" title="2. 有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。"></a>2. 有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。</h6><h6 id="3-2亿个随机生成的无序整数-找出中间大小的值。"><a href="#3-2亿个随机生成的无序整数-找出中间大小的值。" class="headerlink" title="3. 2亿个随机生成的无序整数,找出中间大小的值。"></a>3. 2亿个随机生成的无序整数,找出中间大小的值。</h6><h6 id="4-给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。"><a href="#4-给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。" class="headerlink" title="4. 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。"></a>4. 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。</h6><h6 id="5-遍历二叉树。"><a href="#5-遍历二叉树。" class="headerlink" title="5. 遍历二叉树。"></a>5. 遍历二叉树。</h6><h6 id="6-有3n-1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。"><a href="#6-有3n-1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。" class="headerlink" title="6. 有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。"></a>6. 有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。</h6><h6 id="7-写一个字符串（如：www-javastack-cn）反转函数。"><a href="#7-写一个字符串（如：www-javastack-cn）反转函数。" class="headerlink" title="7. 写一个字符串（如：www.javastack.cn）反转函数。"></a>7. 写一个字符串（如：<a href="http://www.javastack.cn)反转函数./">www.javastack.cn）反转函数。</a></h6><h6 id="8-常用的排序算法，快排，归并、冒泡。-快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。"><a href="#8-常用的排序算法，快排，归并、冒泡。-快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。" class="headerlink" title="8. 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。"></a>8. 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。</h6><h6 id="9-二分查找的时间复杂度，优势。"><a href="#9-二分查找的时间复杂度，优势。" class="headerlink" title="9. 二分查找的时间复杂度，优势。"></a>9. 二分查找的时间复杂度，优势。</h6><h6 id="10-一个已经构建好的TreeSet，怎么完成倒排序。"><a href="#10-一个已经构建好的TreeSet，怎么完成倒排序。" class="headerlink" title="10. 一个已经构建好的TreeSet，怎么完成倒排序。"></a>10. 一个已经构建好的TreeSet，怎么完成倒排序。</h6><h6 id="11-什么是B-树，B-树，列出实际的使用场景。"><a href="#11-什么是B-树，B-树，列出实际的使用场景。" class="headerlink" title="11. 什么是B+树，B-树，列出实际的使用场景。"></a>11. 什么是B+树，B-树，列出实际的使用场景。</h6><h6 id="12-一个单向链表，删除倒数第N个数据。"><a href="#12-一个单向链表，删除倒数第N个数据。" class="headerlink" title="12. 一个单向链表，删除倒数第N个数据。"></a>12. 一个单向链表，删除倒数第N个数据。</h6><h6 id="13-200个有序的数组，每个数组里面100个元素，找出top20的元素。"><a href="#13-200个有序的数组，每个数组里面100个元素，找出top20的元素。" class="headerlink" title="13. 200个有序的数组，每个数组里面100个元素，找出top20的元素。"></a>13. 200个有序的数组，每个数组里面100个元素，找出top20的元素。</h6><h6 id="14-单向链表，查找中间的那个元素。"><a href="#14-单向链表，查找中间的那个元素。" class="headerlink" title="14. 单向链表，查找中间的那个元素。"></a>14. 单向链表，查找中间的那个元素。</h6><h5 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h5><h6 id="1-数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。"><a href="#1-数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。" class="headerlink" title="1. 数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。"></a>1. 数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。</h6><h6 id="2-什么是幻读。"><a href="#2-什么是幻读。" class="headerlink" title="2. 什么是幻读。"></a>2. 什么是幻读。</h6><h6 id="3-MYSQL有哪些存储引擎，各自优缺点。"><a href="#3-MYSQL有哪些存储引擎，各自优缺点。" class="headerlink" title="3. MYSQL有哪些存储引擎，各自优缺点。"></a>3. MYSQL有哪些存储引擎，各自优缺点。</h6><h6 id="4-高并发下，如何做到安全的修改同一行数据。"><a href="#4-高并发下，如何做到安全的修改同一行数据。" class="headerlink" title="4. 高并发下，如何做到安全的修改同一行数据。"></a>4. 高并发下，如何做到安全的修改同一行数据。</h6><h6 id="5-乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。"><a href="#5-乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。" class="headerlink" title="5. 乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。"></a>5. 乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。</h6><h6 id="6-SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。"><a href="#6-SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。" class="headerlink" title="6. SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。"></a>6. SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。</h6><h6 id="7-数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。"><a href="#7-数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。" class="headerlink" title="7. 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。"></a>7. 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。</h6><h6 id="8-MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。"><a href="#8-MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。" class="headerlink" title="8. MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。"></a>8. MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。</h6><h6 id="9-聚集索引和非聚集索引的区别。"><a href="#9-聚集索引和非聚集索引的区别。" class="headerlink" title="9. 聚集索引和非聚集索引的区别。"></a>9. 聚集索引和非聚集索引的区别。</h6><h6 id="10-select-for-update-是什么含义，会锁表还是锁行或是其他。"><a href="#10-select-for-update-是什么含义，会锁表还是锁行或是其他。" class="headerlink" title="10. select for update 是什么含义，会锁表还是锁行或是其他。"></a>10. select for update 是什么含义，会锁表还是锁行或是其他。</h6><h6 id="11-为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。"><a href="#11-为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。" class="headerlink" title="11. 为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。"></a>11. 为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。</h6><h6 id="12-数据库的ACID是什么。"><a href="#12-数据库的ACID是什么。" class="headerlink" title="12. 数据库的ACID是什么。"></a>12. 数据库的ACID是什么。</h6><h6 id="13-某个表有近千万数据，CRUD比较慢，如何优化。"><a href="#13-某个表有近千万数据，CRUD比较慢，如何优化。" class="headerlink" title="13. 某个表有近千万数据，CRUD比较慢，如何优化。"></a>13. 某个表有近千万数据，CRUD比较慢，如何优化。</h6><h6 id="14-Mysql怎么优化table-scan的。"><a href="#14-Mysql怎么优化table-scan的。" class="headerlink" title="14. Mysql怎么优化table scan的。"></a>14. Mysql怎么优化table scan的。</h6><h6 id="15-如何写sql能够有效的使用到复合索引。"><a href="#15-如何写sql能够有效的使用到复合索引。" class="headerlink" title="15. 如何写sql能够有效的使用到复合索引。"></a>15. 如何写sql能够有效的使用到复合索引。</h6><h6 id="16-mysql中in-和exists-区别。"><a href="#16-mysql中in-和exists-区别。" class="headerlink" title="16. mysql中in 和exists 区别。"></a>16. mysql中in 和exists 区别。</h6><h6 id="17-数据库自增主键可能的问题。"><a href="#17-数据库自增主键可能的问题。" class="headerlink" title="17. 数据库自增主键可能的问题。"></a>17. 数据库自增主键可能的问题。</h6><h6 id="18-MVCC的含义，如何实现的。"><a href="#18-MVCC的含义，如何实现的。" class="headerlink" title="18. MVCC的含义，如何实现的。"></a>18. MVCC的含义，如何实现的。</h6><h6 id="19-你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding-jdbc等-他们的原理知道么。"><a href="#19-你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding-jdbc等-他们的原理知道么。" class="headerlink" title="19. 你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他们的原理知道么。"></a>19. 你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他们的原理知道么。</h6><h6 id="20-MYSQL的主从延迟怎么解决。"><a href="#20-MYSQL的主从延迟怎么解决。" class="headerlink" title="20. MYSQL的主从延迟怎么解决。"></a>20. MYSQL的主从延迟怎么解决。</h6><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><h6 id="1-消息队列的使用场景。"><a href="#1-消息队列的使用场景。" class="headerlink" title="1. 消息队列的使用场景。"></a>1. 消息队列的使用场景。</h6><h6 id="2-消息的重发，补充策略。"><a href="#2-消息的重发，补充策略。" class="headerlink" title="2. 消息的重发，补充策略。"></a>2. 消息的重发，补充策略。</h6><h6 id="3-如何保证消息的有序性。"><a href="#3-如何保证消息的有序性。" class="headerlink" title="3. 如何保证消息的有序性。"></a>3. 如何保证消息的有序性。</h6><h6 id="4-用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。"><a href="#4-用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。" class="headerlink" title="4. 用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。"></a>4. 用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。</h6><h6 id="5-MQ系统的数据如何保证不丢失。"><a href="#5-MQ系统的数据如何保证不丢失。" class="headerlink" title="5. MQ系统的数据如何保证不丢失。"></a>5. MQ系统的数据如何保证不丢失。</h6><h6 id="6-rabbitmq如何实现集群高可用。"><a href="#6-rabbitmq如何实现集群高可用。" class="headerlink" title="6. rabbitmq如何实现集群高可用。"></a>6. rabbitmq如何实现集群高可用。</h6><h6 id="7-kafka吞吐量高的原因。"><a href="#7-kafka吞吐量高的原因。" class="headerlink" title="7. kafka吞吐量高的原因。"></a>7. kafka吞吐量高的原因。</h6><h6 id="8-kafka-和其他消息队列的区别，kafka-主从同步怎么实现。"><a href="#8-kafka-和其他消息队列的区别，kafka-主从同步怎么实现。" class="headerlink" title="8. kafka 和其他消息队列的区别，kafka 主从同步怎么实现。"></a>8. kafka 和其他消息队列的区别，kafka 主从同步怎么实现。</h6><h6 id="9-利用mq怎么实现最终一致性。"><a href="#9-利用mq怎么实现最终一致性。" class="headerlink" title="9. 利用mq怎么实现最终一致性。"></a>9. 利用mq怎么实现最终一致性。</h6><h6 id="10-使用kafka有没有遇到什么问题，怎么解决的。"><a href="#10-使用kafka有没有遇到什么问题，怎么解决的。" class="headerlink" title="10. 使用kafka有没有遇到什么问题，怎么解决的。"></a>10. 使用kafka有没有遇到什么问题，怎么解决的。</h6><h6 id="11-MQ有可能发生重复消费，如何避免，如何做到幂等。"><a href="#11-MQ有可能发生重复消费，如何避免，如何做到幂等。" class="headerlink" title="11. MQ有可能发生重复消费，如何避免，如何做到幂等。"></a>11. MQ有可能发生重复消费，如何避免，如何做到幂等。</h6><h6 id="12-MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。"><a href="#12-MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。" class="headerlink" title="12. MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。"></a>12. MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。</h6><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><h6 id="1-常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"><a href="#1-常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。" class="headerlink" title="1. 常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"></a>1. 常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。</h6><h6 id="2-如何防止缓存击穿和雪崩。"><a href="#2-如何防止缓存击穿和雪崩。" class="headerlink" title="2. 如何防止缓存击穿和雪崩。"></a>2. 如何防止缓存击穿和雪崩。</h6><h6 id="3-缓存数据过期后的更新如何设计。"><a href="#3-缓存数据过期后的更新如何设计。" class="headerlink" title="3. 缓存数据过期后的更新如何设计。"></a>3. 缓存数据过期后的更新如何设计。</h6><h6 id="4-redis的list结构相关的操作。"><a href="#4-redis的list结构相关的操作。" class="headerlink" title="4. redis的list结构相关的操作。"></a>4. redis的list结构相关的操作。</h6><h6 id="5-Redis的数据结构都有哪些。"><a href="#5-Redis的数据结构都有哪些。" class="headerlink" title="5. Redis的数据结构都有哪些。"></a>5. Redis的数据结构都有哪些。</h6><h6 id="6-Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"><a href="#6-Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。" class="headerlink" title="6. Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"></a>6. Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。</h6><h6 id="7-redis2和redis3的区别，redis3内部通讯机制。"><a href="#7-redis2和redis3的区别，redis3内部通讯机制。" class="headerlink" title="7. redis2和redis3的区别，redis3内部通讯机制。"></a>7. redis2和redis3的区别，redis3内部通讯机制。</h6><h6 id="8-当前redis集群有哪些玩法，各自优缺点，场景。"><a href="#8-当前redis集群有哪些玩法，各自优缺点，场景。" class="headerlink" title="8. 当前redis集群有哪些玩法，各自优缺点，场景。"></a>8. 当前redis集群有哪些玩法，各自优缺点，场景。</h6><h6 id="9-Memcache的原理，哪些数据适合放在缓存中。"><a href="#9-Memcache的原理，哪些数据适合放在缓存中。" class="headerlink" title="9. Memcache的原理，哪些数据适合放在缓存中。"></a>9. Memcache的原理，哪些数据适合放在缓存中。</h6><h6 id="10-redis和memcached-的内存管理的区别。"><a href="#10-redis和memcached-的内存管理的区别。" class="headerlink" title="10. redis和memcached 的内存管理的区别。"></a>10. redis和memcached 的内存管理的区别。</h6><h6 id="11-Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。"><a href="#11-Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。" class="headerlink" title="11. Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。"></a>11. Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。</h6><h6 id="12-Redis的选举算法和流程是怎样的。"><a href="#12-Redis的选举算法和流程是怎样的。" class="headerlink" title="12. Redis的选举算法和流程是怎样的。"></a>12. Redis的选举算法和流程是怎样的。</h6><h6 id="13-redis的持久化的机制，aof和rdb的区别。"><a href="#13-redis的持久化的机制，aof和rdb的区别。" class="headerlink" title="13. redis的持久化的机制，aof和rdb的区别。"></a>13. redis的持久化的机制，aof和rdb的区别。</h6><h6 id="14-redis的集群怎么同步的数据的。"><a href="#14-redis的集群怎么同步的数据的。" class="headerlink" title="14. redis的集群怎么同步的数据的。"></a>14. redis的集群怎么同步的数据的。</h6><h6 id="15-知道哪些redis的优化操作。"><a href="#15-知道哪些redis的优化操作。" class="headerlink" title="15. 知道哪些redis的优化操作。"></a>15. 知道哪些redis的优化操作。</h6><h6 id="16-Redis的主从复制机制原理。"><a href="#16-Redis的主从复制机制原理。" class="headerlink" title="16. Redis的主从复制机制原理。"></a>16. Redis的主从复制机制原理。</h6><h6 id="17-Redis的线程模型是什么。"><a href="#17-Redis的线程模型是什么。" class="headerlink" title="17. Redis的线程模型是什么。"></a>17. Redis的线程模型是什么。</h6><h6 id="18-请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。"><a href="#18-请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。" class="headerlink" title="18. 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。"></a>18. 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。</h6><h6 id="19-如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。"><a href="#19-如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。" class="headerlink" title="19. 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。"></a>19. 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。</h6><h6 id="20-本地缓存在并发使用时的注意事项。"><a href="#20-本地缓存在并发使用时的注意事项。" class="headerlink" title="20. 本地缓存在并发使用时的注意事项。"></a>20. 本地缓存在并发使用时的注意事项。</h6><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><h6 id="1-elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些"><a href="#1-elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些" class="headerlink" title="1. elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些"></a>1. elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些</h6><h6 id="2-调优手段-。elasticsearch的倒排索引是什么。"><a href="#2-调优手段-。elasticsearch的倒排索引是什么。" class="headerlink" title="2. 调优手段 。elasticsearch的倒排索引是什么。"></a>2. 调优手段 。elasticsearch的倒排索引是什么。</h6><h6 id="3-elasticsearch-索引数据多了怎么办，如何调优，部署。"><a href="#3-elasticsearch-索引数据多了怎么办，如何调优，部署。" class="headerlink" title="3. elasticsearch 索引数据多了怎么办，如何调优，部署。"></a>3. elasticsearch 索引数据多了怎么办，如何调优，部署。</h6><h6 id="4-elasticsearch是如何实现master选举的。"><a href="#4-elasticsearch是如何实现master选举的。" class="headerlink" title="4. elasticsearch是如何实现master选举的。"></a>4. elasticsearch是如何实现master选举的。</h6><h6 id="5-详细描述一下Elasticsearch索引文档的过程。"><a href="#5-详细描述一下Elasticsearch索引文档的过程。" class="headerlink" title="5. 详细描述一下Elasticsearch索引文档的过程。"></a>5. 详细描述一下Elasticsearch索引文档的过程。</h6><h6 id="6-详细描述一下Elasticsearch搜索的过程。"><a href="#6-详细描述一下Elasticsearch搜索的过程。" class="headerlink" title="6. 详细描述一下Elasticsearch搜索的过程。"></a>6. 详细描述一下Elasticsearch搜索的过程。</h6><h6 id="7-Elasticsearch在部署时，对Linux的设置有哪些优化方法？"><a href="#7-Elasticsearch在部署时，对Linux的设置有哪些优化方法？" class="headerlink" title="7. Elasticsearch在部署时，对Linux的设置有哪些优化方法？"></a>7. Elasticsearch在部署时，对Linux的设置有哪些优化方法？</h6><h6 id="8-lucence内部结构是什么。"><a href="#8-lucence内部结构是什么。" class="headerlink" title="8. lucence内部结构是什么。"></a>8. lucence内部结构是什么。</h6><h6 id="问了分布式锁有哪些实现方案？"><a href="#问了分布式锁有哪些实现方案？" class="headerlink" title="问了分布式锁有哪些实现方案？"></a>问了分布式锁有哪些实现方案？</h6><h6 id="分布式事务解决方案知道哪些，说一下区别以及原理？"><a href="#分布式事务解决方案知道哪些，说一下区别以及原理？" class="headerlink" title="分布式事务解决方案知道哪些，说一下区别以及原理？"></a>分布式事务解决方案知道哪些，说一下区别以及原理？</h6><h6 id="看你项目中使用的是spring-cloud，谈谈项目中用到了哪些主要的组件？为什么不使用dubbo？"><a href="#看你项目中使用的是spring-cloud，谈谈项目中用到了哪些主要的组件？为什么不使用dubbo？" class="headerlink" title="看你项目中使用的是spring cloud，谈谈项目中用到了哪些主要的组件？为什么不使用dubbo？"></a>看你项目中使用的是spring cloud，谈谈项目中用到了哪些主要的组件？为什么不使用dubbo？</h6><h6 id="spring-cloud与dubbo的区别？微服务模块之间是如何调用的？"><a href="#spring-cloud与dubbo的区别？微服务模块之间是如何调用的？" class="headerlink" title="spring cloud与dubbo的区别？微服务模块之间是如何调用的？"></a>spring cloud与dubbo的区别？微服务模块之间是如何调用的？</h6><h6 id="spring框架的意义是什么？为什么要使用控制反转？"><a href="#spring框架的意义是什么？为什么要使用控制反转？" class="headerlink" title="spring框架的意义是什么？为什么要使用控制反转？"></a>spring框架的意义是什么？为什么要使用控制反转？</h6><h6 id="谈谈对aop的理解？spring框架中用到了哪些设计模式？"><a href="#谈谈对aop的理解？spring框架中用到了哪些设计模式？" class="headerlink" title="谈谈对aop的理解？spring框架中用到了哪些设计模式？"></a>谈谈对aop的理解？spring框架中用到了哪些设计模式？</h6><h6 id="spring-boot程序为什么加上-springbootapplication就可以启动程序？"><a href="#spring-boot程序为什么加上-springbootapplication就可以启动程序？" class="headerlink" title="spring boot程序为什么加上@springbootapplication就可以启动程序？"></a>spring boot程序为什么加上@springbootapplication就可以启动程序？</h6><h6 id="自己写过spring-boot-starter吗？"><a href="#自己写过spring-boot-starter吗？" class="headerlink" title="自己写过spring boot starter吗？"></a>自己写过spring boot starter吗？</h6><h6 id="mybatis中的动态sql的用法有哪些？"><a href="#mybatis中的动态sql的用法有哪些？" class="headerlink" title="mybatis中的动态sql的用法有哪些？"></a>mybatis中的动态sql的用法有哪些？</h6><h6 id="说说线程池的实现原理？线程安全问题如何解决？"><a href="#说说线程池的实现原理？线程安全问题如何解决？" class="headerlink" title="说说线程池的实现原理？线程安全问题如何解决？"></a>说说线程池的实现原理？线程安全问题如何解决？</h6><p>核心线程数、最大线程数、任务队列。<br>核心线程数指的是线程池的基本大小；<br>最大线程数指的是，同一时刻线程池中线程的数量最大不能超过该值；<br>任务队列是当任务较多时，线程池中线程的数量已经达到了核心线程数，这时候就是用任务队列来存储我们提交的任务。<br>与其他池化技术不同的是，线程池是基于生产者-消费者模式来实现的，任务的提交方是生产者，线程池是消费者。<br>当我们需要执行某个任务时，只需要把任务扔到线程池中即可。</p><h6 id="谈谈并发中的各种锁？"><a href="#谈谈并发中的各种锁？" class="headerlink" title="谈谈并发中的各种锁？"></a>谈谈并发中的各种锁？</h6><h6 id="jvm的调优参数应该从哪些方面考虑，工作中通过哪些方面进行jvm调优？"><a href="#jvm的调优参数应该从哪些方面考虑，工作中通过哪些方面进行jvm调优？" class="headerlink" title="jvm的调优参数应该从哪些方面考虑，工作中通过哪些方面进行jvm调优？"></a>jvm的调优参数应该从哪些方面考虑，工作中通过哪些方面进行jvm调优？</h6><h6 id="谈谈jvm的内存模型？"><a href="#谈谈jvm的内存模型？" class="headerlink" title="谈谈jvm的内存模型？"></a>谈谈jvm的内存模型？</h6><h6 id="谈谈垃圾回收的策略有哪些？"><a href="#谈谈垃圾回收的策略有哪些？" class="headerlink" title="谈谈垃圾回收的策略有哪些？"></a>谈谈垃圾回收的策略有哪些？</h6><h6 id="哪些情况会导致内存泄露？"><a href="#哪些情况会导致内存泄露？" class="headerlink" title="哪些情况会导致内存泄露？"></a>哪些情况会导致内存泄露？</h6><h6 id="redis有哪些数据类型？"><a href="#redis有哪些数据类型？" class="headerlink" title="redis有哪些数据类型？"></a>redis有哪些数据类型？</h6><h6 id="redis为什么使用单线程？"><a href="#redis为什么使用单线程？" class="headerlink" title="redis为什么使用单线程？"></a>redis为什么使用单线程？</h6><h6 id="redis的集群（cluster）搭建？"><a href="#redis的集群（cluster）搭建？" class="headerlink" title="redis的集群（cluster）搭建？"></a>redis的集群（cluster）搭建？</h6><h6 id="map类型知道哪些，谈谈区别？"><a href="#map类型知道哪些，谈谈区别？" class="headerlink" title="map类型知道哪些，谈谈区别？"></a>map类型知道哪些，谈谈区别？</h6><h6 id="hashMap的put过程是怎样的？"><a href="#hashMap的put过程是怎样的？" class="headerlink" title="hashMap的put过程是怎样的？"></a>hashMap的put过程是怎样的？</h6><h6 id="数据库如何解决慢查询问题？"><a href="#数据库如何解决慢查询问题？" class="headerlink" title="数据库如何解决慢查询问题？"></a>数据库如何解决慢查询问题？</h6><h6 id="数据库索引有哪些类型，有什么区别？"><a href="#数据库索引有哪些类型，有什么区别？" class="headerlink" title="数据库索引有哪些类型，有什么区别？"></a>数据库索引有哪些类型，有什么区别？</h6><h6 id="docker常用的命令有哪些？"><a href="#docker常用的命令有哪些？" class="headerlink" title="docker常用的命令有哪些？"></a>docker常用的命令有哪些？</h6><h6 id="dockerfile有哪些常用的命令？"><a href="#dockerfile有哪些常用的命令？" class="headerlink" title="dockerfile有哪些常用的命令？"></a>dockerfile有哪些常用的命令？</h6><h6 id="linux常用的命令？"><a href="#linux常用的命令？" class="headerlink" title="linux常用的命令？"></a>linux常用的命令？</h6><h6 id="谈谈对JavaScript闭包的认识；"><a href="#谈谈对JavaScript闭包的认识；" class="headerlink" title="谈谈对JavaScript闭包的认识；"></a>谈谈对JavaScript闭包的认识；</h6>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Hash一致性Hash算法</title>
    <link href="/2020/03/28/2020-03-28-%E4%BB%80%E4%B9%88%E6%98%AFHash%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/28/2020-03-28-%E4%BB%80%E4%B9%88%E6%98%AFHash%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、什么是Hash"><a href="#1、什么是Hash" class="headerlink" title="1、什么是Hash"></a>1、什么是Hash</h2><p>Hash也称散列、哈希，对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的MD5和SHA都是历史悠久的Hash算法。</p><pre><code class="hljs cpp"><span class="hljs-function">echo <span class="hljs-title">md5</span><span class="hljs-params">(<span class="hljs-string">&quot;这是一个测试文案&quot;</span>)</span></span>;<span class="hljs-comment">// 输出结果：2124968af757ed51e71e6abeac04f98d</span></code></pre><p>在这个例子里，这是一个测试文案是原始值，2124968af757ed51e71e6abeac04f98d 就是经过hash算法得到的Hash值。整个Hash算法的过程就是把原始任意长度的值空间，映射成固定长度的值空间的过程。</p><h2 id="2、Hash的特点"><a href="#2、Hash的特点" class="headerlink" title="2、Hash的特点"></a>2、Hash的特点</h2><p>一个优秀的hash算法，需要什么样的要求呢？</p><ul><li><p>a)、从hash值不可以反向推导出原始的数据这个从上面MD5的例子里可以明确看到，经过映射后的数据和原始数据没有对应关系</p></li><li><p>b)、输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值echo md5(“这是一个测试文案”);// 输出结果：2124968af757ed51e71e6abeac04f98decho md5(“这是二个测试文案”);// 输出结果：bcc2a4bb4373076d494b2223aef9f702可以看到我们只改了一个文字，但是整个得到的hash值产生了非常大的变化。</p></li><li><p>c)、哈希算法的执行效率要高效，长的文本也能快速地计算出哈希值</p></li><li><p>d)、hash算法的冲突概率要小由于hash的原理是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间。<br>根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。那么作为一个好的hash算法，就需要这种冲突的概率尽可能小。</p></li></ul><blockquote><p>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。这一现象就是我们所说的“抽屉原理”。抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理</p></blockquote><h2 id="3、Hash碰撞的解决方案"><a href="#3、Hash碰撞的解决方案" class="headerlink" title="3、Hash碰撞的解决方案"></a>3、Hash碰撞的解决方案</h2><p>前面提到了hash算法是一定会有冲突的，那么如果我们如果遇到了hash冲突需要解决的时候应该怎么处理呢？比较常用的算法是链地址法和开放地址法。</p><h3 id="3-1-链地址法"><a href="#3-1-链地址法" class="headerlink" title="3.1 链地址法"></a>3.1 链地址法</h3><p>链表地址法是使用一个链表数组，来存储相应数据，当hash遇到冲突的时候依次添加到链表的后面进行处理。<br><img src="https://alwaysfaith.github.io/img/hash/v2-976fe3afe0d50dbafa97ae47f6f6a53b_720w.jpg"><br>链地址在处理的流程如下：添加一个元素的时候，首先计算元素key的hash值，确定插入数组中的位置。如果当前位置下没有重复数据，则直接添加到当前位置。当遇到冲突的时候，添加到同一个hash值的元素后面，行成一个链表。这个链表的特点是同一个链表上的Hash值相同。java的数据结构HashMap使用的就是这种方法来处理冲突，JDK1.8中，针对链表上的数据超过8条的时候，使用了红黑树进行优化。由于篇幅原因，这里不深入讨论相关数据结构，有兴趣的同学可以参考这篇文章：<br>            <a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">《Java集合之一—HashMap》</a></p><h3 id="3-2-开放地址法"><a href="#3-2-开放地址法" class="headerlink" title="3.2 开放地址法"></a>3.2 开放地址法</h3><p>开放地址法是指大小为 M 的数组保存 N 个键值对，其中 M &gt; N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为“开放地址”哈希表。线性探测法，就是比较常用的一种“开放地址”哈希表的一种实现方式。线性探测法的核心思想是当冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。简单来说就是：<strong>一旦发生冲突，就去寻找下 一个空的散列表地址，只要散列表足够大，空的散列地址总能找到。</strong></p><p>线性探测法的数学描述是：h(k, i) = (h(k, 0) + i) mod m，i表示当前进行的是第几轮探查。i=1时，即是探查h(k, 0)的下一个；i=2，即是再下一个。这个方法是简单地向下探查。mod m表示：到达了表的底下之后，回到顶端从头开始。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。但是不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。</p><p>散列表的装载因子=填入表中的元素个数/散列表的长度。装载因子越大，说明冲突越多，性能越差。</p><h3 id="3-3-两种方案的demo示例"><a href="#3-3-两种方案的demo示例" class="headerlink" title="3.3 两种方案的demo示例"></a>3.3 两种方案的demo示例</h3><p>假设散列长为8，散列函数H(K)=K mod 7，给定的关键字序列为{32,14,23,2, 20}<br>当使用链表法时，相应的数据结构如下图所示：<br><img src="https://alwaysfaith.github.io/img/hash/v2-dabac86f74bb61605f93258a01917590_r.jpg"></p><p>当使用线性探测法时，相应的数据结果如下图所示：<br><img src="https://alwaysfaith.github.io/img/hash/v2-cf46c1e0d22be22882ebc1974ae3c2cf_720w.jpg"></p><h2 id="4、hash算法在日常活动中的应用"><a href="#4、hash算法在日常活动中的应用" class="headerlink" title="4、hash算法在日常活动中的应用"></a>4、hash算法在日常活动中的应用</h2><p>在日常运营活动中，我们活动开发经常遇到的应用场景是信息加密、数据校验、负载均衡。下面分别对这三种应用场景进行讲解。</p><h3 id="4-1-信息加密"><a href="#4-1-信息加密" class="headerlink" title="4.1 信息加密"></a>4.1 信息加密</h3><p>首先我们看一下信息加密的应用。2011年CSDN脱库事件，导致超过600W的用户的密码泄露，让人失望的是，CSDN是明文存储用户的注册邮箱和密码的。作为用户的非常隐私的信息，最简单的保护措施就是对密码进行hash加密。在客户端对用户输入的密码进行hash运算，然后在服务端的数据库中保存用户密码的hash值。由于服务器端也没有存储密码的明文，所以目前很多网站也就不再有找回密码的功能了。</p><ul><li>这里也友情提示一下大家：如果在使用中发现某网站还有提供找回密码的功能，就要好好担心下这个网站的安全性了。</li></ul><p>看到这里有些同学会觉得那么我们是不是对用户输入的密码进行一次MD5加密就可以了呢，这样就算恶意用户知道了hash值，也没有办法拿到用户的真实密码。假设用户的密码是123456789，经过一次md5以后得到的值是:</p><pre><code class="hljs angelscript"><span class="hljs-number">25f</span>9e794323b453885f5181f1b624d0b```  那么是不是使用了这个加密后的字符串来存密码就万无一失了呢，理想总是很丰满，而现实总是很骨感的。  大家可以看一下这个网站：<span class="hljs-string">[cmd5.com/]</span>(https:<span class="hljs-comment">//www.cmd5.com/)   </span>这里是该网站的相关介绍：&gt; 本站针对md5、sha1等全球通用公开的加密算法进行反向查询，通过穷举字符组合的方式，创建了明文密文对应查询数据库，创建的记录约<span class="hljs-number">90</span>万亿条，占用硬盘超过<span class="hljs-number">500</span>TB，查询成功率<span class="hljs-number">95</span>%以上，很多复杂密文只有本站才可查询。已稳定运行十余年，国内外享有盛誉![](https:<span class="hljs-comment">//alwaysfaith.github.io/img/hash/v2-0254fb3b64eefecac297c6c6b4c1fb15_720w.jpg)</span>那么一般针对这种问题，我们的解决之道就是引入salt(加盐)，即利用特殊字符（盐）和用户的输入合在一起组成新的字符串进行加密。通过这样的方式，增加了反向查询的复杂度。但是这样的方式也不是万无一失，如果发生了盐被泄露的问题，就需要所有用到的地方来重置密码。针对salt泄露的问题，其实还有一种解决办法，即使用HMAC进行加密（Hash-based Message Authentication Code）。这种算法的核心思路是加密使用的key是从服务器端获取的，每一个用户的是不一样的。如果发生了泄露，那么也就是这一个用户的会被泄露，不会影响到全局。这里也留给大家一个思考点，如果恶意用户直接抓取了你的活动参与链接，也就是拿到了你计算后的hash值，那从技术的角度上说，我们还有没有其他可以提升恶意用户的违法成本呢？### <span class="hljs-number">4.2</span> 数据校验**-git commit id**使用过git的同学都应该清楚，每次git提交后都有一个commit id，比如:</code></pre><p>19d02d2cc358e59b3d04f82677dbf3808ae4fc40</p><pre><code class="hljs sql">就是一次git <span class="hljs-keyword">commit</span>的结果，那么这个<span class="hljs-keyword">id</span>是如何生成出来的呢？查阅了相关资料，使用如下代码可以进行查看：</code></pre><p>printf “commit %s\0” $(git cat-file commit HEAD | wc -c); git cat-file commit HEAD</p><pre><code>git的commit id主要包括了以下几部分内容：Tree 哈希，parent哈希、作者信息和本次提交的备注。![](https://alwaysfaith.github.io/img/hash/v2-3b5d910a510a359c0a0c69cb135b4996_720w.jpg)针对这些信息进行SHA-1 算法后得到值就是本次提交的commit id。简单来讲，就是对于单次提交的头信息的一个校验和。&gt;Linux kernel开创者和Git的开发者——Linus说，Git使用了sha1并非是为了安全性，而是为了数据的完整性；它可以保证，在很多年后，你重新checkout某个commit时，一定是它多年前的当时的状态，完全一摸一样，完全值得信任。但最新研究表明，理论上对其进行哈希碰撞（hash collision，不同的两块数据有相同的hash值）的攻击可以在2^51（2的51次方）左右的次数内实现。不过由于commit id 是针对单个仓库里的，所以实际应用中我们可以认为如果两个文件的SHA-1值是相同的，那么它们确是完全相同的内容。注：对于git里tree、parent等结构感兴趣的同学，可以参考下这篇文章[《Git 内部原理 - Git 对象》](https://git-scm.com/book/zh/v2/Git-内部原理-Git-对象)，这里由于篇幅原因就不进行深入分析了。- 版权校验在数据校验方面的另一个应用场景就是版权的保护或者违禁信息的打击，比如某个小视频，第一个用户上传的时候，我们认为是版权所有者，计算一个hash值存下来。当第二个用户上传的时候，同样计算hash值，如果hash值一样的话，就算同一个文件。这种方案其实也给用户传播违禁文件提高了一些门槛，不是简单的换一个名字或者改一下后缀名就可以躲避掉打击了。（当然这种方式也是可以绕过的，图片的你随便改一下颜色，视频去掉一帧就又是完全不同的hash值了。注意：我没有教你变坏，我只是和你在讨论这个技术。。。）另外我们在社区里，也会遇到玩家重复上传同一张图片或者视频的情况，使用这种校验的方式，可以有效减少cos服务的存储空间。- 大文件分块校验使用过bt的同学都有经验，在p2p网络中会把一个大文件拆分成很多小的数据各自传输。这样的好处是如果某个小的数据块在传输过程中损坏了，只要重新下载这个块就好。为了确保每一个小的数据块都是发布者自己传输的，我们可以对每一个小的数据块都进行一个hash的计算，维护一个hash List，在收到所有数据以后，我们对于这个hash List里的每一块进行遍历比对。这里有一个优化点是如果文件分块特别多的时候，如果遍历对比就会效率比较低。可以把所有分块的hash值组合成一个大的字符串，对于这个字符串再做一次Hash运算，得到最终的hash（Root hash）。在实际的校验中，我们只需要拿到了正确的Root hash，即可校验Hash List，也就可以校验每一个数据块了。![](https://alwaysfaith.github.io/img/hash/v2-cc3421c1114ae142865cbe96ca46ae22_720w.jpg)### 一、Redis集群的使用我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：![](https://alwaysfaith.github.io/img/hash/v2-e8e325f7395296718a69349b4a44e731_720w.jpg)同样类似于数据库，当单表数据大于500W的时候需要对其进行分库分表，当数据量很大的时候（标准可能不一样，要看Redis服务器容量）我们同样可以对Redis进行类似的操作，就是分库分表。假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下：![](https://alwaysfaith.github.io/img/hash/v2-8b328ac9a5664f65132a063d6c459224_720w.jpg)由于规则是随机的，所有我们的一条数据都有可能存储在任何一组Redis中，例如上图我们用户查找一张名称为”a.png”的图片，由于规则是随机的，我们不确定具体是在哪一个Redis服务器上的，因此我们需要进行1、2、3、4，4次查询才能够查询到（也就是遍历了所有的Redis服务器），这显然不是我们想要的结果，有了解过的小伙伴可能会想到，随机的规则不行，可以使用类似于数据库中的分库分表规则：按照Hash值、取模、按照类别、按照某一个字段值等等常见的规则就可以出来了！好，按照我们的主题，我们就使用Hash的方式。### 二、为Redis集群使用Hash可想而知，如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如下：![](https://alwaysfaith.github.io/img/hash/v2-bc6db15378a13b66a1ddaea68979762b_720w.jpg)上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 = 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！### 三、使用Hash的问题上述的方式虽然提升了性能，我们不再需要对整个Redis服务器进行遍历！但是，使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！试想一下，如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？很简单，多增加几台缓存服务器不就行了！假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据（还记得上一篇的《缓存雪崩》吗？）！同样的，假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！### 四、一致性Hash算法的神秘面纱一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：![](https://alwaysfaith.github.io/img/hash/v2-fd44ab71c834f3fe458a6f76f3997f98_720w.jpg)整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：![](https://alwaysfaith.github.io/img/hash/v2-509993a49d447b378273e455a095de3c_720w.jpg)接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：![](https://alwaysfaith.github.io/img/hash/v2-4fab60735dfae0bf511709e9d337789b_720w.jpg)根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。### 五、一致性Hash算法的容错性和可扩展性现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：![](https://alwaysfaith.github.io/img/hash/v2-4ebcb8c23bb64a60896bde87dd546214_r.jpg)下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：![](https://alwaysfaith.github.io/img/hash/v2-9cdb1adc37eb1a54c114232120da1485_720w.jpg)此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。### 六、Hash环的数据倾斜问题一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：![](https://alwaysfaith.github.io/img/hash/v2-d499324a9aa067915bbb3f5f3416b032_720w.jpg)此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：![](https://alwaysfaith.github.io/img/hash/v2-0368841e5020dd07f1e67f449b49a1ba_720w.jpg)同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第10章 Java常用类库与技巧</title>
    <link href="/2020/03/26/2020-03-26-%E7%AC%AC10%E7%AB%A0%20Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/03/26/2020-03-26-%E7%AC%AC10%E7%AB%A0%20Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E4%B8%8E%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="10-1-Java异常体系"><a href="#10-1-Java异常体系" class="headerlink" title="10-1 Java异常体系"></a>10-1 Java异常体系</h2><p>![](<a href="https://alwaysfaith.github.io/img/utils/10-1">https://alwaysfaith.github.io/img/utils/10-1</a> Java异常体系[00_00_51][20200325-164248].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-1">https://alwaysfaith.github.io/img/utils/10-1</a> Java异常体系[00_02_20][20200325-164426].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-1">https://alwaysfaith.github.io/img/utils/10-1</a> Java异常体系[00_02_58][20200325-164523].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-1">https://alwaysfaith.github.io/img/utils/10-1</a> Java异常体系[00_03_13][20200325-164548].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-1">https://alwaysfaith.github.io/img/utils/10-1</a> Java异常体系[00_09_54][20200325-171951].jpg)</p><h2 id="10-2-Java异常要点分析"><a href="#10-2-Java异常要点分析" class="headerlink" title="10-2 Java异常要点分析"></a>10-2 Java异常要点分析</h2><p>![](<a href="https://alwaysfaith.github.io/img/utils/10-2">https://alwaysfaith.github.io/img/utils/10-2</a> Java异常要点分析[00_01_00][20200325-172316].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-2">https://alwaysfaith.github.io/img/utils/10-2</a> Java异常要点分析[00_02_12][20200325-172433].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-2">https://alwaysfaith.github.io/img/utils/10-2</a> Java异常要点分析[00_05_24][20200325-172745].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-2">https://alwaysfaith.github.io/img/utils/10-2</a> Java异常要点分析[00_06_43][20200325-172924].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-2">https://alwaysfaith.github.io/img/utils/10-2</a> Java异常要点分析[00_07_51][20200325-173041].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-2">https://alwaysfaith.github.io/img/utils/10-2</a> Java异常要点分析[00_09_37][20200325-173228].jpg)</p><h2 id="10-3-Collection体系"><a href="#10-3-Collection体系" class="headerlink" title="10-3 Collection体系"></a>10-3 Collection体系</h2><p>![](<a href="https://alwaysfaith.github.io/img/utils/10-3">https://alwaysfaith.github.io/img/utils/10-3</a> Collection体系[00_00_56][20200325-173400].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-3">https://alwaysfaith.github.io/img/utils/10-3</a> Collection体系[00_01_15][20200325-173429].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-3">https://alwaysfaith.github.io/img/utils/10-3</a> Collection体系[00_02_10][20200325-173556].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-3">https://alwaysfaith.github.io/img/utils/10-3</a> Collection体系[00_02_37][20200325-173623].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-3">https://alwaysfaith.github.io/img/utils/10-3</a> Collection体系[00_04_09][20200325-173924].jpg)</p><h2 id="10-4-HashMap"><a href="#10-4-HashMap" class="headerlink" title="10-4 HashMap"></a>10-4 HashMap</h2><p>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_01_02][20200325-175143].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_02_46][20200325-175347].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_03_11][20200325-175418].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_08_36][20200325-175954].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_10_20][20200325-180148].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_11_33][20200325-180301].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_15_41][20200325-180719].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-4">https://alwaysfaith.github.io/img/utils/10-4</a> HashMap[00_16_19][20200325-180757].jpg)</p><h2 id="10-5-ConcurrentHashMap"><a href="#10-5-ConcurrentHashMap" class="headerlink" title="10-5 ConcurrentHashMap"></a>10-5 ConcurrentHashMap</h2><p>![](<a href="https://alwaysfaith.github.io/img/utils/10-5">https://alwaysfaith.github.io/img/utils/10-5</a> ConcurrentHashM[00_01_46][20200325-185037].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-5">https://alwaysfaith.github.io/img/utils/10-5</a> ConcurrentHashM[00_02_38][20200325-211042].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-5">https://alwaysfaith.github.io/img/utils/10-5</a> ConcurrentHashM[00_03_18][20200325-211143].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-5">https://alwaysfaith.github.io/img/utils/10-5</a> ConcurrentHashM[00_07_44][20200325-211631].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-5">https://alwaysfaith.github.io/img/utils/10-5</a> ConcurrentHashM[00_08_57][20200325-211805].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-5">https://alwaysfaith.github.io/img/utils/10-5</a> ConcurrentHashM[00_09_48][20200325-211856].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-5">https://alwaysfaith.github.io/img/utils/10-5</a> ConcurrentHashM[00_10_39][20200325-212003].jpg)</p><h2 id="10-6-J-U-C包的梳理"><a href="#10-6-J-U-C包的梳理" class="headerlink" title="10-6 J.U.C包的梳理"></a>10-6 J.U.C包的梳理</h2><p>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_00_16][20200325-212110].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_00_38][20200325-212132].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_00_43][20200325-212137].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_03_59][20200325-212453].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_04_43][20200325-212634].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_05_11][20200325-212713].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_05_36][20200325-212827].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_06_21][20200325-212934].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_06_41][20200325-213004].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_06_49][20200325-213012].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_07_16][20200325-213040].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_07_55][20200325-213118].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_09_08][20200325-213231].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_11_24][20200325-213609].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-6">https://alwaysfaith.github.io/img/utils/10-6</a> J[00_11_47][20200325-213632].jpg)</p><h2 id="10-7-Java的IO机制"><a href="#10-7-Java的IO机制" class="headerlink" title="10-7 Java的IO机制"></a>10-7 Java的IO机制</h2><p>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_02_08][20200325-214217].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_02_52][20200325-214301].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_03_39][20200325-214403].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_04_41][20200325-214458].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_05_00][20200325-214532].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_05_09][20200325-214539].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_07_26][20200325-214725].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_07_48][20200325-214741].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_09_04][20200325-214840].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_09_35][20200325-214904].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_10_05][20200325-214927].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_10_38][20200325-215006].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/utils/10-7">https://alwaysfaith.github.io/img/utils/10-7</a> Java的IO机制[00_19_05][20200325-215636].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第11章 Java框架-Spring</title>
    <link href="/2020/03/26/2020-03-26-%E7%AC%AC11%E7%AB%A0%20Java%E6%A1%86%E6%9E%B6-Spring/"/>
    <url>/2020/03/26/2020-03-26-%E7%AC%AC11%E7%AB%A0%20Java%E6%A1%86%E6%9E%B6-Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="11-2-IOC原理"><a href="#11-2-IOC原理" class="headerlink" title="11-2 IOC原理"></a>11-2 IOC原理</h2><p>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_00_35][20200325-221135].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_01_29][20200325-221250].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_03_17][20200325-221448].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_04_13][20200325-221554].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_05_21][20200325-221703].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_06_23][20200325-221805].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_07_25][20200325-221906].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_08_07][20200325-222009].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_08_45][20200325-222117].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-2">https://alwaysfaith.github.io/img/spring/11-2</a> IOC原理[00_09_23][20200325-222155].jpg)</p><h2 id="11-3-SpringIOC的应用"><a href="#11-3-SpringIOC的应用" class="headerlink" title="11-3 SpringIOC的应用"></a>11-3 SpringIOC的应用</h2><p>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_00_12][20200326-095915].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_00_45][20200326-100030].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_01_07][20200326-100102].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_01_32][20200326-100137].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_01_45][20200326-100200].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_04_11][20200326-100733].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_04_44][20200326-100806].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_08_00][20200326-101132].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_08_59][20200326-101302].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-3">https://alwaysfaith.github.io/img/spring/11-3</a> SpringIOC的应用[00_09_13][20200326-102537].jpg)</p><h2 id="11-5-SpringIOC的getBean方法的解析"><a href="#11-5-SpringIOC的getBean方法的解析" class="headerlink" title="11-5 SpringIOC的getBean方法的解析"></a>11-5 SpringIOC的getBean方法的解析</h2><p>![](<a href="https://alwaysfaith.github.io/img/spring/11-5">https://alwaysfaith.github.io/img/spring/11-5</a> SpringIOC的getBe[00_02_48][20200326-112215].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-5">https://alwaysfaith.github.io/img/spring/11-5</a> SpringIOC的getBe[00_04_22][20200326-112434].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-5">https://alwaysfaith.github.io/img/spring/11-5</a> SpringIOC的getBe[00_05_36][20200326-112548].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-5">https://alwaysfaith.github.io/img/spring/11-5</a> SpringIOC的getBe[00_06_49][20200326-112701].jpg)</p><h2 id="11-6-AOP的介绍和使用"><a href="#11-6-AOP的介绍和使用" class="headerlink" title="11-6 AOP的介绍和使用"></a>11-6 AOP的介绍和使用</h2><p>![](<a href="https://alwaysfaith.github.io/img/spring/11-6">https://alwaysfaith.github.io/img/spring/11-6</a> AOP的介绍和使用[00_01_21][20200326-112854].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-6">https://alwaysfaith.github.io/img/spring/11-6</a> AOP的介绍和使用[00_02_07][20200326-112950].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-6">https://alwaysfaith.github.io/img/spring/11-6</a> AOP的介绍和使用[00_11_19][20200326-115843].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-6">https://alwaysfaith.github.io/img/spring/11-6</a> AOP的介绍和使用[00_11_45][20200326-115922].jpg)</p><h2 id="11-7-SpringAOP的原理"><a href="#11-7-SpringAOP的原理" class="headerlink" title="11-7 SpringAOP的原理"></a>11-7 SpringAOP的原理</h2><p>![](<a href="https://alwaysfaith.github.io/img/spring/11-7">https://alwaysfaith.github.io/img/spring/11-7</a> SpringAOP的原理[00_00_57][20200326-144059].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-7">https://alwaysfaith.github.io/img/spring/11-7</a> SpringAOP的原理[00_01_22][20200326-144135].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-7">https://alwaysfaith.github.io/img/spring/11-7</a> SpringAOP的原理[00_01_37][20200326-144522].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-7">https://alwaysfaith.github.io/img/spring/11-7</a> SpringAOP的原理[00_05_21][20200326-144753].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/spring/11-7">https://alwaysfaith.github.io/img/spring/11-7</a> SpringAOP的原理[00_10_12][20200326-145244].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第9章 Java多线程与并发-原理</title>
    <link href="/2020/03/25/2020-03-25-%E7%AC%AC9%E7%AB%A0%20Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/"/>
    <url>/2020/03/25/2020-03-25-%E7%AC%AC9%E7%AB%A0%20Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="9-1-synchronized"><a href="#9-1-synchronized" class="headerlink" title="9-1 synchronized"></a>9-1 synchronized</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-1">https://alwaysfaith.github.io/img/cas/9-1</a> synchronized[00_00_23][20200325-133855].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-1">https://alwaysfaith.github.io/img/cas/9-1</a> synchronized[00_02_01][20200325-134355].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-1">https://alwaysfaith.github.io/img/cas/9-1</a> synchronized[00_09_27][20200325-135639].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-1">https://alwaysfaith.github.io/img/cas/9-1</a> synchronized[00_13_06][20200325-140157].jpg)</p><h2 id="9-2-synchronized底层实现原理-1"><a href="#9-2-synchronized底层实现原理-1" class="headerlink" title="9-2 synchronized底层实现原理-1"></a>9-2 synchronized底层实现原理-1</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_00_20][20200325-140359].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_00_56][20200325-140534].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_01_13][20200325-140551].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_02_19][20200325-140830].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_03_57][20200325-140907].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_06_33][20200325-141449].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_08_49][20200325-141429].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_09_28][20200325-141608].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-2">https://alwaysfaith.github.io/img/cas/9-2</a> synchronized底层实现[00_10_56][20200325-141737].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_00_47][20200325-141840].jpg)</p><h2 id="9-3-synchronized底层实现原理-2"><a href="#9-3-synchronized底层实现原理-2" class="headerlink" title="9-3 synchronized底层实现原理-2"></a>9-3 synchronized底层实现原理-2</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_01_10][20200325-141914].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_02_41][20200325-142055].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_03_56][20200325-142220].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_05_06][20200325-142337].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_05_44][20200325-142427].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_08_47][20200325-142730].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-3">https://alwaysfaith.github.io/img/cas/9-3</a> synchronized底层实现[00_09_34][20200325-142817].jpg)</p><h2 id="9-4-synchronized和ReentrantLock"><a href="#9-4-synchronized和ReentrantLock" class="headerlink" title="9-4 synchronized和ReentrantLock"></a>9-4 synchronized和ReentrantLock</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-4">https://alwaysfaith.github.io/img/cas/9-4</a> synchronized和Ree[00_03_01][20200325-143207].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-4">https://alwaysfaith.github.io/img/cas/9-4</a> synchronized和Ree[00_04_16][20200325-143324].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-4">https://alwaysfaith.github.io/img/cas/9-4</a> synchronized和Ree[00_07_37][20200325-143656].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-4">https://alwaysfaith.github.io/img/cas/9-4</a> synchronized和Ree[00_07_58][20200325-144141].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-4">https://alwaysfaith.github.io/img/cas/9-4</a> synchronized和Ree[00_11_01][20200325-144107].jpg)</p><h2 id="9-5-jmm的内存可见性"><a href="#9-5-jmm的内存可见性" class="headerlink" title="9-5 jmm的内存可见性"></a>9-5 jmm的内存可见性</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_01_04][20200325-144431].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_01_30][20200325-150444].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_02_02][20200325-150537].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_02_39][20200325-150615].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_03_37][20200325-150723].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_04_19][20200325-150815].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_05_02][20200325-150858].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_05_52][20200325-151043].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_08_28][20200325-151318].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_09_05][20200325-151402].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_10_37][20200325-151608].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_11_50][20200325-151731].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_11_56][20200325-151737].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_12_25][20200325-151820].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_13_00][20200325-151854].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_13_21][20200325-151934].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_14_13][20200325-152026].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_15_34][20200325-152158].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_15_37][20200325-152201].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-5">https://alwaysfaith.github.io/img/cas/9-5</a> jmm的内存可见性_慕课网[00_15_49][20200325-152214].jpg)</p><h2 id="9-6-CAS"><a href="#9-6-CAS" class="headerlink" title="9-6 CAS"></a>9-6 CAS</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-6">https://alwaysfaith.github.io/img/cas/9-6</a> CAS_慕课网[00_00_51][20200325-153006].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-6">https://alwaysfaith.github.io/img/cas/9-6</a> CAS_慕课网[00_01_36][20200325-153337].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-6">https://alwaysfaith.github.io/img/cas/9-6</a> CAS_慕课网[00_04_49][20200325-153429].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-6">https://alwaysfaith.github.io/img/cas/9-6</a> CAS_慕课网[00_06_05][20200325-153600].jpg)</p><h2 id="9-7-Java线程池-1"><a href="#9-7-Java线程池-1" class="headerlink" title="9-7 Java线程池-1"></a>9-7 Java线程池-1</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-7">https://alwaysfaith.github.io/img/cas/9-7</a> Java线程池_慕课网[00_02_30][20200325-153900].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-7">https://alwaysfaith.github.io/img/cas/9-7</a> Java线程池_慕课网[00_04_19][20200325-154049].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-7">https://alwaysfaith.github.io/img/cas/9-7</a> Java线程池_慕课网[00_04_37][20200325-154118].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-7">https://alwaysfaith.github.io/img/cas/9-7</a> Java线程池_慕课网[00_06_35][20200325-154339].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-7">https://alwaysfaith.github.io/img/cas/9-7</a> Java线程池_慕课网[00_07_34][20200325-154800].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-7">https://alwaysfaith.github.io/img/cas/9-7</a> Java线程池_慕课网[00_08_22][20200325-154859].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-7">https://alwaysfaith.github.io/img/cas/9-7</a> Java线程池_慕课网[00_09_26][20200325-155019].jpg)</p><h2 id="9-8-Java线程池-2"><a href="#9-8-Java线程池-2" class="headerlink" title="9-8 Java线程池-2"></a>9-8 Java线程池-2</h2><p>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_02_48][20200325-160346].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_03_39][20200325-160448].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_04_29][20200325-160548].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_04_41][20200325-160600].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_07_08][20200325-160828].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_07_19][20200325-160840].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_08_08][20200325-160929].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/cas/9-8">https://alwaysfaith.github.io/img/cas/9-8</a> Java线程池-2_慕课网[00_09_21][20200325-161043].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第8章 Java多线程与并发</title>
    <link href="/2020/03/25/2020-03-25-%E7%AC%AC8%E7%AB%A0%20Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/03/25/2020-03-25-%E7%AC%AC8%E7%AB%A0%20Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="8-1-进程和线程的区别"><a href="#8-1-进程和线程的区别" class="headerlink" title="8-1 进程和线程的区别"></a>8-1 进程和线程的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-1">https://alwaysfaith.github.io/img/thread/8-1</a> 进程和线程的区别_慕课网1[00_00_41][20200324-150439].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-1">https://alwaysfaith.github.io/img/thread/8-1</a> 进程和线程的区别_慕课网1[00_05_41][20200324-152330].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-1">https://alwaysfaith.github.io/img/thread/8-1</a> 进程和线程的区别_慕课网1[00_06_29][20200324-153532].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-1">https://alwaysfaith.github.io/img/thread/8-1</a> 进程和线程的区别_慕课网1[00_06_38][20200324-153541].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-1">https://alwaysfaith.github.io/img/thread/8-1</a> 进程和线程的区别_慕课网1[00_07_38][20200325-093744].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-1">https://alwaysfaith.github.io/img/thread/8-1</a> 进程和线程的区别_慕课网1[00_08_47][20200325-093904].jpg)</p><h2 id="8-2-线程的start和run方法的区别"><a href="#8-2-线程的start和run方法的区别" class="headerlink" title="8-2 线程的start和run方法的区别"></a>8-2 线程的start和run方法的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-2">https://alwaysfaith.github.io/img/thread/8-2</a> 线程的start和run方法的区[00_01_47][20200325-094607].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-2">https://alwaysfaith.github.io/img/thread/8-2</a> 线程的start和run方法的区[00_02_29][20200325-094612].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-2">https://alwaysfaith.github.io/img/thread/8-2</a> 线程的start和run方法的区[00_04_53][20200325-094657].jpg)</p><h2 id="8-3-Thread和Runnable的关系"><a href="#8-3-Thread和Runnable的关系" class="headerlink" title="8-3 Thread和Runnable的关系"></a>8-3 Thread和Runnable的关系</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-3">https://alwaysfaith.github.io/img/thread/8-3</a> Thread和Runnable的[00_04_45][20200325-095158].jpg)</p><h2 id="8-4-如何实现处理线程的返回值"><a href="#8-4-如何实现处理线程的返回值" class="headerlink" title="8-4 如何实现处理线程的返回值"></a>8-4 如何实现处理线程的返回值</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-4">https://alwaysfaith.github.io/img/thread/8-4</a> 如何实现处理线程的返回值_慕课网[00_00_23][20200325-095238].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-4">https://alwaysfaith.github.io/img/thread/8-4</a> 如何实现处理线程的返回值_慕课网[00_03_54][20200325-100253].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-4">https://alwaysfaith.github.io/img/thread/8-4</a> 如何实现处理线程的返回值_慕课网[00_04_29][20200325-100246].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-4">https://alwaysfaith.github.io/img/thread/8-4</a> 如何实现处理线程的返回值_慕课网[00_08_38][20200325-101446].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-4">https://alwaysfaith.github.io/img/thread/8-4</a> 如何实现处理线程的返回值_慕课网[00_10_38][20200325-101751].jpg)</p><h2 id="8-5-线程的状态"><a href="#8-5-线程的状态" class="headerlink" title="8-5 线程的状态"></a>8-5 线程的状态</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-5">https://alwaysfaith.github.io/img/thread/8-5</a> 线程的状态_慕课网[00_00_04][20200325-101833].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-5">https://alwaysfaith.github.io/img/thread/8-5</a> 线程的状态_慕课网[00_01_21][20200325-101951].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-5">https://alwaysfaith.github.io/img/thread/8-5</a> 线程的状态_慕课网[00_02_05][20200325-102045].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-5">https://alwaysfaith.github.io/img/thread/8-5</a> 线程的状态_慕课网[00_03_02][20200325-102141].jpg)</p><h2 id="8-6-sleep和wait的区别"><a href="#8-6-sleep和wait的区别" class="headerlink" title="8-6 sleep和wait的区别"></a>8-6 sleep和wait的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-6">https://alwaysfaith.github.io/img/thread/8-6</a> sleep和wait的区别_慕课[00_00_42][20200325-103008].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-6">https://alwaysfaith.github.io/img/thread/8-6</a> sleep和wait的区别_慕课[00_01_16][20200325-103052].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-6">https://alwaysfaith.github.io/img/thread/8-6</a> sleep和wait的区别_慕课[00_06_28][20200325-103718].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-6">https://alwaysfaith.github.io/img/thread/8-6</a> sleep和wait的区别_慕课[00_07_28][20200325-103723].jpg)</p><h2 id="8-7-notify和notifyall的区别"><a href="#8-7-notify和notifyall的区别" class="headerlink" title="8-7 notify和notifyall的区别"></a>8-7 notify和notifyall的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-7">https://alwaysfaith.github.io/img/thread/8-7</a> notify和notifyall[00_00_57][20200325-103905].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-7">https://alwaysfaith.github.io/img/thread/8-7</a> notify和notifyall[00_01_00][20200325-103842].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-7">https://alwaysfaith.github.io/img/thread/8-7</a> notify和notifyall[00_01_58][20200325-104021].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-7">https://alwaysfaith.github.io/img/thread/8-7</a> notify和notifyall[00_02_21][20200325-104044].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-7">https://alwaysfaith.github.io/img/thread/8-7</a> notify和notifyall[00_04_02][20200325-104235].jpg)</p><h2 id="8-8-yield函数"><a href="#8-8-yield函数" class="headerlink" title="8-8 yield函数"></a>8-8 yield函数</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-8">https://alwaysfaith.github.io/img/thread/8-8</a> yield函数_慕课网[00_00_33][20200325-105054].jpg)</p><h2 id="8-9-interrupt函数"><a href="#8-9-interrupt函数" class="headerlink" title="8-9 interrupt函数"></a>8-9 interrupt函数</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-9">https://alwaysfaith.github.io/img/thread/8-9</a> interrupt函数_慕课网[00_00_34][20200325-105504].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-9">https://alwaysfaith.github.io/img/thread/8-9</a> interrupt函数_慕课网[00_01_18][20200325-105547].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/thread/8-9">https://alwaysfaith.github.io/img/thread/8-9</a> interrupt函数_慕课网[00_01_40][20200325-105620].jpg)</p><h2 id="8-10-前述方法及线程状态总结"><a href="#8-10-前述方法及线程状态总结" class="headerlink" title="8-10 前述方法及线程状态总结"></a>8-10 前述方法及线程状态总结</h2><p>![](<a href="https://alwaysfaith.github.io/img/thread/8-10">https://alwaysfaith.github.io/img/thread/8-10</a> 前述方法及线程状态总结_慕课网[00_02_08][20200325-110408].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第6章 Java底层知识：JVM</title>
    <link href="/2020/03/24/2020-03-24-%E7%AC%AC6%E7%AB%A0%20Java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%EF%BC%9AJVM/"/>
    <url>/2020/03/24/2020-03-24-%E7%AC%AC6%E7%AB%A0%20Java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%EF%BC%9AJVM/</url>
    
    <content type="html"><![CDATA[<h2 id="6-1-谈谈你对Java的理解"><a href="#6-1-谈谈你对Java的理解" class="headerlink" title="6-1 谈谈你对Java的理解"></a>6-1 谈谈你对Java的理解</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-1">https://alwaysfaith.github.io/img/jvm/6-1</a> 谈谈你对Java的理解_慕课网[00_02_51][20200323-160244].jpg)</p><h2 id="6-2-平台无关性如何实现"><a href="#6-2-平台无关性如何实现" class="headerlink" title="6-2 平台无关性如何实现"></a>6-2 平台无关性如何实现</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-2">https://alwaysfaith.github.io/img/jvm/6-2</a> 平台无关性如何实现_慕课网[00_11_17][20200323-161440].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-2">https://alwaysfaith.github.io/img/jvm/6-2</a> 平台无关性如何实现_慕课网[00_12_08][20200323-161541].jpg)</p><h2 id="6-3-JVM如何加载class文件"><a href="#6-3-JVM如何加载class文件" class="headerlink" title="6-3 JVM如何加载class文件"></a>6-3 JVM如何加载class文件</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-3">https://alwaysfaith.github.io/img/jvm/6-3</a> JVM如何加载class文件_慕[00_04_20][20200323-163136].jpg)</p><h2 id="6-4-什么是反射"><a href="#6-4-什么是反射" class="headerlink" title="6-4 什么是反射"></a>6-4 什么是反射</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-4">https://alwaysfaith.github.io/img/jvm/6-4</a> 什么是反射_慕课网[00_00_58][20200323-164259].jpg)</p><h2 id="6-5-谈谈ClassLoader"><a href="#6-5-谈谈ClassLoader" class="headerlink" title="6-5 谈谈ClassLoader"></a>6-5 谈谈ClassLoader</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-5">https://alwaysfaith.github.io/img/jvm/6-5</a> 谈谈ClassLoader_慕课[00_00_49][20200323-165150].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-5">https://alwaysfaith.github.io/img/jvm/6-5</a> 谈谈ClassLoader_慕课[00_01_18][20200323-165238].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-5">https://alwaysfaith.github.io/img/jvm/6-5</a> 谈谈ClassLoader_慕课[00_05_40][20200323-173802].jpg)</p><h2 id="6-6-ClassLoader的双亲委派机制"><a href="#6-6-ClassLoader的双亲委派机制" class="headerlink" title="6-6 ClassLoader的双亲委派机制"></a>6-6 ClassLoader的双亲委派机制</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-6">https://alwaysfaith.github.io/img/jvm/6-6</a> ClassLoader的双亲委派[00_01_05][20200323-175730].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-6">https://alwaysfaith.github.io/img/jvm/6-6</a> ClassLoader的双亲委派[00_09_49][20200323-180614].jpg)</p><h2 id="6-7-loadClass和forNam的区别"><a href="#6-7-loadClass和forNam的区别" class="headerlink" title="6-7 loadClass和forNam的区别"></a>6-7 loadClass和forNam的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-7">https://alwaysfaith.github.io/img/jvm/6-7</a> loadClass和forNam[00_00_54][20200324-100626].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-7">https://alwaysfaith.github.io/img/jvm/6-7</a> loadClass和forNam[00_02_53][20200324-100836].jpg)</p><h2 id="6-8-Java内存模型之线程独占部分-1"><a href="#6-8-Java内存模型之线程独占部分-1" class="headerlink" title="6-8 Java内存模型之线程独占部分-1"></a>6-8 Java内存模型之线程独占部分-1</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-8">https://alwaysfaith.github.io/img/jvm/6-8</a> Java内存模型之线程独占部分-[00_01_04][20200324-101614].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-8">https://alwaysfaith.github.io/img/jvm/6-8</a> Java内存模型之线程独占部分-[00_01_46][20200324-101714].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-8">https://alwaysfaith.github.io/img/jvm/6-8</a> Java内存模型之线程独占部分-[00_03_04][20200324-101914].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-8">https://alwaysfaith.github.io/img/jvm/6-8</a> Java内存模型之线程独占部分-[00_04_26][20200324-102043].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-8">https://alwaysfaith.github.io/img/jvm/6-8</a> Java内存模型之线程独占部分-[00_05_03][20200324-102210].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-8">https://alwaysfaith.github.io/img/jvm/6-8</a> Java内存模型之线程独占部分-[00_06_02][20200324-102607].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-8">https://alwaysfaith.github.io/img/jvm/6-8</a> Java内存模型之线程独占部分-[00_09_03][20200324-102858].jpg)</p><h2 id="6-9-Java内存模型之线程独占部分-2"><a href="#6-9-Java内存模型之线程独占部分-2" class="headerlink" title="6-9 Java内存模型之线程独占部分-2"></a>6-9 Java内存模型之线程独占部分-2</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-9">https://alwaysfaith.github.io/img/jvm/6-9</a> Java内存模型之线程独占部分-[00_06_13][20200324-103537].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-9">https://alwaysfaith.github.io/img/jvm/6-9</a> Java内存模型之线程独占部分-[00_06_51][20200324-103615].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-9">https://alwaysfaith.github.io/img/jvm/6-9</a> Java内存模型之线程独占部分-[00_08_02][20200324-103736].jpg)</p><h2 id="6-10-Java内存模型之线程共享部分"><a href="#6-10-Java内存模型之线程共享部分" class="headerlink" title="6-10 Java内存模型之线程共享部分"></a>6-10 Java内存模型之线程共享部分</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-10">https://alwaysfaith.github.io/img/jvm/6-10</a> Java内存模型之线程共享部分[00_01_02][20200324-104043].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-10">https://alwaysfaith.github.io/img/jvm/6-10</a> Java内存模型之线程共享部分[00_02_22][20200324-104203].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-10">https://alwaysfaith.github.io/img/jvm/6-10</a> Java内存模型之线程共享部分[00_04_11][20200324-104402].jpg)</p><h2 id="6-11-Java内存模型之常考题解析-1"><a href="#6-11-Java内存模型之常考题解析-1" class="headerlink" title="6-11 Java内存模型之常考题解析-1"></a>6-11 Java内存模型之常考题解析-1</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_00_14][20200324-104503].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_00_55][20200324-104554].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_02_14][20200324-104754].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_03_28][20200324-104919].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_05_29][20200324-105129].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_06_22][20200324-105242].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_07_20][20200324-105339].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/jvm/6-11">https://alwaysfaith.github.io/img/jvm/6-11</a> Java内存模型之 常考题解析[00_08_39][20200324-105509].jpg)</p><h2 id="6-12-Java内存模型之常考题解析-2"><a href="#6-12-Java内存模型之常考题解析-2" class="headerlink" title="6-12 Java内存模型之常考题解析-2"></a>6-12 Java内存模型之常考题解析-2</h2><p>![](<a href="https://alwaysfaith.github.io/img/jvm/6-12">https://alwaysfaith.github.io/img/jvm/6-12</a> Java内存模型之常考题解析-[00_05_41][20200324-110300].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第7章 Java底层知识：GC相关</title>
    <link href="/2020/03/24/2020-03-24-%E7%AC%AC7%E7%AB%A0%20Java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%EF%BC%9AGC%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/03/24/2020-03-24-%E7%AC%AC7%E7%AB%A0%20Java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%EF%BC%9AGC%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="7-1-垃圾回收之标记算法"><a href="#7-1-垃圾回收之标记算法" class="headerlink" title="7-1 垃圾回收之标记算法"></a>7-1 垃圾回收之标记算法</h2><p>![](<a href="https://alwaysfaith.github.io/img/gc/7-1">https://alwaysfaith.github.io/img/gc/7-1</a> 垃圾回收之标记算法_慕课网[00_01_21][20200324-134514].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-1">https://alwaysfaith.github.io/img/gc/7-1</a> 垃圾回收之标记算法_慕课网[00_01_30][20200324-134538].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-1">https://alwaysfaith.github.io/img/gc/7-1</a> 垃圾回收之标记算法_慕课网[00_02_26][20200324-134645].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-1">https://alwaysfaith.github.io/img/gc/7-1</a> 垃圾回收之标记算法_慕课网[00_02_55][20200324-134724].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-1">https://alwaysfaith.github.io/img/gc/7-1</a> 垃圾回收之标记算法_慕课网[00_05_03][20200324-134941].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-1">https://alwaysfaith.github.io/img/gc/7-1</a> 垃圾回收之标记算法_慕课网[00_06_08][20200324-135046].jpg)</p><h2 id="7-2-Java垃圾回收之回收算法"><a href="#7-2-Java垃圾回收之回收算法" class="headerlink" title="7-2 Java垃圾回收之回收算法"></a>7-2 Java垃圾回收之回收算法</h2><p>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_00_29][20200324-135132].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_01_24][20200324-135242].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_02_03][20200324-135332].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_02_23][20200324-135352].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_03_12][20200324-135450].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_03_49][20200324-135528].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_04_10][20200324-135605].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_04_17][20200324-135622].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_04_27][20200324-135632].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_05_13][20200324-135729].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_06_39][20200324-135855].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_07_13][20200324-135956].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_07_52][20200324-140045].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_08_23][20200324-140117].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_09_53][20200324-140256].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_10_40][20200324-140354].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_11_17][20200324-140441].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_11_52][20200324-140526].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-2">https://alwaysfaith.github.io/img/gc/7-2</a> Java垃圾回收之回收算法_慕课[00_14_25][20200324-140759].jpg)</p><h2 id="7-3-Java垃圾回收之新生代垃圾收集"><a href="#7-3-Java垃圾回收之新生代垃圾收集" class="headerlink" title="7-3 Java垃圾回收之新生代垃圾收集"></a>7-3 Java垃圾回收之新生代垃圾收集</h2><p>![](<a href="https://alwaysfaith.github.io/img/gc/7-3">https://alwaysfaith.github.io/img/gc/7-3</a> Java垃圾回收之新生代垃圾收集[00_00_17][20200324-140930].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-3">https://alwaysfaith.github.io/img/gc/7-3</a> Java垃圾回收之新生代垃圾收集[00_01_16][20200324-141039].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-3">https://alwaysfaith.github.io/img/gc/7-3</a> Java垃圾回收之新生代垃圾收集[00_01_56][20200324-141157].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-3">https://alwaysfaith.github.io/img/gc/7-3</a> Java垃圾回收之新生代垃圾收集[00_03_46][20200324-141347].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-3">https://alwaysfaith.github.io/img/gc/7-3</a> Java垃圾回收之新生代垃圾收集[00_04_36][20200324-141437].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-3">https://alwaysfaith.github.io/img/gc/7-3</a> Java垃圾回收之新生代垃圾收集[00_05_11][20200324-141522].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-3">https://alwaysfaith.github.io/img/gc/7-3</a> Java垃圾回收之新生代垃圾收集[00_05_57][20200324-141609].jpg)</p><h2 id="7-4-Java垃圾回收之老年垃圾收集器"><a href="#7-4-Java垃圾回收之老年垃圾收集器" class="headerlink" title="7-4 Java垃圾回收之老年垃圾收集器"></a>7-4 Java垃圾回收之老年垃圾收集器</h2><p>![](<a href="https://alwaysfaith.github.io/img/gc/7-4">https://alwaysfaith.github.io/img/gc/7-4</a> Java垃圾回收之老年垃圾收集器[00_00_21][20200324-141653].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-4">https://alwaysfaith.github.io/img/gc/7-4</a> Java垃圾回收之老年垃圾收集器[00_01_17][20200324-141800].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-4">https://alwaysfaith.github.io/img/gc/7-4</a> Java垃圾回收之老年垃圾收集器[00_03_09][20200324-141952].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-4">https://alwaysfaith.github.io/img/gc/7-4</a> Java垃圾回收之老年垃圾收集器[00_03_41][20200324-142033].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-4">https://alwaysfaith.github.io/img/gc/7-4</a> Java垃圾回收之老年垃圾收集器[00_04_36][20200324-142139].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-4">https://alwaysfaith.github.io/img/gc/7-4</a> Java垃圾回收之老年垃圾收集器[00_05_49][20200324-142302].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-4">https://alwaysfaith.github.io/img/gc/7-4</a> Java垃圾回收之老年垃圾收集器[00_06_47][20200324-142653].jpg)</p><h2 id="7-5-Java垃圾回收之常见面试题-1"><a href="#7-5-Java垃圾回收之常见面试题-1" class="headerlink" title="7-5 Java垃圾回收之常见面试题-1"></a>7-5 Java垃圾回收之常见面试题-1</h2><p>![](<a href="https://alwaysfaith.github.io/img/gc/7-5">https://alwaysfaith.github.io/img/gc/7-5</a> Java垃圾回收之常见面试题_慕[00_00_54][20200324-142812].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-5">https://alwaysfaith.github.io/img/gc/7-5</a> Java垃圾回收之常见面试题_慕[00_05_28][20200324-143306].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-5">https://alwaysfaith.github.io/img/gc/7-5</a> Java垃圾回收之常见面试题_慕[00_06_24][20200324-143412].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-5">https://alwaysfaith.github.io/img/gc/7-5</a> Java垃圾回收之常见面试题_慕[00_07_13][20200324-143502].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-5">https://alwaysfaith.github.io/img/gc/7-5</a> Java垃圾回收之常见面试题_慕[00_07_59][20200324-143548].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-5">https://alwaysfaith.github.io/img/gc/7-5</a> Java垃圾回收之常见面试题_慕[00_08_53][20200324-143642].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/gc/7-5">https://alwaysfaith.github.io/img/gc/7-5</a> Java垃圾回收之常见面试题_慕[00_09_41][20200324-143739].jpg)</p><h2 id="7-6-Java垃圾回收之常见面试题-2"><a href="#7-6-Java垃圾回收之常见面试题-2" class="headerlink" title="7-6 Java垃圾回收之常见面试题-2"></a>7-6 Java垃圾回收之常见面试题-2</h2><p>![](<a href="https://alwaysfaith.github.io/img/gc/7-6">https://alwaysfaith.github.io/img/gc/7-6</a> Java垃圾回收之常见面试题_2[00_09_45][20200324-144813].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第5章 Linux</title>
    <link href="/2020/03/23/2020-03-23-%E7%AC%AC5%E7%AB%A0-Linux/"/>
    <url>/2020/03/23/2020-03-23-%E7%AC%AC5%E7%AB%A0-Linux/</url>
    
    <content type="html"><![CDATA[<h2 id="5-1-Linux的体系结构"><a href="#5-1-Linux的体系结构" class="headerlink" title="5-1 Linux的体系结构"></a>5-1 Linux的体系结构</h2><p>![](<a href="https://alwaysfaith.github.io/img/linux/5-1">https://alwaysfaith.github.io/img/linux/5-1</a> Linux的体系结构_慕课网[00_02_48][20200323-104703].jpg)</p><h2 id="5-2-查找特定文件"><a href="#5-2-查找特定文件" class="headerlink" title="5-2 查找特定文件"></a>5-2 查找特定文件</h2><p>![](<a href="https://alwaysfaith.github.io/img/linux/5-2">https://alwaysfaith.github.io/img/linux/5-2</a> 查找特定文件_慕课网[00_00_37][20200323-105612].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-2">https://alwaysfaith.github.io/img/linux/5-2</a> 查找特定文件_慕课网[00_01_10][20200323-105645].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-2">https://alwaysfaith.github.io/img/linux/5-2</a> 查找特定文件_慕课网[00_01_52][20200323-105738].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-2">https://alwaysfaith.github.io/img/linux/5-2</a> 查找特定文件_慕课网[00_03_20][20200323-110123].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-2">https://alwaysfaith.github.io/img/linux/5-2</a> 查找特定文件_慕课网[00_04_09][20200323-110635].jpg)</p><h2 id="5-3-检索文件内容"><a href="#5-3-检索文件内容" class="headerlink" title="5-3 检索文件内容"></a>5-3 检索文件内容</h2><p>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_00_31][20200323-111128].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_02_05][20200323-111943].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_02_47][20200323-112047].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_03_47][20200323-112159].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_04_52][20200323-112314].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_07_16][20200323-112931].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_08_21][20200323-112902].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-3">https://alwaysfaith.github.io/img/linux/5-3</a> 检索文件内容_慕课网[00_08_57][20200323-113003].jpg)</p><h2 id="5-4-对日志内容做统计"><a href="#5-4-对日志内容做统计" class="headerlink" title="5-4 对日志内容做统计"></a>5-4 对日志内容做统计</h2><p>![](<a href="https://alwaysfaith.github.io/img/linux/5-4">https://alwaysfaith.github.io/img/linux/5-4</a> 对日志内容做统计_慕课网[00_00_59][20200323-113221].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-4">https://alwaysfaith.github.io/img/linux/5-4</a> 对日志内容做统计_慕课网[00_02_00][20200323-113330].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-4">https://alwaysfaith.github.io/img/linux/5-4</a> 对日志内容做统计_慕课网[00_04_12][20200323-142303].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-4">https://alwaysfaith.github.io/img/linux/5-4</a> 对日志内容做统计_慕课网[00_06_58][20200323-142602].jpg)</p><h2 id="5-5-批量替换文件内容及本章小结"><a href="#5-5-批量替换文件内容及本章小结" class="headerlink" title="5-5 批量替换文件内容及本章小结"></a>5-5 批量替换文件内容及本章小结</h2><p>![](<a href="https://alwaysfaith.github.io/img/linux/5-5">https://alwaysfaith.github.io/img/linux/5-5</a> 批量替换文件内容及本章小结_慕课[00_02_46][20200323-142916].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-5">https://alwaysfaith.github.io/img/linux/5-5</a> 批量替换文件内容及本章小结_慕课[00_03_44][20200323-143027].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-5">https://alwaysfaith.github.io/img/linux/5-5</a> 批量替换文件内容及本章小结_慕课[00_04_21][20200323-143142].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-5">https://alwaysfaith.github.io/img/linux/5-5</a> 批量替换文件内容及本章小结_慕课[00_05_44][20200323-143305].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/linux/5-5">https://alwaysfaith.github.io/img/linux/5-5</a> 批量替换文件内容及本章小结_慕课[00_06_34][20200323-143358].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第4章-Redis</title>
    <link href="/2020/03/19/2020-03-19-%E7%AC%AC4%E7%AB%A0-Redis/"/>
    <url>/2020/03/19/2020-03-19-%E7%AC%AC4%E7%AB%A0-Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-Redis简介"><a href="#4-1-Redis简介" class="headerlink" title="4-1 Redis简介"></a>4-1 Redis简介</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_00_51][20200318-153004].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_02_13][20200318-153137].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_03_01][20200318-153224].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_06_38][20200318-153612].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_06_53][20200318-154029].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_07_26][20200318-153700].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_07_56][20200318-153731].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-1">https://alwaysfaith.github.io/img/redis/4-1</a> Redis简介_慕课网[00_09_49][20200318-153923].jpg)</p><h2 id="4-2-Redis常用数据类型"><a href="#4-2-Redis常用数据类型" class="headerlink" title="4-2 Redis常用数据类型"></a>4-2 Redis常用数据类型</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-2">https://alwaysfaith.github.io/img/redis/4-2</a> Redis常用数据类型_慕课网[00_09_23][20200318-155013].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-2">https://alwaysfaith.github.io/img/redis/4-2</a> Redis常用数据类型_慕课网[00_09_53][20200318-155055].jpg)</p><h2 id="4-3-从海量数据里查询某一固定前缀的key"><a href="#4-3-从海量数据里查询某一固定前缀的key" class="headerlink" title="4-3 从海量数据里查询某一固定前缀的key"></a>4-3 从海量数据里查询某一固定前缀的key</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-3">https://alwaysfaith.github.io/img/redis/4-3</a> 从海量数据里查询某一固定前缀的k[00_00_30][20200318-155153].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-3">https://alwaysfaith.github.io/img/redis/4-3</a> 从海量数据里查询某一固定前缀的k[00_01_37][20200318-155504].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-3">https://alwaysfaith.github.io/img/redis/4-3</a> 从海量数据里查询某一固定前缀的k[00_01_53][20200318-155326].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-3">https://alwaysfaith.github.io/img/redis/4-3</a> 从海量数据里查询某一固定前缀的k[00_03_59][20200318-155627].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-3">https://alwaysfaith.github.io/img/redis/4-3</a> 从海量数据里查询某一固定前缀的k[00_05_56][20200318-155824].jpg)</p><h2 id="4-4-如何实现分布式锁"><a href="#4-4-如何实现分布式锁" class="headerlink" title="4-4 如何实现分布式锁"></a>4-4 如何实现分布式锁</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_00_49][20200318-160318].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_01_21][20200318-160401].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_03_43][20200318-160631].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_04_55][20200318-160916].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_05_46][20200318-161021].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_06_41][20200318-161502].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_06_47][20200318-161527].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-4">https://alwaysfaith.github.io/img/redis/4-4</a> 如何实现分布式锁_慕课网[00_07_28][20200318-161608].jpg)</p><h2 id="4-5-如何实现异步队列"><a href="#4-5-如何实现异步队列" class="headerlink" title="4-5 如何实现异步队列"></a>4-5 如何实现异步队列</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-5">https://alwaysfaith.github.io/img/redis/4-5</a> 如何实现异步队列_慕课网[00_01_00][20200318-173702].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-5">https://alwaysfaith.github.io/img/redis/4-5</a> 如何实现异步队列_慕课网[00_02_07][20200318-173947].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-5">https://alwaysfaith.github.io/img/redis/4-5</a> 如何实现异步队列_慕课网[00_02_16][20200318-173843].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-5">https://alwaysfaith.github.io/img/redis/4-5</a> 如何实现异步队列_慕课网[00_02_38][20200318-173916].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-5">https://alwaysfaith.github.io/img/redis/4-5</a> 如何实现异步队列_慕课网[00_02_45][20200318-173922].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-5">https://alwaysfaith.github.io/img/redis/4-5</a> 如何实现异步队列_慕课网[00_04_27][20200318-174143].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-5">https://alwaysfaith.github.io/img/redis/4-5</a> 如何实现异步队列_慕课网[00_04_54][20200318-174211].jpg)</p><h2 id="4-6-持久化方式之RDB"><a href="#4-6-持久化方式之RDB" class="headerlink" title="4-6 持久化方式之RDB"></a>4-6 持久化方式之RDB</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-6">https://alwaysfaith.github.io/img/redis/4-6</a> 持久化方式之RDB_慕课网1[00_03_31][20200318-174759].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-6">https://alwaysfaith.github.io/img/redis/4-6</a> 持久化方式之RDB_慕课网1[00_05_55][20200318-174919].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-6">https://alwaysfaith.github.io/img/redis/4-6</a> 持久化方式之RDB_慕课网1[00_07_01][20200318-175114].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-6">https://alwaysfaith.github.io/img/redis/4-6</a> 持久化方式之RDB_慕课网1[00_08_53][20200318-175338].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-6">https://alwaysfaith.github.io/img/redis/4-6</a> 持久化方式之RDB_慕课网1[00_09_25][20200318-175412].jpg)</p><h2 id="4-7-持久化方式之AOF以及混合模式"><a href="#4-7-持久化方式之AOF以及混合模式" class="headerlink" title="4-7 持久化方式之AOF以及混合模式"></a>4-7 持久化方式之AOF以及混合模式</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_00_26][20200319-135913].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_00_54][20200319-140018].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_03_08][20200319-140245].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_04_32][20200319-140409].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_05_16][20200319-140454].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_05_57][20200319-140534].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_06_40][20200319-140617].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-7">https://alwaysfaith.github.io/img/redis/4-7</a> 持久化方式之AOF以及混合模式_[00_07_52][20200319-140729].jpg)</p><h2 id="4-8-Pipeline及主从同步"><a href="#4-8-Pipeline及主从同步" class="headerlink" title="4-8 Pipeline及主从同步"></a>4-8 Pipeline及主从同步</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-8">https://alwaysfaith.github.io/img/redis/4-8</a> Pipeline及主从同步_慕课[00_01_45][20200319-140944].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-8">https://alwaysfaith.github.io/img/redis/4-8</a> Pipeline及主从同步_慕课[00_03_20][20200319-141129].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-8">https://alwaysfaith.github.io/img/redis/4-8</a> Pipeline及主从同步_慕课[00_04_11][20200319-141219].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-8">https://alwaysfaith.github.io/img/redis/4-8</a> Pipeline及主从同步_慕课[00_05_23][20200319-141338].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-8">https://alwaysfaith.github.io/img/redis/4-8</a> Pipeline及主从同步_慕课[00_06_51][20200319-141517].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-8">https://alwaysfaith.github.io/img/redis/4-8</a> Pipeline及主从同步_慕课[00_08_12][20200319-141638].jpg)</p><h2 id="4-9-Redis集群"><a href="#4-9-Redis集群" class="headerlink" title="4-9 Redis集群"></a>4-9 Redis集群</h2><p>![](<a href="https://alwaysfaith.github.io/img/redis/4-9">https://alwaysfaith.github.io/img/redis/4-9</a> Redis集群_慕课网[00_00_50][20200319-141751].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-9">https://alwaysfaith.github.io/img/redis/4-9</a> Redis集群_慕课网[00_01_34][20200319-142313].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-9">https://alwaysfaith.github.io/img/redis/4-9</a> Redis集群_慕课网[00_02_31][20200319-142411].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-9">https://alwaysfaith.github.io/img/redis/4-9</a> Redis集群_慕课网[00_03_21][20200319-142501].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-9">https://alwaysfaith.github.io/img/redis/4-9</a> Redis集群_慕课网[00_03_28][20200319-142508].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-9">https://alwaysfaith.github.io/img/redis/4-9</a> Redis集群_慕课网[00_04_09][20200319-142609].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/redis/4-9">https://alwaysfaith.github.io/img/redis/4-9</a> Redis集群_慕课网[00_04_43][20200319-142644].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第3章-数据库</title>
    <link href="/2020/03/16/2020-03-16-%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/03/16/2020-03-16-%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-数据库架构"><a href="#3-1-数据库架构" class="headerlink" title="3-1 数据库架构"></a>3-1 数据库架构</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-1">https://alwaysfaith.github.io/img/mysql/3-1</a> 数据库架构_慕课网[00_00_32][20200306-165030].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-1">https://alwaysfaith.github.io/img/mysql/3-1</a> 数据库架构_慕课网[00_02_39][20200306-165900].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-1">https://alwaysfaith.github.io/img/mysql/3-1</a> 数据库架构_慕课网[00_07_08][20200306-165922].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-1">https://alwaysfaith.github.io/img/mysql/3-1</a> 数据库架构_慕课网[00_07_38][20200311-103949].jpg)</p><h3 id="3-1-1-1、为什么要使用索引"><a href="#3-1-1-1、为什么要使用索引" class="headerlink" title="3-1-1 1、为什么要使用索引"></a>3-1-1 1、为什么要使用索引</h3><p>因为索引能够让我们避免全表扫描去查找数据，提升检索效率</p><h3 id="3-1-2-2、什么样的信息能成为索引"><a href="#3-1-2-2、什么样的信息能成为索引" class="headerlink" title="3-1-2 2、什么样的信息能成为索引"></a>3-1-2 2、什么样的信息能成为索引</h3><p>主键、唯一键等，只要是能让数据具备一定区分性的字段都能成为索引</p><h3 id="3-1-3-3、索引的数据结构"><a href="#3-1-3-3、索引的数据结构" class="headerlink" title="3-1-3 3、索引的数据结构"></a>3-1-3 3、索引的数据结构</h3><p>主流B+Tree、Hash结构以及BitMap等，其中mysql数据库不支持BitMap索引,同时基于InnoDB以及MyISAM引擎的mysql不显示支持Hash<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-1">https://alwaysfaith.github.io/img/mysql/3-1</a> 数据库架构_慕课网[00_09_09][20200311-104141].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-1">https://alwaysfaith.github.io/img/mysql/3-1</a> 数据库架构_慕课网[00_09_37][20200311-104220].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-1">https://alwaysfaith.github.io/img/mysql/3-1</a> 数据库架构_慕课网[00_10_23][20200311-104306].jpg)</p><h2 id="3-2-优化你的索引"><a href="#3-2-优化你的索引" class="headerlink" title="3-2 优化你的索引"></a>3-2 优化你的索引</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-2">https://alwaysfaith.github.io/img/mysql/3-2</a> 优化你的索引-运用二叉查找树_慕[00_02_45][20200311-104640].jpg)</p><h2 id="3-3-优化你的索引-运用B树"><a href="#3-3-优化你的索引-运用B树" class="headerlink" title="3-3 优化你的索引-运用B树"></a>3-3 优化你的索引-运用B树</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-3">https://alwaysfaith.github.io/img/mysql/3-3</a> 优化你的索引-运用B树 _慕课网[00_00_32][20200311-104852].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-3">https://alwaysfaith.github.io/img/mysql/3-3</a> 优化你的索引-运用B树 _慕课网[00_02_36][20200311-105056].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-3">https://alwaysfaith.github.io/img/mysql/3-3</a> 优化你的索引-运用B树 _慕课网[00_05_42][20200311-105442].jpg)</p><h2 id="3-4-优化你的索引-运用B-树"><a href="#3-4-优化你的索引-运用B-树" class="headerlink" title="3-4 优化你的索引-运用B+树"></a>3-4 优化你的索引-运用B+树</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-4">https://alwaysfaith.github.io/img/mysql/3-4</a> 优化你的索引-运用B+树_慕课网[00_00_30][20200311-105704].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-4">https://alwaysfaith.github.io/img/mysql/3-4</a> 优化你的索引-运用B+树_慕课网[00_03_20][20200311-110005].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-4">https://alwaysfaith.github.io/img/mysql/3-4</a> 优化你的索引-运用B+树_慕课网[00_05_38][20200311-110229].jpg)</p><h2 id="3-5-优化你的索引-运用Hash以及B"><a href="#3-5-优化你的索引-运用Hash以及B" class="headerlink" title="3-5 优化你的索引-运用Hash以及B"></a>3-5 优化你的索引-运用Hash以及B</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-5">https://alwaysfaith.github.io/img/mysql/3-5</a> 优化你的索引-运用Hash以及B[00_00_54][20200311-110949].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-5">https://alwaysfaith.github.io/img/mysql/3-5</a> 优化你的索引-运用Hash以及B[00_02_53][20200311-111148].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-5">https://alwaysfaith.github.io/img/mysql/3-5</a> 优化你的索引-运用Hash以及B[00_04_36][20200311-111331].jpg)</p><h2 id="3-6-密集索引和稀疏索引的区别"><a href="#3-6-密集索引和稀疏索引的区别" class="headerlink" title="3-6 密集索引和稀疏索引的区别"></a>3-6 密集索引和稀疏索引的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-6">https://alwaysfaith.github.io/img/mysql/3-6</a> 密集索引和稀疏索引的区别_慕课网[00_00_16][20200311-134444].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-6">https://alwaysfaith.github.io/img/mysql/3-6</a> 密集索引和稀疏索引的区别_慕课网[00_01_03][20200311-134531].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-6">https://alwaysfaith.github.io/img/mysql/3-6</a> 密集索引和稀疏索引的区别_慕课网[00_02_19][20200311-134821].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-6">https://alwaysfaith.github.io/img/mysql/3-6</a> 密集索引和稀疏索引的区别_慕课网[00_03_12][20200311-134915].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-6">https://alwaysfaith.github.io/img/mysql/3-6</a> 密集索引和稀疏索引的区别_慕课网[00_06_02][20200311-135235].jpg)</p><h2 id="3-7-索引额外的问题之如何调优Sql"><a href="#3-7-索引额外的问题之如何调优Sql" class="headerlink" title="3-7 索引额外的问题之如何调优Sql"></a>3-7 索引额外的问题之如何调优Sql</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_01_17][20200311-142140].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_01_48][20200311-142236].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_05_09][20200311-142722].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_07_50][20200311-143015].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_09_36][20200311-143440].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_09_38][20200311-143308].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_10_12][20200311-143538].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_10_27][20200311-143603].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_10_41][20200311-143617].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_17_43][20200311-144328].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-7">https://alwaysfaith.github.io/img/mysql/3-7</a> 索引额外的问题之如何调优Sql_[00_20_19][20200311-154312].jpg)</p><h2 id="3-8-索引额外问题之最左匹配原则的成因"><a href="#3-8-索引额外问题之最左匹配原则的成因" class="headerlink" title="3-8 索引额外问题之最左匹配原则的成因"></a>3-8 索引额外问题之最左匹配原则的成因</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-8">https://alwaysfaith.github.io/img/mysql/3-8</a> 索引额外问题之最左匹配原则的成因[00_04_32][20200311-154909].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-8">https://alwaysfaith.github.io/img/mysql/3-8</a> 索引额外问题之最左匹配原则的成因[00_06_14][20200311-155138].jpg)</p><h2 id="3-9-索引额外问题之索引是建立越多越好"><a href="#3-9-索引额外问题之索引是建立越多越好" class="headerlink" title="3-9 索引额外问题之索引是建立越多越好"></a>3-9 索引额外问题之索引是建立越多越好</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-9">https://alwaysfaith.github.io/img/mysql/3-9</a> 索引额外问题之索引是建立越多越好[00_00_38][20200311-155238].jpg)</p><h2 id="3-10-锁模块之MyISAM与InnoDB-1"><a href="#3-10-锁模块之MyISAM与InnoDB-1" class="headerlink" title="3-10 锁模块之MyISAM与InnoDB_1"></a>3-10 锁模块之MyISAM与InnoDB_1</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-10">https://alwaysfaith.github.io/img/mysql/3-10</a> 锁模块之MyISAM与Inoo[00_00_36][20200311-155412].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-10">https://alwaysfaith.github.io/img/mysql/3-10</a> 锁模块之MyISAM与Inoo[00_08_41][20200311-160811].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-10">https://alwaysfaith.github.io/img/mysql/3-10</a> 锁模块之MyISAM与Inoo[00_08_47][20200311-160858].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-10">https://alwaysfaith.github.io/img/mysql/3-10</a> 锁模块之MyISAM与Inoo[00_14_50][20200311-161539].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-10">https://alwaysfaith.github.io/img/mysql/3-10</a> 锁模块之MyISAM与Inoo[00_15_01][20200311-161550].jpg)</p><h2 id="3-11-锁模块之MyISAM与InnoDB-2"><a href="#3-11-锁模块之MyISAM与InnoDB-2" class="headerlink" title="3-11 锁模块之MyISAM与InnoDB_2"></a>3-11 锁模块之MyISAM与InnoDB_2</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_03_19][20200311-162335].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_04_21][20200311-162534].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_05_15][20200311-162643].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_07_04][20200311-162853].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_07_27][20200311-162936].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_10_46][20200311-163306].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_15_26][20200311-163848].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-11">https://alwaysfaith.github.io/img/mysql/3-11</a> 锁模块之MyISAM与Inoo[00_15_37][20200311-163858].jpg)</p><h2 id="3-12-锁模块之数据库事务的四大特性"><a href="#3-12-锁模块之数据库事务的四大特性" class="headerlink" title="3-12 锁模块之数据库事务的四大特性"></a>3-12 锁模块之数据库事务的四大特性</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-12">https://alwaysfaith.github.io/img/mysql/3-12</a> 锁模块之数据库事务的四大特性_[00_01_55][20200311-164211].jpg)</p><h2 id="3-13-锁模块之事务并发访问产生的问题"><a href="#3-13-锁模块之事务并发访问产生的问题" class="headerlink" title="3-13 锁模块之事务并发访问产生的问题"></a>3-13 锁模块之事务并发访问产生的问题</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-13">https://alwaysfaith.github.io/img/mysql/3-13</a> 锁模块之事务并发访问产生的问题[00_10_24][20200311-174630].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-13">https://alwaysfaith.github.io/img/mysql/3-13</a> 锁模块之事务并发访问产生的问题[00_10_28][20200311-174744].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-13">https://alwaysfaith.github.io/img/mysql/3-13</a> 锁模块之事务并发访问产生的问题[00_12_01][20200311-175112].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-13">https://alwaysfaith.github.io/img/mysql/3-13</a> 锁模块之事务并发访问产生的问题[00_12_13][20200311-175029].jpg)</p><h2 id="3-14-锁模块之事务并发访问产生的问题"><a href="#3-14-锁模块之事务并发访问产生的问题" class="headerlink" title="3-14 锁模块之事务并发访问产生的问题"></a>3-14 锁模块之事务并发访问产生的问题</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-14">https://alwaysfaith.github.io/img/mysql/3-14</a> 锁模块之事务并发访问产生的问题[00_02_08][20200312-171340].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-14">https://alwaysfaith.github.io/img/mysql/3-14</a> 锁模块之事务并发访问产生的问题[00_03_21][20200312-171114].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-14">https://alwaysfaith.github.io/img/mysql/3-14</a> 锁模块之事务并发访问产生的问题[00_04_00][20200312-171220].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-14">https://alwaysfaith.github.io/img/mysql/3-14</a> 锁模块之事务并发访问产生的问题[00_10_23][20200313-114431].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-14">https://alwaysfaith.github.io/img/mysql/3-14</a> 锁模块之事务并发访问产生的问题[00_10_46][20200313-114440].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-14">https://alwaysfaith.github.io/img/mysql/3-14</a> 锁模块之事务并发访问产生的问题[00_11_06][20200313-114226].jpg)</p><h2 id="3-15-锁模块之当前读和快照读"><a href="#3-15-锁模块之当前读和快照读" class="headerlink" title="3-15 锁模块之当前读和快照读"></a>3-15 锁模块之当前读和快照读</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_00_28][20200313-145419].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_01_55][20200313-145427].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_03_24][20200313-145435].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_03_40][20200313-143955].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_03_45][20200313-144001].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_05_05][20200313-144124].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_05_28][20200313-144149].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_05_32][20200313-144154].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_11_49][20200313-145512].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_12_33][20200313-145516].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-15">https://alwaysfaith.github.io/img/mysql/3-15</a> 锁模块之当前读和快照读_慕课网[00_16_36][20200313-145300].jpg)</p><h2 id="3-16-锁模块之RR如何避免幻读"><a href="#3-16-锁模块之RR如何避免幻读" class="headerlink" title="3-16 锁模块之RR如何避免幻读"></a>3-16 锁模块之RR如何避免幻读</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_00_33][20200313-145746].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_01_27][20200313-145850].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_04_07][20200313-150130].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_06_57][20200313-150441].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_07_08][20200313-150452].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_07_58][20200313-150644].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_08_40][20200313-150635].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_09_55][20200313-151630].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_12_00][20200313-151851].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_13_06][20200313-152028].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_13_21][20200313-152043].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-16">https://alwaysfaith.github.io/img/mysql/3-16</a> 锁模块之RR如何避免幻读_慕课[00_18_00][20200313-152522].jpg)</p><h2 id="3-17-锁模块小结"><a href="#3-17-锁模块小结" class="headerlink" title="3-17 锁模块小结"></a>3-17 锁模块小结</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-17">https://alwaysfaith.github.io/img/mysql/3-17</a> 锁模块小结_慕课网[00_00_50][20200313-152706].jpg)</p><h2 id="3-18-关键语法讲解"><a href="#3-18-关键语法讲解" class="headerlink" title="3-18 关键语法讲解"></a>3-18 关键语法讲解</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_01_14][20200313-152901].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_02_03][20200313-153000].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_02_30][20200313-153048].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_02_42][20200313-153050].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_02_58][20200313-153106].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_03_07][20200313-153117].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_11_06][20200316-112840].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_11_07][20200316-112852].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_11_40][20200316-112955].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_13_53][20200316-113506].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_14_47][20200316-113910].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_15_05][20200316-113945].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-18">https://alwaysfaith.github.io/img/mysql/3-18</a> 关键语法讲解_慕课网[00_17_35][20200316-135125].jpg)</p><h2 id="3-19-本章总结"><a href="#3-19-本章总结" class="headerlink" title="3-19 本章总结"></a>3-19 本章总结</h2><p>![](<a href="https://alwaysfaith.github.io/img/mysql/3-19">https://alwaysfaith.github.io/img/mysql/3-19</a> 本章总结_慕课网[00_00_32][20200316-135321].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/mysql/3-19">https://alwaysfaith.github.io/img/mysql/3-19</a> 本章总结_慕课网[00_00_44][20200316-135333].jpg)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第2章-计算机网络面试核心</title>
    <link href="/2020/02/25/2020-02-25-%E7%AC%AC2%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/"/>
    <url>/2020/02/25/2020-02-25-%E7%AC%AC2%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="2-1-网络基础知识"><a href="#2-1-网络基础知识" class="headerlink" title="2-1 网络基础知识"></a>2-1 网络基础知识</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-1">https://alwaysfaith.github.io/img/network/2-1</a> 网络基础知识讲解_慕课网[00_08_45][20200225-141830].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-1">https://alwaysfaith.github.io/img/network/2-1</a> 网络基础知识讲解_慕课网[00_10_33][20200225-141839].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-1">https://alwaysfaith.github.io/img/network/2-1</a> 网络基础知识讲解_慕课网[00_11_47][20200225-141843].jpg)</p><h2 id="2-2-TCP的三次握手-1"><a href="#2-2-TCP的三次握手-1" class="headerlink" title="2-2 TCP的三次握手-1"></a>2-2 TCP的三次握手-1</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-2">https://alwaysfaith.github.io/img/network/2-2</a> TCP的三次握手_1_慕课网2[00_01_34][20200225-141915].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-2">https://alwaysfaith.github.io/img/network/2-2</a> TCP的三次握手_1_慕课网2[00_01_41][20200225-141922].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-2">https://alwaysfaith.github.io/img/network/2-2</a> TCP的三次握手_1_慕课网2[00_05_19][20200225-141934].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-2">https://alwaysfaith.github.io/img/network/2-2</a> TCP的三次握手_1_慕课网2[00_07_09][20200225-141946].jpg)</p><h2 id="2-3-TCP的三次握手-2"><a href="#2-3-TCP的三次握手-2" class="headerlink" title="2-3 TCP的三次握手-2"></a>2-3 TCP的三次握手-2</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-3">https://alwaysfaith.github.io/img/network/2-3</a> TCP的三次握手_2_慕课网2[00_04_44][20200225-142036].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-3">https://alwaysfaith.github.io/img/network/2-3</a> TCP的三次握手_2_慕课网2[00_06_39][20200225-142042].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-3">https://alwaysfaith.github.io/img/network/2-3</a> TCP的三次握手_2_慕课网2[00_07_50][20200225-142055].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-3">https://alwaysfaith.github.io/img/network/2-3</a> TCP的三次握手_2_慕课网2[00_09_28][20200225-142103].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-3">https://alwaysfaith.github.io/img/network/2-3</a> TCP的三次握手_2_慕课网2[00_10_42][20200225-142119].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-3">https://alwaysfaith.github.io/img/network/2-3</a> TCP的三次握手_2_慕课网2[00_11_30][20200225-142209].jpg)</p><h2 id="2-4-TCP的四次挥手"><a href="#2-4-TCP的四次挥手" class="headerlink" title="2-4 TCP的四次挥手"></a>2-4 TCP的四次挥手</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-4">https://alwaysfaith.github.io/img/network/2-4</a> TCP的四次挥手_慕课网[00_01_06][20200225-142240].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-4">https://alwaysfaith.github.io/img/network/2-4</a> TCP的四次挥手_慕课网[00_05_25][20200225-142255].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-4">https://alwaysfaith.github.io/img/network/2-4</a> TCP的四次挥手_慕课网[00_07_02][20200225-142322].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-4">https://alwaysfaith.github.io/img/network/2-4</a> TCP的四次挥手_慕课网[00_07_48][20200225-142329].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-4">https://alwaysfaith.github.io/img/network/2-4</a> TCP的四次挥手_慕课网[00_08_47][20200225-142339].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-4">https://alwaysfaith.github.io/img/network/2-4</a> TCP的四次挥手_慕课网[00_10_00][20200225-142541].jpg)</p><h2 id="2-5-TCP和UDP的区别"><a href="#2-5-TCP和UDP的区别" class="headerlink" title="2-5 TCP和UDP的区别"></a>2-5 TCP和UDP的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-5">https://alwaysfaith.github.io/img/network/2-5</a> TCP和UDP的区别_慕课网[00_00_14][20200225-142622].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-5">https://alwaysfaith.github.io/img/network/2-5</a> TCP和UDP的区别_慕课网[00_02_02][20200225-142819].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-5">https://alwaysfaith.github.io/img/network/2-5</a> TCP和UDP的区别_慕课网[00_03_38][20200225-143047].jpg)</p><h2 id="2-6-TCP的滑窗"><a href="#2-6-TCP的滑窗" class="headerlink" title="2-6 TCP的滑窗"></a>2-6 TCP的滑窗</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-6">https://alwaysfaith.github.io/img/network/2-6</a> TCP的滑窗_慕课网[00_01_19][20200225-143254].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-6">https://alwaysfaith.github.io/img/network/2-6</a> TCP的滑窗_慕课网[00_02_38][20200225-143428].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-6">https://alwaysfaith.github.io/img/network/2-6</a> TCP的滑窗_慕课网[00_06_08][20200225-143808].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-6">https://alwaysfaith.github.io/img/network/2-6</a> TCP的滑窗_慕课网[00_07_55][20200225-145525].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-6">https://alwaysfaith.github.io/img/network/2-6</a> TCP的滑窗_慕课网[00_09_44][20200225-145716].jpg)</p><h2 id="2-7-HTTP相关-1"><a href="#2-7-HTTP相关-1" class="headerlink" title="2-7 HTTP相关-1"></a>2-7 HTTP相关-1</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_00_38][20200225-145751].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_02_57][20200225-150052].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_04_15][20200225-153156].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_05_33][20200225-153622].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_05_59][20200225-153717].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_07_20][20200225-154136].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_09_14][20200225-154428].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_10_45][20200225-154610].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-7">https://alwaysfaith.github.io/img/network/2-7</a> HTTP相关_慕课网[00_12_08][20200225-160045].jpg)</p><h2 id="2-8-HTTP相关-2"><a href="#2-8-HTTP相关-2" class="headerlink" title="2-8 HTTP相关-2"></a>2-8 HTTP相关-2</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-8">https://alwaysfaith.github.io/img/network/2-8</a> HTTP相关_2_慕课网[00_01_28][20200225-160256].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-8">https://alwaysfaith.github.io/img/network/2-8</a> HTTP相关_2_慕课网[00_06_16][20200225-160814].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-8">https://alwaysfaith.github.io/img/network/2-8</a> HTTP相关_2_慕课网[00_08_12][20200225-161020].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-8">https://alwaysfaith.github.io/img/network/2-8</a> HTTP相关_2_慕课网[00_08_33][20200225-161051].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-8">https://alwaysfaith.github.io/img/network/2-8</a> HTTP相关_2_慕课网[00_09_21][20200225-161159].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-8">https://alwaysfaith.github.io/img/network/2-8</a> HTTP相关_2_慕课网[00_10_22][20200225-161301].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-8">https://alwaysfaith.github.io/img/network/2-8</a> HTTP相关_2_慕课网[00_11_41][20200225-161419].jpg)</p><h2 id="2-9-HTTP和HTTPS的区别"><a href="#2-9-HTTP和HTTPS的区别" class="headerlink" title="2-9 HTTP和HTTPS的区别"></a>2-9 HTTP和HTTPS的区别</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-9">https://alwaysfaith.github.io/img/network/2-9</a> HTTP和HTTPS的区别_慕课[00_00_31][20200225-161525].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-9">https://alwaysfaith.github.io/img/network/2-9</a> HTTP和HTTPS的区别_慕课[00_03_12][20200225-161817].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-9">https://alwaysfaith.github.io/img/network/2-9</a> HTTP和HTTPS的区别_慕课[00_05_46][20200225-162050].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-9">https://alwaysfaith.github.io/img/network/2-9</a> HTTP和HTTPS的区别_慕课[00_06_55][20200225-162239].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-9">https://alwaysfaith.github.io/img/network/2-9</a> HTTP和HTTPS的区别_慕课[00_07_57][20200225-162409].jpg)</p><h2 id="2-10-socket相关"><a href="#2-10-socket相关" class="headerlink" title="2-10 socket相关"></a>2-10 socket相关</h2><p>![](<a href="https://alwaysfaith.github.io/img/network/2-10">https://alwaysfaith.github.io/img/network/2-10</a> socket相关_慕课网[00_01_07][20200225-162603].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-10">https://alwaysfaith.github.io/img/network/2-10</a> socket相关_慕课网[00_02_50][20200225-162758].jpg)<br>![](<a href="https://alwaysfaith.github.io/img/network/2-10">https://alwaysfaith.github.io/img/network/2-10</a> socket相关_慕课网[00_03_38][20200225-162903].jpg)</p><h3 id="2-10-1-socket相关-TCPClient"><a href="#2-10-1-socket相关-TCPClient" class="headerlink" title="2-10-1 socket相关-TCPClient"></a>2-10-1 socket相关-TCPClient</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.io.OutputStream;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建socket，并指定连接的是本机的端口号为65000的服务器socket</span>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">65000</span>);        <span class="hljs-comment">//获取输出流</span>        OutputStream os = socket.getOutputStream();        <span class="hljs-comment">//获取输入流</span>        InputStream is = socket.getInputStream();        <span class="hljs-comment">//将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流中</span>        os.write(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello world&quot;</span>).getBytes());        <span class="hljs-keyword">int</span> ch = <span class="hljs-number">0</span>;        <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-comment">//buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度</span>        ch = is.read(buff);        <span class="hljs-comment">//将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度</span>        String content = <span class="hljs-keyword">new</span> String(buff, <span class="hljs-number">0</span>, ch);        System.out.println(content);        <span class="hljs-comment">//不要忘记关闭输入输出流以及socket</span>        is.close();        os.close();        socket.close();    &#125;&#125;</code></pre><h3 id="2-10-2-socket相关-TCPServer"><a href="#2-10-2-socket相关-TCPServer" class="headerlink" title="2-10-2 socket相关-TCPServer"></a>2-10-2 socket相关-TCPServer</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.interview.javabasic.thread.MyThread;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建socket,并将socket绑定到65000端口</span>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">65000</span>);        <span class="hljs-comment">//死循环，使得socket一直等待并处理客户端发送过来的请求</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//监听65000端口，直到客户端返回连接信息后才返回</span>            Socket socket = ss.accept();            <span class="hljs-comment">//获取客户端的请求信息后，执行相关业务逻辑</span>            <span class="hljs-keyword">new</span> LengthCalculator(socket).start();        &#125;    &#125;&#125;</code></pre><h3 id="2-10-3-socket相关-UDPClient"><a href="#2-10-3-socket相关-UDPClient" class="headerlink" title="2-10-3 socket相关-UDPClient"></a>2-10-3 socket相关-UDPClient</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.DatagramPacket;<span class="hljs-keyword">import</span> java.net.DatagramSocket;<span class="hljs-keyword">import</span> java.net.InetAddress;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 客户端发数据报给服务端</span>        DatagramSocket socket = <span class="hljs-keyword">new</span> DatagramSocket();        <span class="hljs-comment">// 要发送给服务端的数据</span>        <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-string">&quot;Hello World&quot;</span>.getBytes();        <span class="hljs-comment">// 将IP地址封装成InetAddress对象</span>        InetAddress address = InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);        <span class="hljs-comment">// 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号</span>        DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(buf, buf.length, address,                <span class="hljs-number">65001</span>);        <span class="hljs-comment">// 发送数据给服务端</span>        socket.send(packet);        <span class="hljs-comment">// 客户端接受服务端发送过来的数据报</span>        <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];        <span class="hljs-comment">// 创建DatagramPacket对象用来存储服务端发送过来的数据</span>        DatagramPacket receivedPacket = <span class="hljs-keyword">new</span> DatagramPacket(data, data.length);        <span class="hljs-comment">// 将接受到的数据存储到DatagramPacket对象中</span>        socket.receive(receivedPacket);        <span class="hljs-comment">// 将服务器端发送过来的数据取出来并打印到控制台</span>        String content = <span class="hljs-keyword">new</span> String(receivedPacket.getData(), <span class="hljs-number">0</span>,                receivedPacket.getLength());        System.out.println(content);    &#125;&#125;</code></pre><h3 id="2-10-4-socket相关-UDPServer"><a href="#2-10-4-socket相关-UDPServer" class="headerlink" title="2-10-4 socket相关-UDPServer"></a>2-10-4 socket相关-UDPServer</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.DatagramPacket;<span class="hljs-keyword">import</span> java.net.DatagramSocket;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 服务端接受客户端发送的数据报</span>        DatagramSocket socket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">65001</span>); <span class="hljs-comment">//监听的端口号</span>        <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>]; <span class="hljs-comment">//存储从客户端接受到的内容</span>        DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(buff, buff.length);        <span class="hljs-comment">//接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中</span>        socket.receive(packet);        <span class="hljs-keyword">byte</span>[] data = packet.getData(); <span class="hljs-comment">//从DatagramPacket对象中获取到真正存储的数据</span>        <span class="hljs-comment">//将数据从二进制转换成字符串形式</span>        String content = <span class="hljs-keyword">new</span> String(data, <span class="hljs-number">0</span>, packet.getLength());        System.out.println(content);        <span class="hljs-comment">//将要发送给客户端的数据转换成二进制</span>        <span class="hljs-keyword">byte</span>[] sendedContent = String.valueOf(content.length()).getBytes();        <span class="hljs-comment">// 服务端给客户端发送数据报</span>        <span class="hljs-comment">//从DatagramPacket对象中获取到数据的来源地址与端口号</span>        DatagramPacket packetToClient = <span class="hljs-keyword">new</span> DatagramPacket(sendedContent,                sendedContent.length, packet.getAddress(), packet.getPort());        socket.send(packetToClient); <span class="hljs-comment">//发送数据给客户端</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次Collectors.toMap的问题</title>
    <link href="/2020/02/17/2020-02-17-%E4%B8%80%E6%AC%A1Collectors.toMap%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/17/2020-02-17-%E4%B8%80%E6%AC%A1Collectors.toMap%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Collections-toMap作用"><a href="#Collections-toMap作用" class="headerlink" title="Collections.toMap作用"></a>Collections.toMap作用</h2><p>将list按照规则转成map</p><pre><code class="hljs java">UserVO userVO1 = <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>, <span class="hljs-string">&quot;d1&quot;</span>);UserVO userVO2 = <span class="hljs-keyword">new</span> UserVO(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>, <span class="hljs-string">&quot;d1&quot;</span>);UserVO userVO3 = <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">&quot;A1&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>, <span class="hljs-string">&quot;d1&quot;</span>);UserVO userVO4 = <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">&quot;A2&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>, <span class="hljs-string">&quot;d1&quot;</span>);UserVO userVO5 = <span class="hljs-keyword">null</span>;UserVO userVO6 = <span class="hljs-keyword">new</span> UserVO();UserVO userVO7 = <span class="hljs-keyword">new</span> UserVO();List&lt;UserVO&gt; voList = Arrays.asList(userVO1, userVO2, userVO3,userVO4,userVO5,userVO6,userVO7);Map&lt;String, String&gt; stringMap = Optional.ofNullable(voList)        .map(Collection::stream)        .orElse(Stream.empty())        .collect(Collectors.toMap(UserVO::getId, UserVO::getUsername));</code></pre><h2 id="Collections-toMap-存在的问题"><a href="#Collections-toMap-存在的问题" class="headerlink" title="Collections.toMap 存在的问题"></a>Collections.toMap 存在的问题</h2><ol><li>空指针（map中value是null导致,map中key可以为null）</li><li>key值重复（Map中的key不能重复）<h3 id="1-解决方式"><a href="#1-解决方式" class="headerlink" title="1.解决方式"></a>1.解决方式</h3>使用stream的collect的重载方法：<pre><code class="hljs java">Map&lt;String, String&gt; stringHashMap = Optional.ofNullable(voList)        .map(Collection::stream)        .orElse(Stream.empty())        .collect(HashMap::<span class="hljs-keyword">new</span>, (m, v) -&gt;                m.put(v.getId(), v.getUsername()), HashMap::putAll);System.err.println(<span class="hljs-keyword">new</span> Gson().toJson(stringHashMap));<span class="hljs-comment">//&#123;&quot;&quot;:&quot;b1&quot;,&quot;A1&quot;:&quot;b1&quot;,&quot;A2&quot;:&quot;b1&quot;&#125;</span></code></pre><h3 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2.解决方式"></a>2.解决方式</h3>过滤Map中key，value不为空<pre><code class="hljs java">Map&lt;String, String&gt; stringMap2 = Optional.ofNullable(voList)              .map(Collection::stream)              .orElse(Stream.empty())              .filter(Objects::nonNull)              .filter(x -&gt; StrUtil.isNotBlank(x.getId()))              .filter(x -&gt; StrUtil.isNotBlank(x.getUsername()))              .collect(Collectors.toMap(UserVO::getId,                      UserVO::getUsername,                      (left, right) -&gt; right));      System.err.println(<span class="hljs-keyword">new</span> Gson().toJson(stringMap));      <span class="hljs-comment">//&#123;&quot;A1&quot;:&quot;b1&quot;,&quot;A2&quot;:&quot;b1&quot;&#125;</span></code></pre><h3 id="3-解决方式"><a href="#3-解决方式" class="headerlink" title="3.解决方式"></a>3.解决方式</h3><pre><code class="hljs java">Map&lt;String, String&gt; hashMap = Optional.ofNullable(voList)           .map(Collection::stream)           .orElse(Stream.empty())          .filter(Objects::nonNull)           .filter(x -&gt; StrUtil.isNotBlank(x.getId()))           .filter(x -&gt; StrUtil.isNotBlank(x.getUsername()))           .collect(Collectors.toMap(                   UserVO::getId,                   UserVO::getUsername,                   (left, right) -&gt; right,                   HashMap::<span class="hljs-keyword">new</span>));   System.err.println(<span class="hljs-keyword">new</span> Gson().toJson(hashMap));   <span class="hljs-comment">//&#123;&quot;A1&quot;:&quot;b1&quot;,&quot;A2&quot;:&quot;b1&quot;&#125;</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式的安全类</title>
    <link href="/2020/01/17/2020-01-17-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%89%E5%85%A8%E7%B1%BB/"/>
    <url>/2020/01/17/2020-01-17-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%89%E5%85%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写完这个题目,我感觉自己好像”孔乙己”啊,回字的四种写法要不要学啊~</p><p>我们经常会用到单例模式,但是我对他一直没有一个统一的的认识,比如我清楚好多种单例的写法,但是每一种是怎么演化来的?具体解决了什么问题?这块就没有那么清晰了,因此此文对单例模式进行一个总结,同时手撸一下代码加深理解.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例模式,即某一个类在整个系统中有且仅有一个实例.</p><p>经常用来读取配置,获取连接等等.</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>懒汉模式</p><p>单例实例在第一次使用时进行创建</p><p>非线程安全</p><pre><code class="hljs java"><span class="hljs-meta">@NotThreadSafe</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonExample1</span> </span>&#123;    <span class="hljs-comment">// 私有构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonExample1</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 单例对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonExample1 instance = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 静态的工厂方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonExample1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;            instance = <span class="hljs-keyword">new</span> SingletonExample1();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>饿汉模式</p><p>单例实例在类装载时进行创建</p><p>线程安全</p><pre><code class="hljs java"><span class="hljs-meta">@ThreadSafe</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonExample2</span> </span>&#123;    <span class="hljs-comment">// 私有构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonExample2</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 单例对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonExample2 instance = <span class="hljs-keyword">new</span> SingletonExample2();    <span class="hljs-comment">// 静态的工厂方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonExample2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><h2 id="懒汉模式-synchronized"><a href="#懒汉模式-synchronized" class="headerlink" title="懒汉模式 (synchronized)"></a>懒汉模式 (synchronized)</h2><p>静态的工厂方法synchronized修饰加锁,为线程安全类<br>但锁修饰范围过大，访问性能下降，不推荐</p><pre><code class="hljs java"><span class="hljs-meta">@ThreadSafe</span><span class="hljs-meta">@NotRecommend</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonExample3</span> </span>&#123;    <span class="hljs-comment">// 私有构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonExample3</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 单例对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonExample3 instance = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 静态的工厂方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonExample3 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;            instance = <span class="hljs-keyword">new</span> SingletonExample3();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><h2 id="双重同步锁单例模式（synchronized）"><a href="#双重同步锁单例模式（synchronized）" class="headerlink" title="双重同步锁单例模式（synchronized）"></a>双重同步锁单例模式（synchronized）</h2><p>懒汉模式 -》 双重同步锁单例模式</p><p>单例实例在第一次使用时进行创建</p><p>未使用volatile 修饰,JVM和cpu的优化，会发生指令重排,为非线程安全类</p><pre><code class="hljs java"><span class="hljs-meta">@NotThreadSafe</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonExample4</span> </span>&#123;    <span class="hljs-comment">// 私有构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonExample4</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 1、memory = allocate() 分配对象的内存空间</span>    <span class="hljs-comment">// 2、ctorInstance() 初始化对象</span>    <span class="hljs-comment">// 3、instance = memory 设置instance指向刚分配的内存</span>    <span class="hljs-comment">// JVM和cpu优化，发生了指令重排</span>    <span class="hljs-comment">// 1、memory = allocate() 分配对象的内存空间</span>    <span class="hljs-comment">// 3、instance = memory 设置instance指向刚分配的内存</span>    <span class="hljs-comment">// 2、ctorInstance() 初始化对象</span>    <span class="hljs-comment">// 单例对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonExample4 instance = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 静态的工厂方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonExample4 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 双重检测机制        // B</span>            <span class="hljs-keyword">synchronized</span> (SingletonExample4.class) &#123; <span class="hljs-comment">// 同步锁</span>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                    instance = <span class="hljs-keyword">new</span> SingletonExample4(); <span class="hljs-comment">// A - 3</span>                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><h2 id="双重同步锁单例模式（synchronized-volatile）"><a href="#双重同步锁单例模式（synchronized-volatile）" class="headerlink" title="双重同步锁单例模式（synchronized+volatile）"></a>双重同步锁单例模式（synchronized+volatile）</h2><p>懒汉模式 -》 双重同步锁单例模式</p><p>单例对象 使用volatile + 双重检测机制 -&gt; 禁止指令重排</p><pre><code class="hljs java"><span class="hljs-meta">@ThreadSafe</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonExample5</span> </span>&#123;    <span class="hljs-comment">// 私有构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonExample5</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 1、memory = allocate() 分配对象的内存空间</span>    <span class="hljs-comment">// 2、ctorInstance() 初始化对象</span>    <span class="hljs-comment">// 3、instance = memory 设置instance指向刚分配的内存</span>    <span class="hljs-comment">// 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> SingletonExample5 instance = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 静态的工厂方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonExample5 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 双重检测机制        // B</span>            <span class="hljs-keyword">synchronized</span> (SingletonExample5.class) &#123; <span class="hljs-comment">// 同步锁</span>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                    instance = <span class="hljs-keyword">new</span> SingletonExample5(); <span class="hljs-comment">// A - 3</span>                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><p>我们把Singleton实例放到一个静态内部类中，这样就避免了静态实例在Singleton类加载的时候就创建对象，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的：</p><pre><code class="hljs java"><span class="hljs-meta">@ThreadSafe</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonExample6</span> </span>&#123;    <span class="hljs-comment">// 私有构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonExample6</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 单例对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonExample6 instance = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">static</span> &#123;        instance = <span class="hljs-keyword">new</span> SingletonExample6();    &#125;    <span class="hljs-comment">// 静态的工厂方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonExample6 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(getInstance().hashCode());        System.out.println(getInstance().hashCode());    &#125;&#125;</code></pre><h2 id="枚举模式：最安全"><a href="#枚举模式：最安全" class="headerlink" title="枚举模式：最安全"></a>枚举模式：最安全</h2><p>上面的所有实现都有一点小问题:</p><ol><li>序列化与反序列化没有考虑,每次反序列化都能拿到一个新的实例.</li><li>反射,都可以通过反射强行调用private的构造方法.</li></ol><p>在《Effective Java》最后推荐了这样一个写法,看起来简直简单的有点不可思议,那么它是怎么保证以上几点的呢?</p><ol><li>枚举类的初始化过程天然线程安全.即保证了线程安全.</li><li>对枚举的序列化与反序列禁止了自定义,由JDK实现,不会出现反序列化多个实例的情况.</li></ol><p>在 《Effective Java》中,作者极力推荐枚举实现单例,甚至说了它是单例实现的最好写法.</p><pre><code class="hljs java"><span class="hljs-meta">@ThreadSafe</span><span class="hljs-meta">@Recommend</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonExample7</span> </span>&#123;    <span class="hljs-comment">// 私有构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonExample7</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonExample7 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Singleton.INSTANCE.getInstance();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;        INSTANCE;        <span class="hljs-keyword">private</span> SingletonExample7 singleton;        <span class="hljs-comment">// JVM保证这个方法绝对只调用一次</span>        Singleton() &#123;            singleton = <span class="hljs-keyword">new</span> SingletonExample7();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> SingletonExample7 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> singleton;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map接口在1.8新增方法</title>
    <link href="/2020/01/14/2020-01-14-Map%E6%8E%A5%E5%8F%A3%E5%9C%A81.8%E7%89%88%E6%9C%AC%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"/>
    <url>/2020/01/14/2020-01-14-Map%E6%8E%A5%E5%8F%A3%E5%9C%A81.8%E7%89%88%E6%9C%AC%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>V getOrDefault(Object key, V defaultValue)</li><li>void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</li><li>V putIfAbsent(K key, V value)</li><li>boolean remove(Object key, Object value)</li><li>replace</li><li>default boolean replace(K key, V oldValue, V newValue)</li><li>V replace(K key, V value)</li><li>V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</li><li>V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</li><li>V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</li><li>V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)<h2 id="Map接口在1-8"><a href="#Map接口在1-8" class="headerlink" title="Map接口在1.8"></a>Map接口在1.8</h2></li><li>getOrDefault</li><li>replaceAll</li><li>putIfAbsent</li><li>remove</li><li>replace</li><li>computeIfAbsent</li><li>computeIfPresent</li><li>compute</li><li>merge<h3 id="V-getOrDefault-Object-key-V-defaultValue"><a href="#V-getOrDefault-Object-key-V-defaultValue" class="headerlink" title="V getOrDefault(Object key, V defaultValue)"></a>V getOrDefault(Object key, V defaultValue)</h3>这可以说是最常用的方法了吧,获取指定key的value,当key不存在的时候返回一个默认值,也就是第二个参数.<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">getOrDefault</span><span class="hljs-params">(Object key, V defaultValue)</span> </span>&#123;       V v;       <span class="hljs-keyword">return</span> (((v = get(key)) != <span class="hljs-keyword">null</span>) || containsKey(key))           ? v           : defaultValue;   &#125;</code></pre><h3 id="void-replaceAll-BiFunction-lt-super-K-super-V-extends-V-gt-function"><a href="#void-replaceAll-BiFunction-lt-super-K-super-V-extends-V-gt-function" class="headerlink" title="void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)"></a>void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</h3>将所有value替换成给定lambda的计算结果,lambda的作用为根据key和value算出新的value.</li></ul><p>源代码如下:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-keyword">super</span> K, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;        Objects.requireNonNull(function);        <span class="hljs-keyword">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;            K k;            V v;            <span class="hljs-keyword">try</span> &#123;                k = entry.getKey();                v = entry.getValue();            &#125; <span class="hljs-keyword">catch</span>(IllegalStateException ise) &#123;                <span class="hljs-comment">// this usually means the entry is no longer in the map.</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException(ise);            &#125;            <span class="hljs-comment">// ise thrown from function is not a cme.</span>            v = function.apply(k, v);            <span class="hljs-keyword">try</span> &#123;                entry.setValue(v);            &#125; <span class="hljs-keyword">catch</span>(IllegalStateException ise) &#123;                <span class="hljs-comment">// this usually means the entry is no longer in the map.</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException(ise);            &#125;        &#125;    &#125;</code></pre><p>示例代码如下:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;       Map&lt;Integer, Integer&gt; test = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();       test.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);       test.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);       System.out.println(test.toString());       test.replaceAll((k, v) -&gt; k + v);       System.out.println(test.toString());   &#125;</code></pre><p>这段代码中传递了一个lambda,作用是将key和value相加作为新的value.</p><p>输出结果如下:</p><pre><code class="hljs java">&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-number">1</span>=<span class="hljs-number">2</span>, <span class="hljs-number">2</span>=<span class="hljs-number">4</span>&#125;</code></pre><h3 id="V-putIfAbsent-K-key-V-value"><a href="#V-putIfAbsent-K-key-V-value" class="headerlink" title="V putIfAbsent(K key, V value)"></a>V putIfAbsent(K key, V value)</h3><p>当key不存在的时候,写入新值.始终返回执行操作后的新值.</p><p>源代码如下:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        V v = get(key);        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;            v = put(key, value);        &#125;        <span class="hljs-keyword">return</span> v;    &#125;</code></pre><p>测试代码及输出如下:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, Integer&gt; test = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        test.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        test.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);        System.out.println(test.toString());        test.putIfAbsent(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);        test.putIfAbsent(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);        System.out.println(test.toString());    &#125;------------------------&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">3</span>=<span class="hljs-number">3</span>&#125;</code></pre><h3 id="boolean-remove-Object-key-Object-value"><a href="#boolean-remove-Object-key-Object-value" class="headerlink" title="boolean remove(Object key, Object value)"></a>boolean remove(Object key, Object value)</h3><p>如果给定的key在map中的value与给定值相等,则移除并且返回true,否则返回false.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;        Object curValue = get(key);        <span class="hljs-keyword">if</span> (!Objects.equals(curValue, value) ||            (curValue == <span class="hljs-keyword">null</span> &amp;&amp; !containsKey(key))) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        remove(key);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>这个有两个重载方法.</p><h3 id="default-boolean-replace-K-key-V-oldValue-V-newValue"><a href="#default-boolean-replace-K-key-V-oldValue-V-newValue" class="headerlink" title="default boolean replace(K key, V oldValue, V newValue)"></a>default boolean replace(K key, V oldValue, V newValue)</h3><p>当key在map中的value与给定的oldValue相等,则用newValue替换掉并且返回true,否则返回false.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span> </span>&#123;        Object curValue = get(key);        <span class="hljs-keyword">if</span> (!Objects.equals(curValue, oldValue) ||            (curValue == <span class="hljs-keyword">null</span> &amp;&amp; !containsKey(key))) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        put(key, newValue);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><h3 id="V-replace-K-key-V-value"><a href="#V-replace-K-key-V-value" class="headerlink" title="V replace(K key, V value)"></a>V replace(K key, V value)</h3><p>当key存在,就替换掉并且返回新值,否则返回null.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">replace</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        V curValue;        <span class="hljs-keyword">if</span> (((curValue = get(key)) != <span class="hljs-keyword">null</span>) || containsKey(key)) &#123;            curValue = put(key, value);        &#125;        <span class="hljs-keyword">return</span> curValue;    &#125;</code></pre><h3 id="V-computeIfAbsent-K-key-Function-lt-super-K-extends-V-gt-mappingFunction"><a href="#V-computeIfAbsent-K-key-Function-lt-super-K-extends-V-gt-mappingFunction" class="headerlink" title="V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)"></a>V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</h3><p>如果key不存在,则使用lambda计算并写入新值.永远返回执行操作后的新值.(可以存在,不做任何操作);放回计算的新值.</p><p>这个方法可以为一些耗时或者耗资源的操作构建本地缓存,当元素存在时直接返回,当不存在的时候进行耗时进行并存储,下一次可以直接返回.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">computeIfAbsent</span><span class="hljs-params">(K key,</span></span><span class="hljs-function"><span class="hljs-params">            Function&lt;? <span class="hljs-keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;        Objects.requireNonNull(mappingFunction);        V v;        <span class="hljs-keyword">if</span> ((v = get(key)) == <span class="hljs-keyword">null</span>) &#123;            V newValue;            <span class="hljs-keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="hljs-keyword">null</span>) &#123;                put(key, newValue);                <span class="hljs-keyword">return</span> newValue;            &#125;        &#125;        <span class="hljs-keyword">return</span> v;    &#125;</code></pre><p>测试代码及输出如下:</p><pre><code class="hljs java">    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, Integer&gt; test = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        test.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        test.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);        System.out.println(test.toString());        <span class="hljs-comment">// 1 存在,不做任何操作</span>        test.computeIfAbsent(<span class="hljs-number">1</span>, key -&gt; key + <span class="hljs-number">2</span>);        <span class="hljs-comment">// 3 不存在,将3 +2 = 5.</span>        test.computeIfAbsent(<span class="hljs-number">3</span>, key -&gt; key + <span class="hljs-number">2</span>);        System.out.println(test.toString());    &#125;------------------------&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">3</span>=<span class="hljs-number">5</span>&#125;</code></pre><h3 id="V-computeIfPresent-K-key-BiFunction-lt-super-K-super-V-extends-V-gt-remappingFunction"><a href="#V-computeIfPresent-K-key-BiFunction-lt-super-K-super-V-extends-V-gt-remappingFunction" class="headerlink" title="V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)"></a>V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</h3><p>当key存在时,计算新值,如果新值不为空,则将新值写入,如果新值为空,则移除掉此key.返回新值或者null.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">computeIfPresent</span><span class="hljs-params">(K key,</span></span><span class="hljs-function"><span class="hljs-params">            BiFunction&lt;? <span class="hljs-keyword">super</span> K, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;        Objects.requireNonNull(remappingFunction);        V oldValue;        <span class="hljs-keyword">if</span> ((oldValue = get(key)) != <span class="hljs-keyword">null</span>) &#123;            V newValue = remappingFunction.apply(key, oldValue);            <span class="hljs-keyword">if</span> (newValue != <span class="hljs-keyword">null</span>) &#123;                put(key, newValue);                <span class="hljs-keyword">return</span> newValue;            &#125; <span class="hljs-keyword">else</span> &#123;                remove(key);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;</code></pre><p>测试代码及输出如下:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, Integer&gt; test = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        test.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        test.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);        System.out.println(test.toString());        <span class="hljs-comment">// 1 存在,计算</span>        test.computeIfPresent(<span class="hljs-number">1</span>, (key, oldValue) -&gt; key + oldValue + <span class="hljs-number">2</span>);        <span class="hljs-comment">// 3 不存在,不作操作</span>        test.computeIfPresent(<span class="hljs-number">3</span>, (key, oldValue) -&gt; key + oldValue +  <span class="hljs-number">2</span>);        System.out.println(test.toString());    &#125;-------------------------------&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-number">1</span>=<span class="hljs-number">4</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>&#125;</code></pre><p>这个方法基本上是上一个方法的存在版本,但是要注意传入的lambda,参数是两个,computeIfAbsent的lambda传入key,计算值. 而computeIfPresent传入key和旧的value,并且由他们两个计算得到新的值.</p><h3 id="V-compute-K-key-BiFunction-lt-super-K-super-V-extends-V-gt-remappingFunction"><a href="#V-compute-K-key-BiFunction-lt-super-K-super-V-extends-V-gt-remappingFunction" class="headerlink" title="V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)"></a>V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</h3><p>直接计算新值,新值为空,则删除key并且返回null,新值不为空则写入并且返回新值.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">compute</span><span class="hljs-params">(K key,</span></span><span class="hljs-function"><span class="hljs-params">            BiFunction&lt;? <span class="hljs-keyword">super</span> K, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;        Objects.requireNonNull(remappingFunction);        V oldValue = get(key);        V newValue = remappingFunction.apply(key, oldValue);        <span class="hljs-keyword">if</span> (newValue == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// delete mapping</span>            <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-keyword">null</span> || containsKey(key)) &#123;                <span class="hljs-comment">// something to remove</span>                remove(key);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nothing to do. Leave things as they were.</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// add or replace old mapping</span>            put(key, newValue);            <span class="hljs-keyword">return</span> newValue;        &#125;    &#125;</code></pre><p>测试代码及输出如下:</p><pre><code class="hljs java"> <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, Integer&gt; test = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        test.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        test.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);        System.out.println(test.toString());        test.compute(<span class="hljs-number">1</span>, (key, oldValue) -&gt; key + <span class="hljs-number">2</span>);        test.compute(<span class="hljs-number">3</span>, (key, oldValue) -&gt; key + <span class="hljs-number">2</span>);        test.compute(<span class="hljs-number">2</span>, (key, oldValue) -&gt; <span class="hljs-keyword">null</span>);        System.out.println(test.toString());    &#125;----------------&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-number">1</span>=<span class="hljs-number">3</span>, <span class="hljs-number">3</span>=<span class="hljs-number">5</span>&#125;</code></pre><p>测试代码中对2进行compute-&gt;null,结果是2被删除.</p><h3 id="V-merge-K-key-V-value-BiFunction-lt-super-V-super-V-extends-V-gt-remappingFunction"><a href="#V-merge-K-key-V-value-BiFunction-lt-super-V-super-V-extends-V-gt-remappingFunction" class="headerlink" title="V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)"></a>V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</h3><p>使用旧值和给定的value来计算新值,如果新值为空,则删除key,不为空则写入并且返回.</p><p>注意:如果旧值为空,也就是原有的key不存在,新值等于给定值,不会再进行计算.因此下方的测试代码3=10而不是12.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">merge</span><span class="hljs-params">(K key, V value,</span></span><span class="hljs-function"><span class="hljs-params">            BiFunction&lt;? <span class="hljs-keyword">super</span> V, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;        Objects.requireNonNull(remappingFunction);        Objects.requireNonNull(value);        V oldValue = get(key);        V newValue = (oldValue == <span class="hljs-keyword">null</span>) ? value :                   remappingFunction.apply(oldValue, value);        <span class="hljs-keyword">if</span>(newValue == <span class="hljs-keyword">null</span>) &#123;            remove(key);        &#125; <span class="hljs-keyword">else</span> &#123;            put(key, newValue);        &#125;        <span class="hljs-keyword">return</span> newValue;    &#125;</code></pre><p>测试代码及输出如下:</p><pre><code class="hljs java">    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, Integer&gt; test = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        test.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        test.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);        System.out.println(test.toString());        test.merge(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (v, oldV) -&gt; v + oldV + <span class="hljs-number">2</span>);        test.merge(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, (v, oldV) -&gt; v + oldV + <span class="hljs-number">2</span>);        test.merge(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, (v, oldV) -&gt; <span class="hljs-keyword">null</span>);        System.out.println(test.toString());    &#125;--------------------------&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-number">1</span>=<span class="hljs-number">13</span>, <span class="hljs-number">3</span>=<span class="hljs-number">10</span>&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
