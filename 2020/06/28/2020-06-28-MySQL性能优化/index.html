

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon_1.png">
  <link rel="icon" type="image/png" href="/img/favicon_1.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>MySQL性能优化 - 108 Keywords</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Square</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/wallhaven-xl3jwl.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-06-28 10:00" pubdate>
        2020年6月28日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      78
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">MySQL性能优化</h1>
            
            <div class="markdown-body" id="post-body">
              <h6 id="1-查询-SQL-尽量不要使用-select-，而是-select-具体字段"><a href="#1-查询-SQL-尽量不要使用-select-，而是-select-具体字段" class="headerlink" title="1. 查询 SQL 尽量不要使用 select *，而是 select 具体字段"></a>1. 查询 SQL 尽量不要使用 select *，而是 select 具体字段</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例子:</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employee;
<span class="hljs-comment">### 正例子:</span>
<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>，<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee;</code></pre></div>

<ul>
<li>只取需要的字段，节省资源、减少网络开销。</li>
<li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li>
</ul>
<h6 id="2-如果知道查询结果只有一条或者只要最大-最小一条记录，建议用-limit-1"><a href="#2-如果知道查询结果只有一条或者只要最大-最小一条记录，建议用-limit-1" class="headerlink" title="2. 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用 limit 1"></a>2. 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用 limit 1</h6><div class="hljs"><pre><code class="hljs routeros">CREATE TABLE `employee` (
  `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  `name` varchar(255)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,
  `age` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,
  `date` datetime<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,
  `sex` int(1)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,
  PRIMARY KEY (`id`)
) <span class="hljs-attribute">ENGINE</span>=InnoDB<span class="hljs-built_in"> DEFAULT </span><span class="hljs-attribute">CHARSET</span>=utf8mb4;</code></pre></div>

<div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>，<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;jay&#x27;</span>
<span class="hljs-comment">### 正例:</span>
<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>，<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;jay&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;</code></pre></div>

<ul>
<li>加上 limit 1 后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li>
<li>当然，如果 name 是唯一索引的话，是不必要加上 limit 1 了，因为 limit 的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有 limit ，性能的差别并不大。</li>
</ul>
<h6 id="3-应尽量避免在-where-子句中使用-or-来连接条件"><a href="#3-应尽量避免在-where-子句中使用-or-来连接条件" class="headerlink" title="3. 应尽量避免在 where 子句中使用 or 来连接条件"></a>3. 应尽量避免在 where 子句中使用 or 来连接条件</h6><div class="hljs"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (
  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,
  <span class="hljs-symbol">`userId`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),
  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_userId`</span> (<span class="hljs-symbol">`userId`</span>)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code></pre></div>

<p>假设现在需要查询 userId 为 1 或者年龄为 18 岁的用户，很容易有以下 sql</p>
<div class="hljs"><pre><code class="hljs crystal"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span> * from user where userid=<span class="hljs-number">1</span> or age =<span class="hljs-number">18</span>
<span class="hljs-comment">### 正例：</span>
/<span class="hljs-regexp">/ 使用union all</span>
<span class="hljs-regexp">select * from user where userid=1</span>
<span class="hljs-regexp">union all</span>
<span class="hljs-regexp">select * from user where age = 18</span>
<span class="hljs-regexp"></span>
<span class="hljs-regexp">/</span><span class="hljs-regexp">/ 或者分开两条sql写：</span>
<span class="hljs-regexp">select * from user where userid=1</span>
<span class="hljs-regexp">select * from user where age = 18</span></code></pre></div>

<ul>
<li>使用 or 可能会使索引失效，从而全表扫描。<br>对于 or+没有索引的 age 这种情况，假设它走了 userId 的索引，但是走到 age 查询条件时，它还得全表扫描，<br>也就是需要三步过程：全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。<br>mysql 是有优化器的，处于效率与成本考虑，遇到 or 条件，索引可能失效，看起来也合情合理。<br>建议 age 也添加索引</li>
</ul>
<h6 id="4-优化-limit-分页"><a href="#4-优化-limit-分页" class="headerlink" title="4. 优化 limit 分页"></a>4. 优化 limit 分页</h6><div class="hljs"><pre><code class="hljs clean">### 反例:
select * <span class="hljs-keyword">from</span> saleshistory limit <span class="hljs-number">10000000</span>,<span class="hljs-number">10</span>
### 正例:
<span class="hljs-comment">//方案一 ：返回上次查询的最大记录(偏移量)</span>
select * <span class="hljs-keyword">from</span> saleshistory <span class="hljs-keyword">where</span> id&gt; <span class="hljs-number">10000000</span> limit <span class="hljs-number">10</span></code></pre></div>

<h6 id="5-优化你的-like-语句"><a href="#5-优化你的-like-语句" class="headerlink" title="5. 优化你的 like 语句"></a>5. 优化你的 like 语句</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
select userId，name <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userId like <span class="hljs-string">&#x27;%123&#x27;</span>
<span class="hljs-comment">### 正例:</span>
select userId，name <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userId like <span class="hljs-string">&#x27;123%&#x27;</span>;</code></pre></div>

<h6 id="6-使用-where-条件限定要查询的数据，避免返回多余的行"><a href="#6-使用-where-条件限定要查询的数据，避免返回多余的行" class="headerlink" title="6. 使用 where 条件限定要查询的数据，避免返回多余的行"></a>6. 使用 where 条件限定要查询的数据，避免返回多余的行</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
select userId <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">isVip</span>=1
<span class="hljs-comment">### 正例:</span>
select userId <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">userId</span>=<span class="hljs-string">&#x27;userId&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">isVip</span>=<span class="hljs-string">&#x27;1&#x27;</span></code></pre></div>

<h6 id="7-尽量避免在索引列上使用-mysql-的内置函数"><a href="#7-尽量避免在索引列上使用-mysql-的内置函数" class="headerlink" title="7. 尽量避免在索引列上使用 mysql 的内置函数"></a>7. 尽量避免在索引列上使用 mysql 的内置函数</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span> userId,loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span> <span class="hljs-keyword">Date_ADD</span>(loginTime,<span class="hljs-built_in">Interval</span> <span class="hljs-number">7</span> <span class="hljs-keyword">DAY</span>) &gt;=<span class="hljs-keyword">now</span>();
<span class="hljs-comment">### 正例:</span>
<span class="hljs-keyword">select</span> userId,loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span> loginTime &gt;= <span class="hljs-keyword">Date_SUB</span>(<span class="hljs-keyword">now</span>() ,<span class="hljs-built_in">Interval</span> <span class="hljs-number">7</span> <span class="hljs-keyword">DAY</span>);</code></pre></div>

<h6 id="8-应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"><a href="#8-应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫" class="headerlink" title="8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"></a>8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age-1 =10
<span class="hljs-comment">### 正例:</span>
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age =11</code></pre></div>

<h6 id="9-Inner-join-、left-join、right-join，优先使用-Inner-join，如果是-left-join，左边表结果尽量小"><a href="#9-Inner-join-、left-join、right-join，优先使用-Inner-join，如果是-left-join，左边表结果尽量小" class="headerlink" title="9. Inner join 、left join、right join，优先使用 Inner join，如果是 left join，左边表结果尽量小"></a>9. Inner join 、left join、right join，优先使用 Inner join，如果是 left join，左边表结果尽量小</h6><ul>
<li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li>
<li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录</li>
<li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录</li>
</ul>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-comment">### 反例:</span>
<span class="hljs-attribute">select</span> * from tab<span class="hljs-number">1</span> t<span class="hljs-number">1</span> left join tab<span class="hljs-number">2</span> t<span class="hljs-number">2</span>  <span class="hljs-literal">on</span> t<span class="hljs-number">1</span>.size = t<span class="hljs-number">2</span>.size where t<span class="hljs-number">1</span>.id &gt; <span class="hljs-number">2</span>
<span class="hljs-comment">### 正例:</span>
<span class="hljs-attribute">select</span> * from (select * from tab<span class="hljs-number">1</span> where id &gt;<span class="hljs-number">2</span>) t<span class="hljs-number">1</span> left join tab<span class="hljs-number">2</span> t<span class="hljs-number">2</span> <span class="hljs-literal">on</span> t<span class="hljs-number">1</span>.size = t<span class="hljs-number">2</span>.size</code></pre></div>

<h6 id="10-应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描"><a href="#10-应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描" class="headerlink" title="10. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描"></a>10. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span> age,<span class="hljs-keyword">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &lt;&gt;<span class="hljs-number">18</span>;
<span class="hljs-comment">### 正例:</span>
//可以考虑分开两条sql写
<span class="hljs-keyword">select</span> age,<span class="hljs-keyword">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &lt;<span class="hljs-number">18</span>;
<span class="hljs-keyword">select</span> age,<span class="hljs-keyword">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt;<span class="hljs-number">18</span>;</code></pre></div>

<h6 id="11-使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则"><a href="#11-使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则" class="headerlink" title="11. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则"></a>11. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则</h6><p>表结构：（联合索引 idx_userId_age，userId 在前，age 在后）</p>
<div class="hljs"><pre><code class="hljs routeros">CREATE TABLE `user` (
  `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,
  `userId` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  `age` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,
  `name` varchar(255) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  PRIMARY KEY (`id`),
  KEY `idx_userId_age` (`userId`,`age`) USING BTREE
) <span class="hljs-attribute">ENGINE</span>=InnoDB <span class="hljs-attribute">AUTO_INCREMENT</span>=2<span class="hljs-built_in"> DEFAULT </span><span class="hljs-attribute">CHARSET</span>=utf8;</code></pre></div>

<div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age = <span class="hljs-number">10</span>;
<span class="hljs-comment">### 正例:</span>
//符合最左匹配原则
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">10</span> <span class="hljs-keyword">and</span> age =<span class="hljs-number">10</span>；
//符合最左匹配原则
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid =<span class="hljs-number">10</span>;</code></pre></div>

<h6 id="12-对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描"><a href="#12-对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描" class="headerlink" title="12. 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描"></a>12. 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where<span class="hljs-built_in"> address </span>=<span class="hljs-string">&#x27;深圳&#x27;</span> order by age
<span class="hljs-comment">### 正例:</span>
alter table<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">add</span> index idx_address_age (address,age)</code></pre></div>

<h6 id="13-如果插入数据过多，考虑批量插入"><a href="#13-如果插入数据过多，考虑批量插入" class="headerlink" title="13. 如果插入数据过多，考虑批量插入"></a>13. 如果插入数据过多，考虑批量插入</h6><div class="hljs"><pre><code class="hljs pgsql">### 反例:
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">User</span> u :list)&#123;
 <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>,age) <span class="hljs-keyword">values</span>(#<span class="hljs-type">name</span>#,#age#)
&#125;
### 正例:
//一次<span class="hljs-number">500</span>批量插入，分批进行
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>,age) <span class="hljs-keyword">values</span>
&lt;<span class="hljs-keyword">foreach</span> collection=&quot;list&quot; item=&quot;item&quot; <span class="hljs-keyword">index</span>=&quot;index&quot; separator=&quot;,&quot;&gt;
    (#&#123;item.name&#125;,#&#123;item.age&#125;)
&lt;/<span class="hljs-keyword">foreach</span>&gt;</code></pre></div>

<h6 id="14-在适当的时候，使用覆盖索引"><a href="#14-在适当的时候，使用覆盖索引" class="headerlink" title="14. 在适当的时候，使用覆盖索引"></a>14. 在适当的时候，使用覆盖索引</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
// like模糊查询，不走索引了
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span>
<span class="hljs-comment">### 正例:</span>
//<span class="hljs-keyword">id</span>为主键，那么为普通索引，即覆盖索引登场了。
<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span>;</code></pre></div>

<h6 id="15-慎用-distinct-关键字"><a href="#15-慎用-distinct-关键字" class="headerlink" title="15. 慎用 distinct 关键字"></a>15. 慎用 distinct 关键字</h6><p>distinct 关键字一般用来过滤重复记录，以返回不重复的记录。<br>在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。</p>
<div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
SELECT DISTINCT * <span class="hljs-keyword">from</span>  user;
<span class="hljs-comment">### 正例:</span>
select DISTINCT name <span class="hljs-keyword">from</span> user;</code></pre></div>

<h6 id="16-删除冗余和重复索引"><a href="#16-删除冗余和重复索引" class="headerlink" title="16. 删除冗余和重复索引"></a>16. 删除冗余和重复索引</h6><div class="hljs"><pre><code class="hljs autohotkey"><span class="hljs-title">### 反例:</span>
  KEY `idx_userId` (`userId`)
  KEY `idx_userId_age` (`userId`,`age`)
<span class="hljs-title">### 正例:</span>
  //删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引
  KEY `idx_userId_age` (`userId`,`age`)</code></pre></div>

<h6 id="17-如果数据量较大，优化你的修改-删除语句"><a href="#17-如果数据量较大，优化你的修改-删除语句" class="headerlink" title="17. 如果数据量较大，优化你的修改/删除语句"></a>17. 如果数据量较大，优化你的修改/删除语句</h6><div class="hljs"><pre><code class="hljs clean">### 反例:
<span class="hljs-comment">//一次删除10万或者100万+？</span>
delete <span class="hljs-keyword">from</span> user <span class="hljs-keyword">where</span> id &lt;<span class="hljs-number">100000</span>;
<span class="hljs-comment">//或者采用单一循环操作，效率低，时间漫长</span>
for（User user：list）&#123;
   delete <span class="hljs-keyword">from</span> user；
&#125;
### 正例:
<span class="hljs-comment">//分批进行删除,如每次500</span>
delete user <span class="hljs-keyword">where</span> id&lt;<span class="hljs-number">500</span>
delete product <span class="hljs-keyword">where</span> id&gt;=<span class="hljs-number">500</span> and id&lt;<span class="hljs-number">1000</span>；</code></pre></div>

<h6 id="18-where-子句中考虑使用默认值代替-null"><a href="#18-where-子句中考虑使用默认值代替-null" class="headerlink" title="18. where 子句中考虑使用默认值代替 null"></a>18. where 子句中考虑使用默认值代替 null</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;
<span class="hljs-comment">### 正例:</span>
//设置0为默认值
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt; <span class="hljs-number">0</span>;</code></pre></div>

<h6 id="19-不要有超过-5-个以上的表连接"><a href="#19-不要有超过-5-个以上的表连接" class="headerlink" title="19. 不要有超过 5 个以上的表连接"></a>19. 不要有超过 5 个以上的表连接</h6><ul>
<li>连表越多，编译的时间和开销也就越大。</li>
<li>把连接表拆开成较小的几个执行，可读性更高。</li>
<li>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li>
</ul>
<h6 id="20-exist-amp-in-的合理利用"><a href="#20-exist-amp-in-的合理利用" class="headerlink" title="20. exist &amp; in 的合理利用"></a>20. exist &amp; in 的合理利用</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> deptId <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> deptId <span class="hljs-keyword">from</span> B);
<span class="hljs-comment">### 正例:</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> A.deptId = B.deptId);</code></pre></div>

<p>因此，我们要选择最外层循环小的，也就是，如果 B 的数据量小于 A，适合使用 in，如果 B 的数据量大于 A，即适合选择 exist。</p>
<h6 id="21-尽量用-union-all-替换-union"><a href="#21-尽量用-union-all-替换-union" class="headerlink" title="21. 尽量用 union all 替换 union"></a>21. 尽量用 union all 替换 union</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">userid</span>=1
union
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age = 10
<span class="hljs-comment">### 正例:</span>
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where <span class="hljs-attribute">userid</span>=1
union all
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where age = 10</code></pre></div>

<ul>
<li>如果使用 union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。</li>
<li>如果已知检索结果没有重复记录，使用 union all 代替 union，这样会提高效率</li>
</ul>
<h6 id="22-索引不宜太多，一般-5-个以内"><a href="#22-索引不宜太多，一般-5-个以内" class="headerlink" title="22. 索引不宜太多，一般 5 个以内"></a>22. 索引不宜太多，一般 5 个以内</h6><ul>
<li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li>
<li>insert 或 update 时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li>
<li>一个表的索引数最好不要超过 5 个，若太多需要考虑一些索引是否没有存在的必要。</li>
</ul>
<h6 id="23-尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"><a href="#23-尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型" class="headerlink" title="23. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"></a>23. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
king_id` varchar（20） NOT NULL <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;守护者Id&#x27;</span>
<span class="hljs-comment">### 正例:</span>
<span class="hljs-string">`king_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;守护者Id&#x27;</span><span class="hljs-string">`</span></code></pre></div>

<ul>
<li>相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。</li>
</ul>
<h6 id="24-索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段"><a href="#24-索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段" class="headerlink" title="24. 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段"></a>24. 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段</h6><p>因为 SQL 优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，<br>Mysql 查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p>
<h6 id="25-尽量避免向客户端返回过多数据量"><a href="#25-尽量避免向客户端返回过多数据量" class="headerlink" title="25. 尽量避免向客户端返回过多数据量"></a>25. 尽量避免向客户端返回过多数据量</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
//一次性查询所有数据回来
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime &gt;= <span class="hljs-keyword">Date_sub</span>(<span class="hljs-keyword">now</span>(),<span class="hljs-built_in">Interval</span> <span class="hljs-number">1</span> Y)
<span class="hljs-comment">### 正例:</span>
//分页查询
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime&gt;= <span class="hljs-keyword">Date_sub</span>(<span class="hljs-keyword">now</span>(),<span class="hljs-built_in">Interval</span> <span class="hljs-number">1</span> Y) <span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span>，pageSize
//如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime&gt;= <span class="hljs-keyword">Date_sub</span>(<span class="hljs-keyword">now</span>(),<span class="hljs-built_in">Interval</span> <span class="hljs-number">1</span> Y) <span class="hljs-keyword">limit</span> <span class="hljs-number">200</span> ;</code></pre></div>

<h6 id="26-当在-SQL-语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰"><a href="#26-当在-SQL-语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰" class="headerlink" title="26. 当在 SQL 语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰"></a>26. 当在 SQL 语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 反例:</span>
<span class="hljs-keyword">select</span>  * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.deptId = B.deptId;
<span class="hljs-comment">### 正例:</span>
<span class="hljs-keyword">select</span>  memeber.name,deptment.deptName <span class="hljs-keyword">from</span> A <span class="hljs-keyword">member</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B deptment <span class="hljs-keyword">on</span> member.deptId = deptment.deptId;</code></pre></div>

<h6 id="27-尽可能使用-varchar-nvarchar-代替-char-nchar"><a href="#27-尽可能使用-varchar-nvarchar-代替-char-nchar" class="headerlink" title="27. 尽可能使用 varchar/nvarchar 代替 char/nchar"></a>27. 尽可能使用 varchar/nvarchar 代替 char/nchar</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
`deptName` char(100)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;部门名称&#x27;</span>
<span class="hljs-comment">### 正例:</span>
`deptName` varchar(100)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;部门名称&#x27;</span></code></pre></div>

<ul>
<li>因为首先变长字段存储空间小，可以节省存储空间。</li>
<li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li>
</ul>
<h6 id="28-为了提高-group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉"><a href="#28-为了提高-group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉" class="headerlink" title="28. 为了提高 group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉"></a>28. 为了提高 group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
select job，avg（salary） <span class="hljs-keyword">from</span> employee <span class="hljs-built_in"> group </span>by job having job =<span class="hljs-string">&#x27;president&#x27;</span> <span class="hljs-keyword">or</span> job = <span class="hljs-string">&#x27;managent&#x27;</span>
<span class="hljs-comment">### 正例:</span>
select job，avg（salary） <span class="hljs-keyword">from</span> employee where job =<span class="hljs-string">&#x27;president&#x27;</span> <span class="hljs-keyword">or</span> job = <span class="hljs-string">&#x27;managent&#x27;</span><span class="hljs-built_in"> group </span>by job</code></pre></div>

<h6 id="29-如何字段类型是字符串，where-时一定用引号括起来，否则索引失效"><a href="#29-如何字段类型是字符串，where-时一定用引号括起来，否则索引失效" class="headerlink" title="29. 如何字段类型是字符串，where 时一定用引号括起来，否则索引失效"></a>29. 如何字段类型是字符串，where 时一定用引号括起来，否则索引失效</h6><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment">### 反例:</span>
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userid =123
<span class="hljs-comment">### 正例:</span>
select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userid =<span class="hljs-string">&#x27;123&#x27;</span></code></pre></div>

<h6 id="30-使用-explain-分析你-SQL-的计划"><a href="#30-使用-explain-分析你-SQL-的计划" class="headerlink" title="30. 使用 explain 分析你 SQL 的计划"></a>30. 使用 explain 分析你 SQL 的计划</h6><div class="hljs"><pre><code class="hljs routeros">explain select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> user </span>where userid =10086 <span class="hljs-keyword">or</span> age =18;

<span class="hljs-comment">### 效率从高到低依次</span>
system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; All</code></pre></div>

<h6 id="1-巧用-CASE-WHEN-进行统计"><a href="#1-巧用-CASE-WHEN-进行统计" class="headerlink" title="1. 巧用 CASE WHEN 进行统计"></a>1. 巧用 CASE WHEN 进行统计</h6><table>
<thead>
<tr>
<th>city</th>
<th align="center">population</th>
</tr>
</thead>
<tbody><tr>
<td>长沙</td>
<td align="center">100</td>
</tr>
<tr>
<td>衡阳</td>
<td align="center">200</td>
</tr>
<tr>
<td>三亚</td>
<td align="center">300</td>
</tr>
<tr>
<td>海口</td>
<td align="center">300</td>
</tr>
</tbody></table>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> pref_name
      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;长沙&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;湖南&#x27;</span>
      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;衡阳&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;湖南&#x27;</span>
      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;海口&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;海南&#x27;</span>
      <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;三亚&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;海南&#x27;</span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;其他&#x27;</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> district,
    <span class="hljs-keyword">SUM</span>(population)
<span class="hljs-keyword">FROM</span> PopTbl
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> district;</code></pre></div>

<table>
<thead>
<tr>
<th>province</th>
<th align="center">人口</th>
</tr>
</thead>
<tbody><tr>
<td>湖南</td>
<td align="center">300</td>
</tr>
<tr>
<td>海南</td>
<td align="center">700</td>
</tr>
</tbody></table>
<h6 id="2-巧用-CASE-WHEN-进行更新"><a href="#2-巧用-CASE-WHEN-进行更新" class="headerlink" title="2. 巧用 CASE WHEN 进行更新"></a>2. 巧用 CASE WHEN 进行更新</h6><table>
<thead>
<tr>
<th>name</th>
<th align="center">salary</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td align="center">10500</td>
</tr>
<tr>
<td>小红</td>
<td align="center">8000</td>
</tr>
<tr>
<td>小李</td>
<td align="center">5000</td>
</tr>
</tbody></table>
<ol>
<li>对当前工资为 1 万以上的员工，降薪 10%</li>
<li>对当前工资低于 1 万的员工，加薪 20%</li>
</ol>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 条件1</span>
<span class="hljs-keyword">UPDATE</span> Salaries
<span class="hljs-keyword">SET</span> salary = salary * <span class="hljs-number">0.9</span> <span class="hljs-keyword">WHERE</span> salary &gt;= <span class="hljs-number">10000</span>;
<span class="hljs-comment">-- 条件2</span>
<span class="hljs-keyword">UPDATE</span> Salaries
<span class="hljs-keyword">SET</span> salary = salary * <span class="hljs-number">1.2</span>
<span class="hljs-keyword">WHERE</span> salary &lt; <span class="hljs-number">10000</span>;</code></pre></div>
<p>这么做其实是有问题的， 什么问题，对小明来说，他的工资是 10500，执行第一个 SQL 后，工资变为 10500 * 0.9 = 9450,<br>紧接着又执行条件 2， 工资变为了 9450 * 1.2 = 11340，反而涨薪了！</p>
<div class="hljs"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> Salaries
<span class="hljs-keyword">SET</span> salary = <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> salary &gt;= <span class="hljs-number">10000</span> <span class="hljs-keyword">THEN</span> salary * <span class="hljs-number">0.9</span>
<span class="hljs-keyword">WHEN</span> salary &lt; <span class="hljs-number">10000</span> <span class="hljs-keyword">THEN</span> salary * <span class="hljs-number">1.2</span>
<span class="hljs-keyword">ELSE</span> salary <span class="hljs-keyword">END</span>;</code></pre></div>

<h6 id="3-巧用-HAVING-子句"><a href="#3-巧用-HAVING-子句" class="headerlink" title="3. 巧用 HAVING 子句"></a>3. 巧用 HAVING 子句</h6><p>一般 HAVING 是与 GROUP BY 结合使用的，但其实它是可以独立使用的，<br>假设有如下表，第一列 seq 叫连续编号，但其实有些编号是缺失的，怎么知道编号是否缺失呢，</p>
<table>
<thead>
<tr>
<th>seq(连续编号)</th>
<th align="center">name(名字)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">小张</td>
</tr>
<tr>
<td>2</td>
<td align="center">小丽</td>
</tr>
<tr>
<td>3</td>
<td align="center">小王</td>
</tr>
<tr>
<td>5</td>
<td align="center">小明</td>
</tr>
<tr>
<td>6</td>
<td align="center">小李</td>
</tr>
<tr>
<td>8</td>
<td align="center">老马</td>
</tr>
</tbody></table>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;存在缺失的编号&#x27;</span> <span class="hljs-keyword">AS</span> gap
  <span class="hljs-keyword">FROM</span> SeqTbl
<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &lt;&gt; <span class="hljs-keyword">MAX</span>(seq);</code></pre></div>

<h6 id="4-自连接"><a href="#4-自连接" class="headerlink" title="4. 自连接"></a>4. 自连接</h6><ol>
<li>删除重复行</li>
</ol>
<table>
<thead>
<tr>
<th>name(商品名称)</th>
<th align="center">price(价格)</th>
</tr>
</thead>
<tbody><tr>
<td>apple</td>
<td align="center">50</td>
</tr>
<tr>
<td>orange</td>
<td align="center">100</td>
</tr>
<tr>
<td>orange</td>
<td align="center">100</td>
</tr>
<tr>
<td>orange</td>
<td align="center">100</td>
</tr>
<tr>
<td>blackberry</td>
<td align="center">180</td>
</tr>
</tbody></table>
<p>表中有三个橘子，需要把这些重复的行给删掉，用如下自连接可以解决</p>
<div class="hljs"><pre><code class="hljs reasonml">DELETE FROM Products P1
 WHERE id &lt; ( SELECT <span class="hljs-constructor">MAX(P2.<span class="hljs-params">id</span>)</span> 
                   FROM Products P2 
                  WHERE <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P1</span>.</span></span>name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P2</span>.</span></span>name 
                    AND <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P1</span>.</span></span>price = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">P2</span>.</span></span>price );</code></pre></div>

<ol start="2">
<li>排序</li>
</ol>
<table>
<thead>
<tr>
<th>name(商品名称)</th>
<th align="center">price(价格)</th>
</tr>
</thead>
<tbody><tr>
<td>apple</td>
<td align="center">50</td>
</tr>
<tr>
<td>orange</td>
<td align="center">100</td>
</tr>
<tr>
<td>watermelon</td>
<td align="center">100</td>
</tr>
<tr>
<td>berry</td>
<td align="center">120</td>
</tr>
<tr>
<td>blackberry</td>
<td align="center">180</td>
</tr>
</tbody></table>
<div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 排序从 1 开始。如果已出现相同位次，则跳过之后的位次 </span>
<span class="hljs-keyword">SELECT</span> P1.name,
       P1.price,
       (<span class="hljs-keyword">SELECT</span> COUNT(P2.price)
          <span class="hljs-keyword">FROM</span> Products P2
         <span class="hljs-keyword">WHERE</span> P2.price &gt; P1.price) + <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> rank_1
  <span class="hljs-keyword">FROM</span> Products P1 
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rank_1;</code></pre></div>

<h6 id="5-巧用-COALESCE-函数"><a href="#5-巧用-COALESCE-函数" class="headerlink" title="5. 巧用 COALESCE 函数"></a>5. 巧用 COALESCE 函数</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 
    <span class="hljs-keyword">COALESCE</span>(city, <span class="hljs-string">&#x27;N/A&#x27;</span>)
  <span class="hljs-keyword">FROM</span>
    customers;</code></pre></div>
<table>
<thead>
<tr>
<th>id</th>
<th align="center">city</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">null</td>
</tr>
<tr>
<td>2</td>
<td align="center">上海</td>
</tr>
<tr>
<td>3</td>
<td align="center">北京</td>
</tr>
</tbody></table>
<h6 id="1-参数是子查询时，使用-EXISTS-代替-IN"><a href="#1-参数是子查询时，使用-EXISTS-代替-IN" class="headerlink" title="1. 参数是子查询时，使用 EXISTS 代替 IN"></a>1. 参数是子查询时，使用 EXISTS 代替 IN</h6><table>
<thead>
<tr>
<th>id</th>
<th align="center">name(名字)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">小明</td>
</tr>
<tr>
<td>2</td>
<td align="center">晓东</td>
</tr>
<tr>
<td>3</td>
<td align="center">阿强</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>id</th>
<th align="center">name(名字)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">小明</td>
</tr>
<tr>
<td>2</td>
<td align="center">晓东</td>
</tr>
<tr>
<td>3</td>
<td align="center">大雄</td>
</tr>
</tbody></table>
<p>要查出同时存在于两个表的员工，即小明和晓东，<br>则以下用 IN 和 EXISTS 返回的结果是一样，但是用 EXISTS 的 SQL 会更快:</p>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 慢</span>
<span class="hljs-keyword">SELECT</span> * 
  <span class="hljs-keyword">FROM</span> Class_A
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> 
               <span class="hljs-keyword">FROM</span>  CLASS_B);

<span class="hljs-comment">-- 快</span>
<span class="hljs-keyword">SELECT</span> *
  <span class="hljs-keyword">FROM</span> Class_A A 
 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>
(<span class="hljs-keyword">SELECT</span> * 
   <span class="hljs-keyword">FROM</span> Class_B  B
  <span class="hljs-keyword">WHERE</span> A.id = B.id);</code></pre></div>

<p>如果 IN 的参数是子查询时，也可以用连接来代替，如下：</p>
<div class="hljs"><pre><code class="hljs reasonml">-- 使用连接代替 IN SELECT <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>id, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>name
FROM Class_A A INNER JOIN Class_B B ON <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>id = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>id;</code></pre></div>

<h6 id="2-避免排序"><a href="#2-避免排序" class="headerlink" title="2. 避免排序"></a>2. 避免排序</h6><p>SQL 是声明式语言，即对用户来说，只关心它能做什么，不用关心它怎么做。<br>这样可能会产生潜在的性能问题：排序，会产生排序的代表性运算有下面这些</p>
<ul>
<li>GROUP BY 子句</li>
<li>ORDER BY 子句</li>
<li>聚合函数(SUM、COUNT、AVG、MAX、MIN)</li>
<li>DISTINCT</li>
<li>集合运算符(UNION、INTERSECT、EXCEPT)</li>
<li>窗口函数(RANK、ROW_NUMBER 等)</li>
</ul>
<p>如果在内存中排序还好，但如果内存不够导致需要在硬盘上排序上的话，<br>性能就会急剧下降，所以我们需要减少不必要的排序。怎样做可以减少排序呢。</p>
<ol>
<li>使用集合运算符的 ALL 可选项<br>注意：加 ALL 是优化性能非常有效的手段，不过前提是不在乎结果是否有重复数据。</li>
<li>使用 EXISTS 代表 DISTINCT<br>为了排除重复数据， DISTINCT 也会对结果进行排序，如果需要对两张表的连接结果进行去重，<br>可以考虑用 EXISTS 代替 DISTINCT，这样可以避免排序。</li>
</ol>
<table>
<thead>
<tr>
<th>item_no</th>
<th align="center">item</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td align="center">面包</td>
</tr>
<tr>
<td>20</td>
<td align="center">香蕉</td>
</tr>
<tr>
<td>30</td>
<td align="center">苹果</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>sale_date</th>
<th align="center">item_no</th>
<th align="center">quantity</th>
</tr>
</thead>
<tbody><tr>
<td>2020-06-01 10:05:56</td>
<td align="center">10</td>
<td align="center">4</td>
</tr>
<tr>
<td>2020-06-01 10:05:56</td>
<td align="center">20</td>
<td align="center">10</td>
</tr>
<tr>
<td>2020-06-01 10:05:56</td>
<td align="center">30</td>
<td align="center">3</td>
</tr>
<tr>
<td>2020-06-01 10:05:56</td>
<td align="center">10</td>
<td align="center">30</td>
</tr>
</tbody></table>
<p>如何找出有销售记录的商品，使用如下 DISTINCT 可以:</p>
<div class="hljs"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> I.item_no
<span class="hljs-keyword">FROM</span> Items I <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SalesHistory SH
<span class="hljs-keyword">ON</span> I. item_no = SH. item_no;</code></pre></div>
<p>不过更好的方式是使用 EXISTS: 既用到了索引，又避免了排序对性能的损耗。</p>
<div class="hljs"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> item_no <span class="hljs-keyword">FROM</span> Items I
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> 
        (<span class="hljs-keyword">SELECT</span> *
           <span class="hljs-keyword">FROM</span> SalesHistory SH
          <span class="hljs-keyword">WHERE</span> I.item_no = SH.item_no);</code></pre></div>

<h6 id="2-在极值函数中使用索引（MAX-MIN）"><a href="#2-在极值函数中使用索引（MAX-MIN）" class="headerlink" title="2. 在极值函数中使用索引（MAX/MIN）"></a>2. 在极值函数中使用索引（MAX/MIN）</h6><p>使用 MAX/ MIN 都会对进行排序，如果参数字段上没加索引会导致全表扫描，<br>如果建有索引，则只需要扫描索引即可，对比如下</p>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 这样写需要扫描全表 </span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(item)
  <span class="hljs-keyword">FROM</span> Items;

<span class="hljs-comment">-- 这样写能用到索引 </span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(item_no)
  <span class="hljs-keyword">FROM</span> Items;</code></pre></div>
<p>注意：极值函数参数推荐为索引列中并不是不需要排序，而是优化了排序前的查找速度（毕竟索引本身就是有序排列的）</p>
<h6 id="3-能写在-WHERE-子句里的条件不要写在-HAVING-子句里"><a href="#3-能写在-WHERE-子句里的条件不要写在-HAVING-子句里" class="headerlink" title="3. 能写在 WHERE 子句里的条件不要写在 HAVING 子句里"></a>3. 能写在 WHERE 子句里的条件不要写在 HAVING 子句里</h6><div class="hljs"><pre><code class="hljs routeros">-- 聚合后使用 HAVING 子句过滤
SELECT sale_date, SUM(quantity)
  <span class="hljs-keyword">FROM</span> SalesHistory<span class="hljs-built_in"> GROUP </span>BY sale_date
HAVING sale_date = <span class="hljs-string">&#x27;2007-10-01&#x27;</span>;

-- 聚合前使用 WHERE 子句过滤
SELECT sale_date, SUM(quantity)
  <span class="hljs-keyword">FROM</span> SalesHistory
 WHERE sale_date = <span class="hljs-string">&#x27;2007-10-01&#x27;</span> 
<span class="hljs-built_in"> GROUP </span>BY sale_date;</code></pre></div>
<p>使用第二条语句效率更高，原因主要有两点: </p>
<ol>
<li>使用 GROUP BY 子句进行聚合时会进行排序，如果事先通过 WHERE 子句能筛选出一部分行，能减轻排序的负担</li>
<li>在 WHERE 子句中可以使用索引，而 HAVING 子句是针对聚合后生成的视频进行筛选的，但很多时候聚合后生成的视图并没有保留原表的索引结构</li>
</ol>
<h6 id="4-在-GROUP-BY-子句和-ORDER-BY-子句中使用索引"><a href="#4-在-GROUP-BY-子句和-ORDER-BY-子句中使用索引" class="headerlink" title="4. 在 GROUP BY 子句和 ORDER BY 子句中使用索引"></a>4. 在 GROUP BY 子句和 ORDER BY 子句中使用索引</h6><p>GROUP BY 子句和 ORDER BY 子句一般都会进行排序，以对行进行排列和替换，<br>不过如果指定带有索引的列作为这两者的参数列，<br>由于用到了索引，可以实现高速查询，由于索引是有序的，排序本身都会被省略掉</p>
<h6 id="5-使用索引时，条件表达式的左侧应该是原始字段"><a href="#5-使用索引时，条件表达式的左侧应该是原始字段" class="headerlink" title="5. 使用索引时，条件表达式的左侧应该是原始字段"></a>5. 使用索引时，条件表达式的左侧应该是原始字段</h6><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *
  <span class="hljs-keyword">FROM</span> SomeTable
 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> * <span class="hljs-number">1.1</span> &gt; <span class="hljs-number">100</span>;

<span class="hljs-keyword">SELECT</span> *
  <span class="hljs-keyword">FROM</span> SomeTable
 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">SUBSTR</span>(<span class="hljs-keyword">col</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;a&#x27;</span>;</code></pre></div>
<p>第一个 SQL 在索引列上进行了运算, 第二个 SQL 对索引列使用了函数，均无法用到索引，正确方式是把列单独放在左侧,如下:</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> *
  <span class="hljs-attribute">FROM</span> SomeTable
 <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> &gt; <span class="hljs-number">100</span> / <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;</code></pre></div>

<h6 id="6-尽量避免使用否定形式"><a href="#6-尽量避免使用否定形式" class="headerlink" title="6. 尽量避免使用否定形式"></a>6. 尽量避免使用否定形式</h6><p>如下的几种否定形式不能用到索引：</p>
<ul>
<li>&lt;&gt;</li>
<li>!=</li>
<li>NOT IN<div class="hljs"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *
  <span class="hljs-keyword">FROM</span> SomeTable
 <span class="hljs-keyword">WHERE</span> col_1 &lt;&gt; <span class="hljs-number">100</span>;</code></pre></div>
第一条SQL 语句会导致全表扫描,可以改成以下形式: <div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> *
  <span class="hljs-attribute">FROM</span> SomeTable
 <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> &gt; <span class="hljs-number">100</span> or col_<span class="hljs-number">1</span> &lt; <span class="hljs-number">100</span>;</code></pre></div>

</li>
</ul>
<h6 id="7-进行默认的类型转换"><a href="#7-进行默认的类型转换" class="headerlink" title="7. 进行默认的类型转换"></a>7. 进行默认的类型转换</h6><p>假设 col 是 char 类型，则推荐使用以下第二，三条 SQL 的写法，不推荐第一条 SQL 的写法</p>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-number">10</span>;
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-string">&#x27;10&#x27;</span>;
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-keyword">CAST</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">AS</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">2</span>));</code></pre></div>
<h6 id="8-减少中间表"><a href="#8-减少中间表" class="headerlink" title="8. 减少中间表"></a>8. 减少中间表</h6><p>在 SQL 中，子查询的结果会产生一张新表，不过如果不加限制大量使用中间表的话，会带来两个问题，<br>一是展示数据需要消耗内存资源，<br>二是原始表中的索引不容易用到，所以尽量减少中间表也可以提升性能。</p>
<h6 id="9-灵活使用-HAVING-子句"><a href="#9-灵活使用-HAVING-子句" class="headerlink" title="9. 灵活使用 HAVING 子句"></a>9. 灵活使用 HAVING 子句</h6><p>这一点与上面第八条相呼应，对聚合结果指定筛选条件时，使用 HAVING 是基本的原则，可能一些工程师会倾向于使用下面这样的写法</p>
<div class="hljs"><pre><code class="hljs routeros">SELECT *
  <span class="hljs-keyword">FROM</span> (SELECT sale_date, MAX(quantity) AS max_qty
          <span class="hljs-keyword">FROM</span> SalesHistory 
        <span class="hljs-built_in"> GROUP </span>BY sale_date) TMP
         WHERE max_qty &gt;= 10;</code></pre></div>
<p>虽然上面这样的写法能达到目的，但会生成 TMP 这张临时表，HAVING 子句和聚合操作是同时执行的，<br>所以比起生成中间表后再执行 HAVING 子句，效率会更高，代码也更简洁</p>
<div class="hljs"><pre><code class="hljs routeros">SELECT sale_date, MAX(quantity) 
  <span class="hljs-keyword">FROM</span> SalesHistory
<span class="hljs-built_in"> GROUP </span>BY sale_date
HAVING MAX(quantity) &gt;= 10;</code></pre></div>

<h6 id="10-需要对多个字段使用-IN-谓词时，将它们汇总到一处"><a href="#10-需要对多个字段使用-IN-谓词时，将它们汇总到一处" class="headerlink" title="10. 需要对多个字段使用 IN 谓词时，将它们汇总到一处"></a>10. 需要对多个字段使用 IN 谓词时，将它们汇总到一处</h6><p>一个表的多个字段可能都使用了 IN 谓词，如下:</p>
<div class="hljs"><pre><code class="hljs pf">SELECT id, <span class="hljs-keyword">state</span>, city 
  FROM Addresses1 A1
 WHERE <span class="hljs-keyword">state</span> IN (SELECT <span class="hljs-keyword">state</span>
                   FROM Addresses2 A2
                  WHERE A1.id = A2.id) 
    AND city IN (SELECT city
                   FROM Addresses2 A2 
                  WHERE A1.id = A2.id);</code></pre></div>
<p>这段代码用到了两个子查询，也就产生了两个中间表，可以像下面这样写,<br>查询不用考虑关联性，没有中间表产生，而且只执行一次即可。</p>
<div class="hljs"><pre><code class="hljs pf">SELECT *
  FROM Addresses1 A1
 WHERE id || <span class="hljs-keyword">state</span> || city
 IN (SELECT id || <span class="hljs-keyword">state</span>|| city
       FROM Addresses2 A2);</code></pre></div>

<h6 id="11-使用延迟查询优化-limit-offset-rows"><a href="#11-使用延迟查询优化-limit-offset-rows" class="headerlink" title="11. 使用延迟查询优化 limit [offset], [rows]"></a>11. 使用延迟查询优化 limit [offset], [rows]</h6><div class="hljs"><pre><code class="hljs pgsql">### <span class="hljs-keyword">offset</span> 特别大
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> film <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span></code></pre></div>
<p>假设有以下 SQL,有组合索引（sex, rating）</p>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> &lt;cols&gt; <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">profiles</span> <span class="hljs-keyword">where</span> sex=<span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>;

<span class="hljs-comment">### 则上述写法可以改成如下写法</span>
<span class="hljs-keyword">SELECT</span> &lt;cols&gt; 
  <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">profiles</span> 
<span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span>
(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">form</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">profiles</span> <span class="hljs-keyword">where</span> x.sex=<span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>)
<span class="hljs-keyword">as</span> x <span class="hljs-keyword">using</span>(<span class="hljs-keyword">id</span>);</code></pre></div>

<h6 id="12-利用-LIMIT-1-取得唯一行"><a href="#12-利用-LIMIT-1-取得唯一行" class="headerlink" title="12. 利用 LIMIT 1 取得唯一行"></a>12. 利用 LIMIT 1 取得唯一行</h6><p>数据库引擎只要发现满足条件的一行数据则立即停止扫描，这种情况适用于只需查找一条满足条件的数据的情况</p>
<h6 id="13-注意组合索引，要符合最左匹配原则才能生效"><a href="#13-注意组合索引，要符合最左匹配原则才能生效" class="headerlink" title="13. 注意组合索引，要符合最左匹配原则才能生效"></a>13. 注意组合索引，要符合最左匹配原则才能生效</h6><p>假设存在这样顺序的一个联合索引“col_1, col_2, col_3”。这时，指定条件的顺序就很重要</p>
<div class="hljs"><pre><code class="hljs n1ql">○ <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> col_2 = <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> col_3 = <span class="hljs-number">500</span>;
○ <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 = <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> col_2 = <span class="hljs-number">100</span> ;
× <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_2 = <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> col_3 = <span class="hljs-number">500</span> ;</code></pre></div>
<p>前面两条会命中索引，第三条由于没有先匹配 col_1，导致无法命中索引，<br>另外如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引 拆分为多个索引。</p>
<h6 id="14-使用-LIKE-谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）"><a href="#14-使用-LIKE-谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）" class="headerlink" title="14. 使用 LIKE 谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）"></a>14. 使用 LIKE 谓词时，只有前方一致的匹配才能用到索引（最左匹配原则）</h6><div class="hljs"><pre><code class="hljs sql">× <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a&#x27;</span>;
× <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>;
○ <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SomeTable <span class="hljs-keyword">WHERE</span> col_1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;a%&#x27;</span>;</code></pre></div>
<p>上例中，只有第三条会命中索引，前面两条进行后方一致或中间一致的匹配无法命中索引</p>
<h6 id="15-简单字符串表达式"><a href="#15-简单字符串表达式" class="headerlink" title="15.  简单字符串表达式"></a>15.  简单字符串表达式</h6><p>模型字符串可以使用 _ 时， 尽可能避免使用 %, 假设某一列上为 char(5)</p>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 不推荐</span>
<span class="hljs-keyword">SELECT</span> 
    first_name, 
    last_name,
    homeroom_nbr
  <span class="hljs-keyword">FROM</span> Students
 <span class="hljs-keyword">WHERE</span> homeroom_nbr <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;A-1%&#x27;</span>;

<span class="hljs-comment">### 推荐</span>
<span class="hljs-keyword">SELECT</span> first_name, last_name
homeroom_nbr
  <span class="hljs-keyword">FROM</span> Students
 <span class="hljs-keyword">WHERE</span> homeroom_nbr <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;A-1__&#x27;</span>; <span class="hljs-comment">--模式字符串中包含了两个下划线</span></code></pre></div>

<h6 id="16-尽量使用自增-id-作为主键"><a href="#16-尽量使用自增-id-作为主键" class="headerlink" title="16. 尽量使用自增 id 作为主键"></a>16. 尽量使用自增 id 作为主键</h6><p>比如现在有一个用户表，有人说身份证是唯一的，也可以用作主键，理论上确实可以，不过用身份证作主键的话，<br>一是占用空间相对于自增主键大了很多，<br>二是很容易引起频繁的页分裂，造成性能问题（什么是页分裂，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247484006&idx=1&sn=3e15abeb5299a3e9b578332dd8565273&scene=21#wechat_redirect">请参考这篇文章</a>   ）<br>主键选择的几个原则：自增，尽量小，不要对主键进行修改</p>
<h6 id="17-在无-WHERE-条件下要计算表的行数，优先使用-count"><a href="#17-在无-WHERE-条件下要计算表的行数，优先使用-count" class="headerlink" title="17. 在无 WHERE 条件下要计算表的行数，优先使用 count(*)"></a>17. 在无 WHERE 条件下要计算表的行数，优先使用 count(*)</h6><p>优先使用以下语句来统计行数, innoDB 5.6之后已经对此语句进行了优化<br>按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(<em>)，count(</em>) 会选用性能最好的索引来进行排序</p>
<div class="hljs"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">FROM</span> SomeTable</code></pre></div>

<h6 id="18-避免使用-SELECT-，尽量利用覆盖索引来优化性能"><a href="#18-避免使用-SELECT-，尽量利用覆盖索引来优化性能" class="headerlink" title="18. 避免使用 SELECT * ，尽量利用覆盖索引来优化性能"></a>18. 避免使用 SELECT * ，尽量利用覆盖索引来优化性能</h6><p>SELECT * 会提取出一整行的数据，如果查询条件中用的是组合索引进行查找，<br>还会导致回表（先根据组合索引找到叶子节点，再根据叶子节点上的主键回表查询一整行），降低性能，<br>而如果我们所要的数据就在组合索引里，只需读取组合索引列，<br>这样网络带宽将大大减少,假设有组合索引列 (col_1, col_2)</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-comment">### 推荐用</span>
<span class="hljs-attribute">SELECT</span> col_<span class="hljs-number">1</span>, col_<span class="hljs-number">2</span> 
  <span class="hljs-attribute">FROM</span> SomeTable 
 <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> = xxx AND col_<span class="hljs-number">2</span> = xxx

<span class="hljs-comment">### 不推荐用</span>
<span class="hljs-attribute">SELECT</span> *
  <span class="hljs-attribute">FROM</span> SomeTable 
 <span class="hljs-attribute">WHERE</span> col_<span class="hljs-number">1</span> = xxx AND  col_<span class="hljs-number">2</span> = xxx</code></pre></div>

<h6 id="19-如有必要，使用-force-index-强制走某个索引"><a href="#19-如有必要，使用-force-index-强制走某个索引" class="headerlink" title="19. 如有必要，使用 force index() 强制走某个索引"></a>19. 如有必要，使用 force index() 强制走某个索引</h6><div class="hljs"><pre><code class="hljs 1c">SELECT *
  FROM  SomeTable
 WHERE `status` = <span class="hljs-number">0</span>
   AND `gmt_create` &gt; <span class="hljs-number">1490025600</span>
   AND `gmt_create` &lt; <span class="hljs-number">1490630400</span>
   AND `id` &gt; <span class="hljs-number">0</span>
   AND `post_id` IN (&#x27;<span class="hljs-number">6777</span>8&#x27;, &#x27;<span class="hljs-number">6781</span>1&#x27;, &#x27;<span class="hljs-number">6783</span>3&#x27;, &#x27;<span class="hljs-number">6783</span>4&#x27;, &#x27;<span class="hljs-number">6783</span>9&#x27;, &#x27;<span class="hljs-number">6785</span>2&#x27;, &#x27;<span class="hljs-number">6786</span>1&#x27;, &#x27;<span class="hljs-number">6786</span>8&#x27;, &#x27;<span class="hljs-number">6787</span>0&#x27;, &#x27;<span class="hljs-number">6787</span>8&#x27;, &#x27;<span class="hljs-number">6790</span>9&#x27;, &#x27;<span class="hljs-number">6794</span>8&#x27;, &#x27;<span class="hljs-number">6795</span>1&#x27;, &#x27;<span class="hljs-number">6796</span>3&#x27;, &#x27;<span class="hljs-number">6797</span>7&#x27;, &#x27;<span class="hljs-number">6798</span>3&#x27;, &#x27;<span class="hljs-number">6798</span>5&#x27;, &#x27;<span class="hljs-number">6799</span>1&#x27;, &#x27;<span class="hljs-number">6803</span>2&#x27;, &#x27;<span class="hljs-number">6803</span>8&#x27;/*... omitted <span class="hljs-number">480</span> items ...*/)
order by id asc limit <span class="hljs-number">200</span>;</code></pre></div>
<p>post_id 也加了索引，理论上走 post_id 索引会很快查询出来，但实现了通过 EXPLAIN 发现走的却是 id 的索引（这里隐含了一个常见考点，在多个索引的情况下, MySQL 会如何选择索引），<br>而 id &gt; 0 这个查询条件没啥用，直接导致了全表扫描，<br>所以在有多个索引的情况下一定要慎用，可以使用 force index 来强制走某个索引，<br>以这个例子为例，可以强制走 post_id 索引，效果立杆见影。</p>
<h6 id="20-批量插入，速度更快"><a href="#20-批量插入，速度更快" class="headerlink" title="20. 批量插入，速度更快"></a>20. 批量插入，速度更快</h6><p>当需要插入数据时，批量插入比逐条插入性能更高</p>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">### 推荐用</span>
<span class="hljs-comment">-- 批量插入</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> (<span class="hljs-keyword">id</span>, user_id, title) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;b&#x27;</span>);

<span class="hljs-comment">### 不推荐用</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> (<span class="hljs-keyword">id</span>, user_id, title) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> (<span class="hljs-keyword">id</span>, user_id, title) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;b&#x27;</span>);</code></pre></div>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Docker/">Docker</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/tags/Docker/">Docker</a>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/02/2020-07-02-IDEA%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">IDEA插件合集</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/06/02/2020-06-02-Docker%E9%83%A8%E7%BD%B2jar/">
                        <span class="hidden-mobile">Docker部署jar</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Square</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证336300号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=336300"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备336300号</span>
      </a>
     
  </div>


  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "MySQL性能优化&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>















</body>
</html>
